{"docs":[{"location":"/index.html","text":"","title":"Knora Documentation"},{"location":"/index.html#knora-documentation","text":"Release Notes v1.1.0 Release Notes v1.2.0 Release Notes v1.3.0 Release Notes v1.4.0 Release Notes v1.5.0 Release Notes (not released yet) Introduction What Is Knora? An Example Project Knora Ontologies Introduction The Knora Base Ontology The SALSAH GUI Ontology The Knora API Server Deployment Design Development Knora API v1 Knora API v2 Knora Admin API The SALSAH 1 GUI Running the automated tests The Sipi Media Server Setting Up Sipi for Knora Interaction Between Sipi and Knora","title":"Knora Documentation"},{"location":"/00-release-notes/index.html","text":"","title":"Release Notes"},{"location":"/00-release-notes/index.html#release-notes","text":"These are the release notes for each version of Knora.\nv1.1.0 Release Notes v1.2.0 Release Notes v1.3.0 Release Notes v1.4.0 Release Notes v1.5.0 Release Notes (not released yet)","title":"Release Notes"},{"location":"/00-release-notes/v1.1.0.html","text":"","title":"v1.1.0 Release Notes"},{"location":"/00-release-notes/v1.1.0.html#v1-1-0-release-notes","text":"See the release on Github.","title":"v1.1.0 Release Notes"},{"location":"/00-release-notes/v1.1.0.html#required-changes-to-existing-data-","text":"","title":"Required changes to existing data:"},{"location":"/00-release-notes/v1.1.0.html#1-project-ontologies-property-changed-","text":"The knora-base:projectOntologyGraph needs to be renamed to knora-base:projectOntology. Also before it was a xsd:string, where now it needs to be an IRI. The graph where the ontology is stored will need to have the same name.","title":"1. Project ontologies property changed:"},{"location":"/00-release-notes/v1.1.0.html#2-project-data-graph-property-removed-","text":"The property knora-base:projectDataGraph needs to be removed.","title":"2. Project data graph property removed:"},{"location":"/00-release-notes/v1.1.0.html#2-project-shortcode-property-added-","text":"The knora-base:projectShortcode property was added. When adding a project shortcode, we also need to update:\nthe IRI of the project to: http://rdfh.ch/projects/[shortcode] the IRIs all project ontologies to: http://www.knora.org/ontology/[shortcode]/[ontoname] the IRIs of lists to: http://rdfh.ch/lists/[shortcode]/[UUID] the IRIs of groups to: http://rdfh.ch/groups/[shortcode]/[UUID]","title":"2. Project shortcode property added:"},{"location":"/00-release-notes/v1.1.0.html#new-features-","text":"","title":"New features:"},{"location":"/00-release-notes/v1.1.0.html#bugfixes-","text":"","title":"Bugfixes:"},{"location":"/00-release-notes/v1.2.0.html","text":"","title":"v1.2.0 Release Notes"},{"location":"/00-release-notes/v1.2.0.html#v1-2-0-release-notes","text":"See the release and closed tickets on the v1.2.0 milestone on Github.","title":"v1.2.0 Release Notes"},{"location":"/00-release-notes/v1.2.0.html#required-changes-to-existing-data-","text":"","title":"Required changes to existing data:"},{"location":"/00-release-notes/v1.2.0.html#1-project-keywords-admin-data-","text":"Project keywords need to be transformed into sequences and property changed to projectKeyword (singular).\nbefore:\n<http://rdfh.ch/projects/00FF>\n        knora-base:projectKeywords \"images, collection\"^^xsd:string .\nafter:\n<http://rdfh.ch/projects/00FF>\n        knora-base:projectKeyword \"images\"^^xsd:string, \"collection\"^^xsd:string ;","title":"1. Project keywords (admin data)"},{"location":"/00-release-notes/v1.2.0.html#2-project-descriptions-admin-data-","text":"Project descriptions need to be transformed into sequences with language tag.\nbefore:\n<http://rdfh.ch/projects/00FF>\n        knora-base:projectDescription \"A demo project of a collection of images\"^^xsd:string .\nafter:\n<http://rdfh.ch/projects/00FF>\n        knora-base:projectDescription \"A demo project of a collection of images\"@en .","title":"2. Project descriptions (admin data)"},{"location":"/00-release-notes/v1.2.0.html#3-salsah-gui-guiorder","text":"The predicate salsah-gui:guiOrder is now attached to cardinalities in class definitions, instead of attaching it to property definitions. This allows the same property to be first in one class and last in another class.\nBefore:\n:title rdf:type owl:ObjectProperty ;\n  salsah-gui:guiOrder \"1\"^^xsd:integer .\nAfter:\n:book rdf:type owl:Class ;\n      rdfs:subClassOf knora-base:Resource ,\n                      [\n                         rdf:type owl:Restriction ;\n                         owl:onProperty :title ;\n                         owl:minCardinality \"1\"^^xsd:nonNegativeInteger ;\n                         salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger\n                      ]\nExisting project-specific ontologies must be updated. You can use the command-line tool org/knora/webapi/util/TransformOntology.scala to do this automatically. First dump your ontology to a Turtle file. Then at the sbt console, type:\nrunMain org.knora.webapi.util.TransformOntology -t guiorder INPUT OUTPUT\nFor INPUT, use the absolute path of the Turtle file representing your existing ontology. For OUTPUT, use the absolute path of the output file to be created.\nNote that, because of a limitation of the current version of the RDF4J Turtle generation library, the generated Turtle represents cardinalities as labelled blank nodes, rather than as anonymous blank nodes, which would be more readable (see this pull request).\nThen replace the contents of your ontology’s named graph in the triplestore with the contents of the transformed Turtle file, and restart the Knora API server. Be sure to test this on a test installation using a copy of your data and ontologies, before updating the ontology used by a live server.\nAlso, you have to replace the salsah-gui ontology that you have in the triplestore with the one in salsah-gui.ttl.","title":"3. salsah-gui:guiOrder"},{"location":"/00-release-notes/v1.2.0.html#new-features-","text":"General Change: Return differently formatted JSON responses for exception messages, depending on which route (v1, v2` or admin) was accessed. Admin API Change: Project shortcode is required for the creation of new projects Change: Project keywords are now a sequence. Needs change to existing data. Please see example above. Change: Project description has language tag and is returned as array. Needs change to existing data. Please see example above. Change: Remove institution from project (will be added later with the FAIR metadata) Change: Sorting of collections with admin objects (user, group, project) New: Keywords endpoint at /admin/projects/keywords returns all unique keywords (as strings) for all projects in an array New: Keywords endpoint at /admin/projects/keywords/[projectIri] returns all keywords of a single project. New: Lists endpoint at /admin/lists/ allows new lists to be created. New: Lists endpoint at /admin/lists/infos/<listIri> allows to change basic list information.","title":"New features:"},{"location":"/00-release-notes/v1.2.0.html#bugfixes-","text":"","title":"Bugfixes:"},{"location":"/00-release-notes/v1.3.0.html","text":"","title":"v1.3.0 Release Notes"},{"location":"/00-release-notes/v1.3.0.html#v1-3-0-release-notes","text":"See the release and closed tickets on the v1.3.0 milestone on Github.","title":"v1.3.0 Release Notes"},{"location":"/00-release-notes/v1.3.0.html#required-changes-to-existing-data-","text":"","title":"Required changes to existing data:"},{"location":"/00-release-notes/v1.3.0.html#1-replace-salsah-gui-ontology","text":"You must replace the salsah-gui ontology that you have in the triplestore with the one in salsah-gui.ttl.","title":"1. Replace salsah-gui ontology"},{"location":"/00-release-notes/v1.3.0.html#new-features-","text":"More support for salsah-gui elements and attributes in ontologies Serve the salsah-gui ontology in API v2 in the default schema. Show salsah-gui:guiElement and salsah-gui:guiAttribute when serving ontologies in API v2 in the default schema. Allow salsah-gui:guiElement and salsah-gui:guiAttribute to be included in new property definitions created via API v2. Change salsah-gui so that GraphDB’s consistency checker can check the use of guiElement and guiAttribute. Changes to application.conf. The sipi and web-api sections have received a big update, adding separate settings for internal and external host settings:\napp {\n    knora-api {\n        // relevant for direct communication inside the knora stack\n        internal-host = \"0.0.0.0\"\n        internal-port = 3333\n\n        // relevant for the client, i.e. browser\n        external-protocol = \"http\" // optional ssl termination needs to be done by the proxy\n        external-host = \"0.0.0.0\"\n        external-port = 3333\n    }\n\n    sipi {\n        // relevant for direct communication inside the knora stack\n        internal-protocol = \"http\"\n        internal-host = \"localhost\"\n        internal-port = 1024\n\n        // relevant for the client, i.e. browser\n        external-protocol = \"http\"\n        external-host = \"localhost\"\n        external-port = 1024\n\n        prefix = \"knora\"\n        file-server-path = \"server\"\n        path-conversion-route = \"convert_from_binaries\"\n        file-conversion-route = \"convert_from_file\"\n        image-mime-types = [\"image/tiff\", \"image/jpeg\", \"image/png\", \"image/jp2\"]\n        movie-mime-types = []\n        sound-mime-types = []\n    }\n\n    salsah1 {\n        base-url = \"http://localhost:3335/\"\n        project-icons-basepath = \"project-icons/\"\n    }\n}","title":"New features:"},{"location":"/00-release-notes/v1.3.0.html#bugfixes-","text":"When API v2 served knora-api (default schema), salsah-gui:guiElement and salsah-gui:guiAttribute were not shown in properties in that ontology. The predicate salsah-gui:guiOrder was not accepted when creating a property via API v2.","title":"Bugfixes:"},{"location":"/00-release-notes/v1.4.0.html","text":"","title":"v1.4.0 Release Notes"},{"location":"/00-release-notes/v1.4.0.html#v1-4-0-release-notes","text":"See the release and closed tickets on the v1.4.0 milestone on Github.","title":"v1.4.0 Release Notes"},{"location":"/00-release-notes/v1.4.0.html#required-changes-to-existing-data-","text":"Every ontology must now have the property knora-base:attachedToProject, which points to the IRI of the project that is responsible for the ontology. This must be added to each project-specific ontology in existing repositories. All built-in ontologies have been updated to have this property, and must therefore be reloaded into existing repositories. The property knora-base:projectOntology has been removed, and must be removed from project definitions in existing repositories. Every project now needs to have the property knora-base:projectShortcode set.","title":"Required changes to existing data:"},{"location":"/00-release-notes/v1.4.0.html#new-features-","text":"Added OpenAPI / Swagger API documentation route The Knora API server now checks the validity of ontologies on startup. The property knora-base:projectShortcode is now a required property (was optional).","title":"New features:"},{"location":"/00-release-notes/v1.4.0.html#bugfixes-","text":"API v1 extended search was not properly handling multiple conditions on list values (issue #800) Fix image orientation in SALSAH 1 (issue #726)","title":"Bugfixes:"},{"location":"/00-release-notes/v1.5.0.html","text":"","title":"v1.5.0 Release Notes (not released yet)"},{"location":"/00-release-notes/v1.5.0.html#v1-5-0-release-notes-not-released-yet-","text":"See the release and closed tickets on the v1.5.0 milestone on Github.","title":"v1.5.0 Release Notes (not released yet)"},{"location":"/00-release-notes/v1.5.0.html#required-changes-to-existing-data-","text":"","title":"Required changes to existing data:"},{"location":"/00-release-notes/v1.5.0.html#new-features-","text":"","title":"New features:"},{"location":"/00-release-notes/v1.5.0.html#bugfixes-","text":"","title":"Bugfixes:"},{"location":"/01-introduction/index.html","text":"","title":"Introduction"},{"location":"/01-introduction/index.html#introduction","text":"What Is Knora? An Example Project The Incunabula Ontology","title":"Introduction"},{"location":"/01-introduction/what-is-knora.html","text":"","title":"What Is Knora?"},{"location":"/01-introduction/what-is-knora.html#what-is-knora-","text":"Knora (Knowledge Organization, Representation, and Annotation) is a software framework for storing, sharing, and working with humanities data.\nKnora is based on the idea that the continuous availability and reusability of digital qualitative research data in the humanities requires a common, flexible data representation and storage technology capable of performing queries across large quantities of heterogeneous data, organised according to project-specific data structures that cannot be known in advance. It also requires a convenient, storage-independent way for Virtual Research Environments (VREs) and automated data-processing software to access, query, and add to this data.\nTo solve the data representation and storage problem, Knora represents humanities data as RDF graphs, using OWL ontologies that express abstract, cross-disciplinary commonalities in the structure and semantics of research data. Each project using Knora extends these abstractions by providing its own project-specific ontology, which more specifically describes the structure and semantics of its data. Existing non-RDF repositories can readily be converted to an RDF format based on the proposed abstractions. This design makes it possible to preserve the semantics of data imported from relational databases, XML-based markup systems, and other types of storage, as well as to query, annotate, and link together heterogeneous data in a unified way. By offering a shared, standards-based, extensible infrastructure for diverse humanities projects, Knora also deals with the issue of conversion and migration caused by the obsolescence of file and data formats in an efficient and feasible manner.\nTo solve the access problem, Knora offers a generic HTTP-based API. In the Knora framework, the standard implementation of this API is a server program called the Knora API Server. The Knora API allows applications to query and work with data in terms of the concepts expressed by the Knora ontologies, without dealing with the complexities of the underlying storage system and its query language (e.g. SPARQL). It also provides features that are not part of SPARQL, such as access control and automatic versioning of data. While the Knora API is best suited to interacting with RDF repositories based on the Knora ontologies, it can also be implemented as a gateway to other sorts of repositories, including non-RDF repositories.\nKnora uses a high-performance media server, called Sipi, for serving and converting binary media files such as images and video. Sipi can efficiently convert between many different formats on demand, preserving embedded metadata, and implements the International Image Interoperability Framework (IIIF).\nKnora provides a general-purpose, browser-based VRE called SALSAH, which relies on the components described above. Using the Knora API, a project can also create its own VRE or project-specific web site, optionally reusing components from SALSAH.\nKnora is thus a set of standard components that can be used separately or together, or extended to meet a project’s specific needs. You can learn more about each component:\nThe Knora ontologies, a set of OWL ontologies describing a common structure for describing humanities data in RDF. The Knora API server, a server program that implements an HTTP-based API for accessing and working with data stored in an RDF triplestore according to the structures defined in the Knora ontologies. Sipi, a high-performance media server. The SALSAH GUI (to be released soon), a web-based virtual research environment for working with data managed by the Knora API server.","title":"What Is Knora?"},{"location":"/01-introduction/example-project.html","text":"","title":"An Example Project"},{"location":"/01-introduction/example-project.html#an-example-project","text":"This section introduces some of the basic concepts involved in creating ontologies for Knora projects, by means of a relatively simple example project. Before reading this document, it will be helpful to have some familiarity with the basic concepts explained in knora-base.\nKnora comes with two example projects, called incunabula and images-demo. Here we will consider the incunabula example, which is a reduced version of a real research project on early printed books. It is designed to store an image of each page of each book, as well as RDF data about books, pages, their contents, and relationships between them. At the moment, only the RDF data is provided in the example project, not the images.\nThe incunabula ontology is in the file incunabula-onto.ttl, and its data is in the file incunabula-demo-data.ttl. Both these files are in a standard RDF file format called Turtle. The Knora distribution includes sample scripts (in the webapi/scripts directory) for importing these files directly into different triplestores. If you are starting a new project from scratch, you can adapt these scripts to import your ontology (and any existing RDF data) into your triplestore for use with Knora.\nThe syntax of Turtle is fairly simple: it is basically a sequence of triples. We will consider some details of Turtle syntax as we go along.","title":"An Example Project"},{"location":"/01-introduction/example-project.html#the-incunabula-ontology","text":"Here we will just focus on some of the main aspects of the ontology. An ontology file typically begins by defining prefixes for the IRIs of other ontologies that will be referred to. First there are some prefixes for ontologies that are very commonly used in RDF:\n@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix owl: <http://www.w3.org/2002/07/owl#> .\n@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .\n@prefix foaf: <http://xmlns.com/foaf/0.1/> .\n@prefix dcterms: <http://purl.org/dc/terms/> .\nThe rdf, rdfs, and owl ontologies contain basic properties that are used to define ontology entities. The xsd ontology contains definitions of literal data types such as string and integer. (For more information about these ontologies, see the references in knora-base.) The foaf ontology contains classes and properties for representing people. The dcterms ontology represents Dublin Core metadata.\nThen we define prefixes for Knora ontologies:\n@prefix knora-base: <http://www.knora.org/ontology/knora-base#> .\n@prefix salsah-gui: <http://www.knora.org/ontology/salsah-gui#> .\nThe knora-base ontology contains Knora’s core abstractions, and is described in knora-base. The salsah-gui ontology includes properties that Knora projects must use to enable SALSAH, Knora’s generic virtual research environment.\nFor convenience, we can use the empty prefix to refer to the incunabula ontology itself:\n@prefix : <http://www.knora.org/ontology/0803/incunabula#> .\nHowever, outside the ontology file, it would make more sense to define an incunabula prefix to refer to the incunabula ontology.","title":"The Incunabula Ontology"},{"location":"/01-introduction/example-project.html#properties","text":"All the content produced by a Knora project must be stored in Knora resources (see incunabula-resource-classes). Resources have properties that point to different parts of their contents; for example, the incunabula project contains books, which have properties like title. Every property that poitns to a Knora value must be a subproperty of knora-base:hasValue, and every property that points to another Knora resource must be a subproperty of knora-base:hasLinkTo.\nHere is the definition of the incunabula:title property:\n:title rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf knora-base:hasValue, dcterms:title ;\n\n  rdfs:label \"Titel\"@de ,\n    \"Titre\"@fr ,\n    \"Titolo\"@it ,\n    \"Title\"@en ;\n\n  knora-base:subjectClassConstraint :book ;\n\n  knora-base:objectClassConstraint knora-base:TextValue ;\n\n  salsah-gui:guiElement salsah-gui:SimpleText ;\n\n  salsah-gui:guiAttribute \"size=80\" ,\n    \"maxlength=255\" .\nThe definition of incunabula:title consists of a list of triples, all of which have :title as their subject. To avoid repeating :title for each triple, Turtle syntax allows us to use a semicolon (;) to separate triples that have the same subject. Moreover, some triples also have the same predicate; a comma (,) is used to avoid repeating the predicate. The definition of :title says:\nrdf:type owl:ObjectProperty: It is an owl:ObjectProperty. There are two kinds of OWL properties: object properties and datatype properties. Object properties point to objects, which have IRIs and can have their own properties. Datatype properties point to literal values, such as strings and integers. rdfs:subPropertyOf knora-base:hasValue, dcterms:title: It is a subproperty of knora-base:hasValue and dcterms:title. Since the objects of this property will be Knora values, it must be a subproperty of knora-base:hasValue. To facilitate searches, we have also chosen to make it a subproperty of dcterms:title. In the Knora API v2, if you do a search for resources that have a certain dcterms:title, and there is a resource with a matching incunabula:title, the search results could include that resource. rdfs:label \"Titel\"@de, etc.: It has the specified labels in various languages. These are needed, for example, by user interfaces, to prompt the user to enter a value. knora-base:subjectClassConstraint :book: The subject of the property must be an incunabula:book. knora-base:objectClassConstraint knora-base:TextValue: The object of this property must be a knora-base:TextValue (which is a subclass of knora-base:Value). salsah-gui:guiElement salsah-gui:SimpleText: When SALSAH asks a user to enter a value for this property, it should use a simple text field. salsah-gui:guiAttribute \"size=80\" , \"maxlength=255\": The SALSAH text field for entering a value for this property should be 80 characters wide, and should accept at most 255 characters.\nThe incunabula ontology contains several other property definitions that are basically similar. Note that different subclasses of Value are used. For example, incunabula:pubdate, which represents the publication date of a book, points to a knora-base:DateValue. The DateValue class stores a date range, with a specified degree of precision and a preferred calendar system for display.\nA property can point to a Knora resource instead of to a Knora value. For example, in the incunabula ontology, there are resources representing pages and books, and each page is part of some book. This relationship is expressed using the property incunabula:partOf:\n:partOf rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf knora-base:isPartOf ;\n\n  rdfs:label \"ist ein Teil von\"@de ,\n    \"est un part de\"@fr ,\n    \"e una parte di\"@it ,\n    \"is a part of\"@en ;\n\n  rdfs:comment \"\"\"Diese Property bezeichnet eine Verbindung zu einer anderen Resource, in dem ausgesagt wird, dass die vorliegende Resource ein integraler Teil der anderen Resource ist. Zum Beispiel ist eine Buchseite ein integraler Bestandteil genau eines Buches.\"\"\"@de ;\n\n  knora-base:subjectClassConstraint :page ;\n\n  knora-base:objectClassConstraint :book ;\n\n  salsah-gui:guiElement salsah-gui:Searchbox .\nThe key things to notice here are:\nrdfs:subPropertyOf knora-base:isPartOf: The Knora base ontology provides a generic isPartOf property to express part-whole relationships. Like many properties defined in knora-base, a project cannot use knora-base:isPartOf directly, but must make a subproperty such as incunabula:partOf. It is important to note that knora-base:isPartOf is a subproperty of knora-base:hasLinkTo. Any property that points to a knora-base:Resource must be a subproperty of knora-base:hasLinkTo. In Knora terminology, such a property is called a link property. knora-base:objectClassConstraint :book: The object of this property must be a member of the class incunabula:book, which, as we will see below, is a subclass of knora-base:Resource. salsah-gui:guiElement salsah-gui:Searchbox: When SALSAH prompts a user to select the book that a page is part of, it should provide a search box enabling the user to find the desired book.\nBecause incunabula:partOf is a link property, it must always accompanied by a link value property, which enables Knora to store metadata about each link that is created with the link property. This metadata includes the date and time when the link was created, its owner, the permissions it grants, and whether it has been deleted. Storing this metadata allows Knora to authorise users to see or modify the link, as well as to query a previous state of a repository in which a deleted link had not yet been deleted. (The ability to query previous states of a repository is planned for Knora API version 2.)\nThe name of a link property and its link value property must be related by the following naming convention: to determine the name of the link value property, add the word Value to the name of the link property. Hence, the incunabula ontology defines the property partOfValue:\n:partOfValue rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf knora-base:isPartOfValue ;\n\n  knora-base:subjectClassConstraint :page ;\n\n  knora-base:objectClassConstraint knora-base:LinkValue .\nAs a link value property, incunabula:partOfValue must point to a knora-base:LinkValue. The LinkValue class is an RDF reification of a triple (in this case, the triple that links a page to a book). For more details about this, see knora-base-linkvalue.\nNote that the property incunabula:hasAuthor points to a knora-base:TextValue, because the incunabula project repåresents authors simply by their names. A more complex project could represent each author as a resource, in which case incunabula:hasAuthor would need to be a subproperty of knora-base:hasLinkTo.","title":"Properties"},{"location":"/01-introduction/example-project.html#resource-classes","text":"The two main resource classes in the incunabula ontology are book and page. Here is incunabula:book:\n:book rdf:type owl:Class ;\n\n  rdfs:subClassOf knora-base:Resource , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :title ;\n    owl:minCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasAuthor ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :publisher ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :publoc ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"4\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :pubdate ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :location ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :url ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :description ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :physical_desc ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"9\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :note ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :citation ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :book_comment ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger\n  ] ;\n\n  knora-base:resourceIcon \"book.gif\" ;\n\n  rdfs:label \"Buch\"@de ,\n    \"Livre\"@fr ,\n    \"Libro\"@it ,\n    \"Book\"@en ;\n\n  rdfs:comment \"\"\"Diese Resource-Klasse beschreibt ein Buch\"\"\"@de .\nLike every Knora resource class, incunabula:book is a subclass of knora-base:Resource. It is also a subclass of a number of other classes of type owl:Restriction, which are defined in square brackets, using Turtle’s syntax for anonymous blank nodes. Each owl:Restriction specifies a cardinality for a property that is allowed in resources of type incunabula:book. A cardinality is indeed a kind of restriction: it means that a resource of this type may have, or must have, a certain number of instances of the specified property. For example, incunabula:book has cardinalities saying that a book must have at least one title and at most one publication date. In the Knora API version 1, the word ‘occurrence’ is used instead of ‘cardinality’.\nThe OWL cardinalities supported by Knora are described in OWL Cardinalities.\nNote that incunabula:book specifies a cardinality of owl:minCardinality 0 on the property incunabula:hasAuthor. At first glance, this might seem as if it serves no purpose, since it says that the property is optional and can have any number of instances. You may be wondering whether this cardinality could simply be omitted from the definition of incunabula:book. However, Knora requires every property of a resource to have some cardinality in the resource’s class. This is because Knora uses the cardinalities to determine which properties are possible for instances of the class, and the Knora API relies on this information. If there was no cardinality for incunabula:hasAuthor, Knora would not allow a book to have an author.\nEach owl:Restriction specifying a cardinality can include the predicate salsah-gui:guiOrder, which tells the SALSAH GUI the order the properties should be displayed in.\nHere is the definition of incunabula:page:\n:page rdf:type owl:Class ;\n\n  rdfs:subClassOf knora-base:StillImageRepresentation , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :pagenum ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"1\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :partOfValue ;\n    owl:cardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :partOf ;\n    owl:cardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :seqnum ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"3\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :description ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"2\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :citation ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"5\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :page_comment ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"6\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :origname ;\n    owl:cardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"7\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasLeftSidebandValue ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasLeftSideband ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"10\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasRightSidebandValue ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasRightSideband ;\n    owl:maxCardinality \"1\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"11\"^^xsd:nonNegativeInteger\n  ] , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :transcription ;\n    owl:minCardinality \"0\"^^xsd:nonNegativeInteger ;\n    salsah-gui:guiOrder \"12\"^^xsd:nonNegativeInteger\n  ] ;\n\n  knora-base:resourceIcon \"page.gif\" ;\n\n  rdfs:label \"Seite\"@de ,\n    \"Page\"@fr ,\n    \"Page\"@en ;\n\n  rdfs:comment \"\"\"Eine Seite ist ein Teil eines Buchs\"\"\"@de ,\n    \"\"\"Une page est une partie d'un livre\"\"\"@fr ,\n    \"\"\"A page is a part of a book\"\"\"@en .\nThe incunabula:page class is a subclass of knora-base:StillImageRepresentation, which is a subclass of knora-base:Representation, which is a subclass of knora-base:Resource. The class knora-base:Representation is used for resources that contain metadata about files stored by Knora. Each It has different subclasses that can hold different types of files, including still images, audio, and video files. A given Representation can store metadata about several different files, as long as they are of the same type and are semantically equivalent, e.g. are different versions of the same image with different colorspaces, so that coordinates in one file will work in the other files.\nIn Knora, a subclass inherits the cardinalities defined in its superclasses. Let’s look at the class hierarchy of incunabula:page, starting with knora-base:Representation:\n:Representation rdf:type owl:Class ;\n\n  rdfs:subClassOf :Resource , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasFileValue ;\n    owl:minCardinality \"1\"^^xsd:nonNegativeInteger\n  ] ;\n\n  rdfs:comment \"A resource that can store one or more FileValues\"@en .\nThis says that a Representation must have at least one instance of the property hasFileValue, which is defined like this:\n:hasFileValue rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf :hasValue ;\n\n  :subjectClassConstraint :Representation ;\n\n  :objectClassConstraint :FileValue .\nThe subject of hasFileValue must be a Representation, and its object must be a FileValue. There are different subclasses of FileValue for different kinds of files, but we’ll skip the details here.\nThis is the definition of knora-base:StillImageRepresentation:\n:StillImageRepresentation rdf:type owl:Class ;\n\n  rdfs:subClassOf :Representation , [\n    rdf:type owl:Restriction ;\n    owl:onProperty :hasStillImageFileValue ;\n    owl:minCardinality \"1\"^^xsd:nonNegativeInteger\n  ] ;\n\n  rdfs:comment \"A resource that can contain two-dimensional still image files\"@en .\nIt must have at least one instance of the property hasStillImageFileValue, which is defined as follows:\n:hasStillImageFileValue rdf:type owl:ObjectProperty ;\n\n  rdfs:subPropertyOf :hasFileValue ;\n\n  :subjectClassConstraint :StillImageRepresentation ;\n\n  :objectClassConstraint :StillImageFileValue .\nBecause hasStillImageFileValue is a subproperty of hasFileValue, the cardinality on hasStillImageFileValue, defined in the subclass StillImageRepresentation, overrides the cardinality on hasFileValue, defined in the superclass Representation. In other words, the more general cardinality in the superclass is replaced by a more specific cardinality in the base class. Since incunabula:page is a subclass of StillImageRepresentation, it inherits the cardinality on hasStillImageFileValue. As a result, a page must have at least one image file attached to it.\nHere’s another example of cardinality inheritance. The class knora-base:Resource has a cardinality for knora-base:seqnum. The idea is that resources of any type could be arranged in some sort of sequence. As we saw above, incunabula:page is a subclass of knora-base:Resource. But incunabula:page has its own cardinality for incunabula:seqnum, which is a subproperty of knora-base:seqnum. Once again, the subclass’s cardinality on the subproperty replaces the superclass’s cardinality on the superproperty: a page is allowed to have an incunabula:seqnum, but it is not allowed to have a knora-base:seqnum.","title":"Resource Classes"},{"location":"/02-knora-ontologies/index.html","text":"","title":"Knora Ontologies"},{"location":"/02-knora-ontologies/index.html#knora-ontologies","text":"Introduction Resource Description Framework (RDF) Built-in Ontologies and Project-specific Ontologies The Knora Base Ontology Overview The Knora Data Model Summary of Restrictions on Project-Specific Ontologies Standardisation The SALSAH GUI Ontology Overview Properties Classes Individuals\nThe Knora ontologies provide a generic framework for describing humanities research data, allowing data from different projects to be combined, augmented, and reused.","title":"Knora Ontologies"},{"location":"/02-knora-ontologies/introduction.html","text":"","title":"Introduction"},{"location":"/02-knora-ontologies/introduction.html#introduction","text":"Resource Description Framework (RDF) Built-in Ontologies and Project-specific Ontologies","title":"Introduction"},{"location":"/02-knora-ontologies/introduction.html#resource-description-framework-rdf-","text":"Knora uses a hierarchy of ontologies based on the Resource Description Framework (RDF), RDF Schema (RDFS), and the Web Ontology Language (OWL). Both RDFS and OWL are expressed in RDF. RDF expresses information as a set of statements (called triples). A triple consists of a subject, a predicate, and an object:\nThe object may be either a literal value (such as a name or number) or another subject. Thus it is possible to create complex graphs that connect many subjects, like this:\nIn RDF, each subject and predicate has a unique, URL-like identifier called an Internationalized Resource Identifier (IRI). Within a given project, IRIs typically differ only in their last component (the “local part”), which is often the fragment following a # character. Such IRIs share a long “prefix”. In Turtle and similar formats for writing RDF, a short prefix label can be defined to represent the long prefix. Then an IRI can be written as a prefix label and a local part, separated by a colon (:). For example, if the “example” project’s long prefix is http://www.example.org/rdf#, and it contains subjects with IRIs like http://www.example.org/rdf#book, we can define the prefix label ex to represent the prefix label, and write prefixed names for IRIs:","title":"Resource Description Framework (RDF)"},{"location":"/02-knora-ontologies/introduction.html#built-in-ontologies-and-project-specific-ontologies","text":"To ensure the interoperability of data produced by different projects, each project must describe its data model by creating ontologies that extend Knora's built-in ontologies. The main built-in ontology in Knora is knora-base.","title":"Built-in Ontologies and Project-specific Ontologies"},{"location":"/02-knora-ontologies/knora-base.html","text":"","title":"The Knora Base Ontology"},{"location":"/02-knora-ontologies/knora-base.html#the-knora-base-ontology","text":"Overview The Knora Data Model Projects Ontologies Resources Values Links Between Resources Text with Standoff Markup Authorisation Users and Groups Permissions Consistency Checking OWL Cardinalities Constraints on the Types of Property Subjects and Objects Consistency Constraint Example Summary of Restrictions on Project-Specific Ontologies Restrictions on Classes Restrictions on properties Standardisation","title":"The Knora Base Ontology"},{"location":"/02-knora-ontologies/knora-base.html#overview","text":"The Knora base ontology is the main built-in Knora ontology. Each project that uses Knora must describe its data model by creating ontologies that extend this ontology.\nThe Knora base ontology is identified by the IRI http://www.knora.org/ontology/knora-base. In the Knora documentation in general, it is identified by the prefix knora-base, but for brevity, in this document, we use kb or omit the prefix entirely.","title":"Overview"},{"location":"/02-knora-ontologies/knora-base.html#the-knora-data-model","text":"The Knora data model is based on the observation that, in the humanities, a value or literal is often itself structured and can be highly complex. Moreover, a value may have its own metadata, such as its creation date, information about permissions, and so on. Therefore, the Knora base ontology describes structured value types that can store this type of metadata. In the diagram below, a book (ex:book2) has a title (identified by the predicate ex:title) and a publication date (ex:pubdate), each of which has some metadata.","title":"The Knora Data Model"},{"location":"/02-knora-ontologies/knora-base.html#projects","text":"In Knora, each item of data belongs to some particular project. Each project using Knora must define a kb:knoraProject, which has these properties (cardinalities are indicated in parentheses after each property name):\nprojectShortname (1) A short name that can be used to identify the project in configuration files and the like. projectLongname (1) The full name of the project. projectShortcode (1) A hexadecimal code that uniquely identifies the project. These codes are assigned to projects by the DaSCH. projectDescription (0-1) A description of the project. belongsToInstitution (0-1) The kb:Institution that the project belongs to.\nOntologies, resources, and valuesare associated with a project by means of the kb:attachedToProject property, as described in Ontologies and Properties of Resource). Users are associated with a project by means of the kb:isInProject property, as described in Users and Groups.","title":"Projects"},{"location":"/02-knora-ontologies/knora-base.html#ontologies","text":"Each project-specific ontology must be defined as an owl:Ontology with the properties rdfs:label and kb:attachedToProject.","title":"Ontologies"},{"location":"/02-knora-ontologies/knora-base.html#resources","text":"All the content produced by a project (e.g. digitised primary source materials or research data) must be stored in objects that belong to subclasses of kb:Resource, so that the Knora API server can query and update that content. Each project using the Knora base ontology must define its own OWL classes, derived from kb:Resource, to represent the types of data it deals with. A subclass of kb:Resource may additionally be a subclass of any other class, e.g. an industry-standard class such as foaf:Person; this can facilitate searches across projects.\nResources have properties that point to different parts of the content they contain. For example, a resource representing a book could have a property called hasAuthor, pointing to the author of the book. There are two possible kinds of content in a Knora resource: Knora values (see Values) or links to other resources (see Links Between Resources). Properties that point to Knora values must be subproperties of kb:hasValue, and properties that point to other resources must be subproperties of kb:hasLinkTo. Either of these two types of properties may also be a subproperty of any other property, e.g. an industry-standard property such as foaf:name; this can facilitate searches across projects. Each property definition must specify the types that its subjects and objects must belong to (see Constraints on the Types of Property Subjects and Objects for details).\nEach project-specific resource class definition must use OWL cardinality restrictions to specify the properties that resources of that class can have (see OWL Cardinalities for details).\nResources are not versioned; only their values are versioned (see Values).\nEvery resource is required to have an rdfs:label. The object of this property is an xsd:string, rather than a Knora value; hence it is not versioned. A user who has modify permission on a resource (see Authorisation) can change its label.\nA resource can be marked as deleted; the Knora API server does this by adding the predicate kb:isDeleted true to the resource. An optional kb:deleteComment may be added to explain why the resource has been marked as deleted. Deleted resources are normally hidden. They cannot be undeleted, because even though resources are not versioned, it is necessary to be able to find out when a resource was deleted. If desired, a new resource can be created by copying data from a deleted resource.","title":"Resources"},{"location":"/02-knora-ontologies/knora-base.html#properties-of-resource","text":"creationDate (1) The time when the resource was created. attachedToUser (1) The user who owns the resource. attachedToProject (1) The project that the resource is part of. lastModificationDate (0-1) A timestamp indicating when the resource (or one of its values) was last modified. seqnum (0-1) The sequence number of the resource, if it is part of an ordered group of resources, such as the pages in a book. isDeleted (1) Indicates whether the resource has been deleted. deleteDate (0-1) If the resource has been deleted, indicates when it was deleted. deleteComment (0-1) If the resource has been deleted, indicates why it was deleted.\nResources can have properties that point to other resources; see Links Between Resources. A resource grants permissions to groups of users; see Authorisation.","title":"Properties of Resource"},{"location":"/02-knora-ontologies/knora-base.html#representations","text":"It is not practical to store all data in RDF. In particular, RDF is not a good storage medium for binary data such as images. Therefore, Knora stores such data outside the triplestore, in ordinary files. A resource can have one or more files attached to it. For each file, there is a kb:FileValue in the triplestore containing metadata about the file (see FileValue. A resource that has file values must belong to one of the subclasses of kb:Representation. The base class Representation, which is not intended to be used directly, has this property:\nhasFileValue (1-n) Points to one or more file values.\nIts subclasses, which are intended to be used directly in data, include:\nStillImageRepresentation A representation containing still image files. MovingImageRepresentation A representation containing video files. AudioRepresentation A representation containing audio files. DDDrepresentation A representation containing 3D images. TextRepresentation A representation containing formatted text files, such as XML files. DocumentRepresentation A representation containing documents (such as PDF files) that are not text files.\nThere are two ways for a project to design classes for representations. The simpler way is to create a resource class that represents a thing in the world (such as ex:Painting) and also belongs to a subclass of Representation. This is adequate if the class can have only one type of file attached to it. For example, if paintings are represented only by still images, ex:Painting could be a subclass of StillImageRepresentation. This is the only approach supported in version 1 of the Knora API.\nThe more flexible approach, which is allowed by the Knora base ontology and will be supported by version 2 of the Knora API, is for each ex:Painting to use the kb:hasRepresentation property to point to other resources containing files that represent the painting. Each of these other resources can extend a different subclass of Representation. For example, a painting could have a StillImageRepresentation as well as a DDDrepresentation.","title":"Representations"},{"location":"/02-knora-ontologies/knora-base.html#standard-resource-classes","text":"In general, each project using Knora must define its own subclasses of kb:Resource. However, the Knora base ontology provides some standard subclasses of kb:Resource, which are intended to be used by any project:\nRegion Represents a region of a Representation (see Representations). Annotation Represents an annotation of a resource. The hasComment property points to the text of the annotation, represented as a kb:TextValue. LinkObj Represents a link that connects two or more resources. A LinkObj has a hasLinkTo property pointing to each resource that it connects, as well as a hasLinkToValue property pointing to a reification of each of these direct links (see Links Between Resources). A LinkObj is more complex (and hence less convenient and readable) than a simple direct link, but it has the advantage that it can be annotated using an Annotation. For improved readability, a project can make its own subclasses of LinkObj with specific meanings.","title":"Standard Resource Classes"},{"location":"/02-knora-ontologies/knora-base.html#values","text":"The Knora base ontology defines a set of OWL classes that are derived from kb:Value and represent different types of structured values found in humanities data. This set of classes may not be extended by project-specific ontologies.\nA value is always part of one particular resource, which points to it using some property derived from hasValue. For example, a project-specific ontology could specify a Book class with a property hasSummary (derived from hasValue), and that property could have a knora-base:objectClassConstraint of TextValue. This would mean that the summary of each book is represented as a TextValue.\nKnora values are versioned. Existing values are not modified. Instead, a new version of an existing value is created. The new version is linked to the old version via the previousValue property.\n“Deleting” a value means marking it with kb:isDeleted. An optional kb:deleteComment may be added to explain why the value has been marked as deleted. Deleted values are normally hidden.\nMost types of values are marked as deleted without creating a new version of the value. However, link values must be treated as a special case. Before a LinkValue can be marked as deleted, its reference count must be decremented to 0. Therefore, a new version of the LinkValue is made, with a reference count of 0, and it is this new version that is marked as deleted.\nTo simplify the enforcement of ontology constraints, and for consistency with resource updates, no new versions of a deleted value can be made; it is not possible to undelete. Instead, if desired, a new value can be created by copying data from a deleted value.","title":"Values"},{"location":"/02-knora-ontologies/knora-base.html#properties-of-value","text":"valueCreationDate (1) The date and time when the value was created. attachedToUser (1) The user who owns the value. attachedToProject (0-1) The project that the value is part of. If not specified, defaults to the project of the containing resource. valueHasString (1) A human-readable string representation of the value’s contents, which is available to Knora’s full-text search index. valueHasOrder (0-1) A resource may have several properties of the same type with different values (which will be of the same class), and it may be necessary to indicate an order in which these values occur. For example, a book may have several authors which should appear in a defined order. Hence, valueHasOrder, when present, points to an integer literal indicating the order of a given value relative to the other values of the same property. These integers will not necessarily start at any particular number, and will not necessarily be consecutive. previousValue (0-1) The previous version of the value. isDeleted (1) Indicates whether the value has been deleted. deleteDate (0-1) If the value has been deleted, indicates when it was deleted. deleteComment (0-1) If the value has been deleted, indicates why it was deleted.\nEach Knora value can grant permissions (see Authorisation).","title":"Properties of Value"},{"location":"/02-knora-ontologies/knora-base.html#subclasses-of-value","text":"","title":"Subclasses of Value"},{"location":"/02-knora-ontologies/knora-base.html#textvalue","text":"Represents text, possibly including markup. The text is the object of the valueHasString property. A line break is represented as a Unicode line feed character (U+000A). The non-printing Unicode character INFORMATION SEPARATOR TWO (U+001E) can be used to separate words that are separated only by standoff markup (see below), so they are recognised as separate in a full-text search index.\nMarkup is stored using this property:\nvalueHasStandoff (0-n) Points to a standoff markup tag. See Text with Standoff Markup. valueHasMapping (0-1) Points to the mapping used to create the standoff markup and to convert it back to the original XML. See Mapping to Create Standoff From XML.","title":"TextValue"},{"location":"/02-knora-ontologies/knora-base.html#datevalue","text":"Humanities data includes many different types of dates. In Knora, a date has a specified calendar, and is always represented as a period with start and end points (which may be equal), each of which has a precision (DAY, MONTH, or YEAR). An optional ERA indicator term (BCE, CE, or BC, AD) can be added to the date, when no era is provided the default era AD will be considered. Internally, the start and end points are stored as two Julian Day Numbers. This calendar-independent representation makes it possible to compare and search for dates regardless of the calendar in which they were entered. Properties:\nvalueHasCalendar (1) The name of the calendar in which the date should be displayed. Currently GREGORIAN and JULIAN are supported. valueHasStartJDN (1) The Julian Day Number of the start of the period (an xsd:integer). valueHasStartPrecision (1) The precision of the start of the period. valueHasEndJDN (1) The Julian Day Number of the end of the period (an xsd:integer). valueHasEndPrecision (1) The precision of the end of the period.","title":"DateValue"},{"location":"/02-knora-ontologies/knora-base.html#intvalue","text":"Represents an integer. Property:\nvalueHasInteger (1) An xsd:integer.","title":"IntValue"},{"location":"/02-knora-ontologies/knora-base.html#colorvalue","text":"valueHasColor (1) A string representing a color. The string encodes a color as hexadecimal RGB values, e.g. \"#FF0000\".","title":"ColorValue"},{"location":"/02-knora-ontologies/knora-base.html#decimalvalue","text":"Represents an arbitrary-precision decimal number. Property:\nvalueHasDecimal (1) An xsd:decimal.","title":"DecimalValue"},{"location":"/02-knora-ontologies/knora-base.html#urivalue","text":"Represents a non-Knora URI. Property:\nvalueHasUri (1) An xsd:anyURI.","title":"UriValue"},{"location":"/02-knora-ontologies/knora-base.html#booleanvalue","text":"Represents a boolean value. Property:\nvalueHasBoolean (1) An xsd:boolean.","title":"BooleanValue"},{"location":"/02-knora-ontologies/knora-base.html#geomvalue","text":"Represents a geometrical object as a JSON string, using normalized coordinates. Property:\nvalueHasGeometry (1) A JSON string.","title":"GeomValue"},{"location":"/02-knora-ontologies/knora-base.html#geonamevalue","text":"Represents a geolocation, using the identifiers found at GeoNames. Property:\nvalueHasGeonameCode (1) the identifier of a geographical feature from GeoNames, represented as an xsd:string.","title":"GeonameValue"},{"location":"/02-knora-ontologies/knora-base.html#intervalvalue","text":"Represents a time interval, with precise start and end times on a timeline, e.g. relative to the beginning of an audio or video file. Properties:\nvalueHasIntervalStart (1) An xsd:decimal representing the start of the interval in seconds. valueHasIntervalEnd (1) An xsd:decimal representing the end of the interval in seconds.","title":"IntervalValue"},{"location":"/02-knora-ontologies/knora-base.html#listvalue","text":"Projects often need to define lists or hierarchies of categories that can be assigned to many different resources. Then, for example, a user interface can provide a drop-down menu to allow the user to assign a category to a resource. The ListValue class provides a way to represent these sorts of data structures. It can represent either a flat list or a tree.\nA ListValue has this property:\nvalueHasListNode (1) Points to a ListNode.\nEach ListNode can have the following properties:\nisRootNode (0-1) Set to true if this is the root node. hasSubListNode (0-n) Points to the node’s child nodes, if any. hasRootNode (0-1) Points to the root node of the list (absent if isRootNode is true). listNodePosition (0-1) An integer indicating the node’s position in the list of its siblings (absent if isRootNode is true). listNodeName (0-1) The node’s human-readable name (absent if isRootNode is true).","title":"ListValue"},{"location":"/02-knora-ontologies/knora-base.html#filevalue","text":"Knora stores certain kinds of data outside the triplestore, in files (see Representations). Each digital object that is stored outside the triplestore has associated metadata, which is stored in the triplestore in a kb:FileValue. The base class FileValue, which is not intended to be used directly, has these properties:\ninternalFilename (1) The name of the file as stored by the Knora API server. internalMimeType (1) The MIME type of the file as stored by the Knora API server. originalFilename (0-1) The original name of the file when it was uploaded to the Knora API server. originalMimeType (0-1) The original MIME type of the file when it was uploaded to the Knora API server. isPreview (0-1) A boolean indicating whether the file is a preview, i.e. a small image representing the contents of the file. A preview is always a StillImageFileValue, regardless of the type of the enclosing Representation.\nThe subclasses of FileValue, which are intended to be used directly in data, include:\nStillImageFileValue Contains metadata about a still image file. MovingImageFileValue Contains metadata about a video file. AudioFileValue Contains metadata about an audio file. DDDFileValue Contains metadata about a 3D image file. TextFileValue Contains metadata about a text file. DocumentFileValue Contains metadata about a document (such as PDF) that is not a text file.\nEach of these classes contains properties that are specific to the type of file it describes. For example, still image files have dimensions, video files have frame rates, and so on.\nThe files in a given representation must be semantically equivalent, meaning that coordinates that relate to one file must also be valid for other files in the same representation. Coordinates in Knora are expressed as fractions of the size of the object on some dimension; for example, image coordinates are expressed as fractions of its width and height, rather than in pixels. Therefore, the image files in a StillImageRepresentation must have the same aspect ratio, but they need not have the same dimensions in pixels. Similarly, the audio and video files in an AudioRepresentation or MovingImageRepresentation must have the same length in seconds, but may have different bitrates.\nFileValue objects are versioned like other values, and the actual files stored by Knora are also versioned. Version 1 of the Knora API does not provide a way to retrieve a previous version of a file, but this feature will be added in a subsequent version of the API.","title":"FileValue"},{"location":"/02-knora-ontologies/knora-base.html#linkvalue","text":"A LinkValue is an RDF “reification” containing metadata about a link between two resources. It is therefore a subclass of rdf:Statement as well as of Value. It has these properties:\nrdf:subject (1) The resource that is the source of the link. rdf:predicate (1) The link property. rdf:object (1) The resource that is the target of the link. valueHasRefCount (1) The reference count of the link. This is meaningful when the LinkValue describes resource references in Standoff text markup (see StandoffLinkTag). Otherwise, the reference count will always be 1 (if the link exists) or 0 (if it has been deleted).\nFor details about how links are created in Knora, see Links Between Resources.","title":"LinkValue"},{"location":"/02-knora-ontologies/knora-base.html#externalresvalue","text":"Represents a resource that is not stored in the RDF triplestore managed by the Knora API server, but instead resides in an external repository managed by some other software. The ExternalResValue contains the information that the Knora API server needs in order to access the resource, assuming that a suitable gateway plugin is installed.\nextResAccessInfo (1) The location of the repository containing the external resource (e.g. its URL). extResId (1) The repository-specific ID of the external resource. extResProvider (1) The name of the external provider of the resource.","title":"ExternalResValue"},{"location":"/02-knora-ontologies/knora-base.html#links-between-resources","text":"A link between two resources is expressed, first of all, as a triple, in which the subject is the resource that is the source of the link, the predicate is a “link property” (a subproperty of kb:hasLinkTo), and the object is the resource that is the target of the link.\nIt is also useful to store metadata about links. For example, Knora needs to know who owns the link, who has permission to modify it, when it was created, and so on. Such metadata cannot simply describe the link property, because then it would refer to that property in general, not to any particular instance in which that property is used to connect two particular resources. To attach metadata to a specific link in RDF, it is necessary to create an RDF “reification”. A reification makes statements about a particular triple (subject, predicate, object), in this case the triple that expresses the link between the resources. Knora uses reifications of type kb:LinkValue (described in LinkValue to store metadata about links.\nFor example, suppose a project describes paintings that belong to collections. The project can define an ontology as follows (expressed here in Turtle format, and simplified for the purposes of illustration):\n@prefix kb <http://www.knora.org/ontology/knora-base#> .\n@prefix : <http://www.knora.org/ontology/paintings#> .\n\n:Painting rdf:type owl:Class ;\n    rdfs:subClassOf kb:Resource ,\n        [ rdf:type owl:Restriction ;\n            owl:onProperty :hasArtist ;\n            owl:cardinality 1 ] ,\n        [ rdf:type owl:Restriction ;\n              owl:onProperty :hasTitle ;\n              owl:cardinality 1 ] ;\n        [ rdf:type owl:Restriction ;\n              owl:onProperty :isInCollection ;\n              owl:minCardinality 1 ] ;\n        [ rdf:type owl:Restriction ;\n              owl:onProperty :isInCollectionValue ;\n              owl:minCardinality 1 ] .\n\n:Collection rdf:type owl:Class ;\n    rdfs:subClassOf kb:Resource ,\n        [ rdf:type owl:Restriction ;\n            owl:onProperty :hasCollectionName ;\n            owl:cardinality 1 ] .\n\n:hasArtist rdf:type owl:ObjectProperty ;\n    rdfs:label \"Name of artist\" ;\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint kb:TextValue .\n\n:hasTitle rdf:type owl:ObjectProperty ;\n    rdfs:label \"Title of painting\"\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint kb:TextValue .\n\n:hasCollectionName rdf:type owl:ObjectProperty ;\n    rdfs:label \"Name of collection\" ;\n    kb:subjectClassConstraint :Collection ;\n    kb:objectClassConstraint kb:TextValue .\nTo link the paintings to the collection, we must add a “link property” to the ontology. In this case, the link property will point from a painting to the collection it belongs to. Every link property must be a subproperty of kb:hasLinkTo.\n:isInCollection rdf:type owl:ObjectProperty ;\n    rdfs:subPropertyOf kb:hasLinkTo ;\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint :Collection .\nWe must then add a “link value property”, which will point from a painting to a kb:LinkValue (described in LinkValue), which will contain metadata about the link between the property and the collection. In particular, the link value specifies the creator of the link, the date when it was created, and the permissions that determine who can view or modify it. The name of the link value property is constructed using a simple naming convention: the word Value is appended to the name of the link property. In this case, since our link property is called :isInCollection, the link value property must be called :isInCollectionValue. Every link value property must be a subproperty of kb:hasLinkToValue.\n:isInCollectionValue rdf:type owl:ObjectProperty ;\n    rdfs:subPropertyOf kb:hasLinkToValue ;\n    kb:subjectClassConstraint :Painting ;\n    kb:objectClassConstraint kb:LinkValue .\nGiven this ontology, we can create some RDF data describing a painting and a collection:\n@prefix paintings <http://www.knora.org/ontology/paintings#> .\n@prefix data <http://www.knora.org/ontology/paintings/data#> .\n\ndata:dali_4587 rdf:type paintings:Painting ;\n    paintings:hasTitle data:value_A ;\n    paintings:hasArtist data:value_B .\n\ndata:value_A rdf:type kb:TextValue ;\n    kb:valueHasString \"The Persistence of Memory\" .\n\ndata:value_B rdf:type kb:TextValue ;\n    kb:valueHasString \"Salvador Dali\" .\n\ndata:pompidou rdf:type paintings:Collection ;\n    paintings:hasCollectionName data:value_C .\n\ndata:value_C rdf:type kb:TextValue ;\n    kb:valueHasString \"Centre Pompidou, Paris\" .\nWe can then state that the painting is in the collection:\ndata:dali_4587 paintings:isInCollection data:pompidou ;\n    paintings:isinCollectionValue data:value_D .\n\ndata:value_D rdf:type kb:LinkValue ;\n    rdf:subject data:dali_4587 ;\n    rdf:predicate paintings:isInCollection ;\n    rdf:object data:pompidou ;\n    kb:valueHasRefCount 1 .\nThis creates a link (paintings:isInCollection) between the painting and the collection, along with a reification containing metadata about the link. We can visualise the result as the following graph:\nThe Knora API server allows a user to see a link if the requesting user has permission to see the source and target resources as well as the kb:LinkValue.","title":"Links Between Resources"},{"location":"/02-knora-ontologies/knora-base.html#text-with-standoff-markup","text":"Knora is designed to be able to store text with markup, which can indicate formatting and structure, as well as the complex observations involved in transcribing handwritten manuscripts. One popular way of representing text in the humanities is to encode it in XML using the Text Encoding Initiative (TEI) guidelines. In Knora, a TEI/XML document can be stored as a file with attached metadata, but this is not recommended, because it does not allow Knora to perform searches across multiple documents.\nThe recommended way to store text with markup in Knora is to use Knora’s built-in support for “standoff” markup, which is stored separately from the text. This has some advantages over embedded markup such as XML. While XML requires markup to have a hierarchical structure, and does not allow overlapping tags, standoff nodes do not have these limitations (see Using Standoff Properties for Marking-up Historical Documents in the Humanities). A standoff tag can be attached to any substring in the text by giving its start and end positions. Unlike in corpus linguistics, we do not use any tokenisation resulting in a form of predefined segmentation, which would limit the user’s ability to freely annotate any ranges in the text.\nFor example, suppose we have the following text:\nThis sentence has overlapping visual attributes.\n(italic, start=5, end=29)\n(bold, start=14, end=36)\nMoreover, standoff makes it possible to mark up the same text in different, possibly incompatible ways, allowing for different interpretations without making redundant copies of the text. In the Knora base ontology, any text value can have standoff tags.\nBy representing standoff as RDF triples, Knora makes markup searchable across multiple text documents in a repository. For example, if a repository contains documents in which references to persons are indicated in standoff, it is straightforward to find all the documents mentioning a particular person. Knora’s standoff support is intended to make it possible to convert documents with embedded, hierarchical markup, such as TEI/XML, into RDF standoff and back again, with no data loss, thus bringing the benefits of RDF to existing TEI-encoded documents.\nIn the Knora base ontology, a TextValue can have one or more standoff tags. Each standoff tag indicates the start and end positions of a substring in the text that has a particular attribute. The OWL class kb:StandoffTag, which is the base class of all standoff node classes, has these properties:\nstandoffTagHasStart (1) The index of the first character in the text that has the attribute. standoffTagHasEnd (1) The index of the last character in the text that has the attribute, plus 1. standoffTagHasUUID (1) A UUID identifying this instance and those corresponding to it in later versions of the TextValue it belongs to. The UUID is a means to maintain a reference to a particular range of a text also when new versions are made and standoff tag IRIs change. standoffTagHasOriginalXMLID (0-1) The original id of the XML element that the standoff tag represents, if any. standoffTagHasStartIndex (1) The start index of the standoff tag. Start indexes are numbered from 0 within the context of a particular text. When several standoff tags share the same start position, they can be nested correctly with this information when transforming them to XML. standoffTagHasEndIndex (1) The end index of the standoff tag. Start indexes are numbered from 0 within the context of a particular text. When several standoff tags share the same end position, they can be nested correctly with this information when transforming them to XML. standoffTagHasStartParent (0-1) Points to the parent standoff tag. This corresponds to the original nesting of tags in XML. If a standoff tag has no parent, it represents the XML root element. If the original XML element is a CLIX tag, it represents the start of a virtual (non syntactical) hierarchy. standoffTagHasEndParent (0-1) Points to the parent standoff tag if the original XML element is a CLIX tag and represents the end of a virtual (non syntactical) hierarchy.\nThe StandoffTag class is not used directly in RDF data; instead, its subclasses are used. A few subclasses are currently provided in standoff-onto.ttl, and more will be added to support TEI semantics. Projects are able to define their own custom standoff tag classes (direct subclasses of StandoffTag or one of the standoff data type classes or subclasses of one of the standoff classes defined in standoff-onto.ttl).","title":"Text with Standoff Markup"},{"location":"/02-knora-ontologies/knora-base.html#subclasses-of-standofftag","text":"","title":"Subclasses of StandoffTag"},{"location":"/02-knora-ontologies/knora-base.html#standoff-data-type-tags","text":"Associates data in some Knora value type with a substring in a text. Standoff data type tags are subclasses of ValueBase classes.\nStandoffLinkTag Indicates that a substring refers to another kb:Resource. See StandoffLinkTag. StandoffInternalReferenceTag Indicates that a substring refers to another standoff tag in the same text value. See Internal Links in a TextValue. StandoffUriTag Indicates that a substring is associated with a URI, which is stored in the same form that is used for kb:UriValue. See UriValue. StandoffDateTag Indicates that a substring represents a date, which is stored in the same form that is used for kb:DateValue. See DateValue. StandoffColorTag Indicates that a substring represents a color, which is stored in the same form that is used for kb:ColorValue. See ColorValue. StandoffIntegerTag Indicates that a substring represents an integer, which is stored in the same form that is used for kb:IntegerValue. See IntValue. StandoffDecimalTag Indicates that a substring represents a number with fractions, which is stored in the same form that is used for kb:DecimalValue. See DecimalValue. StandoffIntervalTag Indicates that a substring represents an interval, which is stored in the same form that is used for kb:IntervalValue. See IntervalValue. StandoffBooleanTag Indicates that a substring represents a Boolean, which is stored in the same form that is used for kb:BooleanValue. See BooleanValue.","title":"Standoff Data Type Tags"},{"location":"/02-knora-ontologies/knora-base.html#standofflinktag","text":"A StandoffLinkTag Indicates that a substring is associated with a Knora resource. For example, if a repository contains resources representing persons, a text could be marked up so that each time a person’s name is mentioned, a StandoffLinkTag connects the name to the Knora resource describing that person. Property:\nstandoffTagHasLink (1) The IRI of the resource that is referred to.\nOne of the design goals of the Knora ontology is to make it easy and efficient to find out which resources contain references to a given resource. Direct links are easier and more efficient to query than indirect links. Therefore, when a text value contains a resource reference in its standoff nodes, the Knora API server automatically creates a direct link between the containing resource and the target resource, along with an RDF reification (a kb:LinkValue) describing the link, as discussed in Links Between Resources. In this case, the link property is always kb:hasStandoffLinkTo, and the link value property (which points to the LinkValue) is always kb:hasStandoffLinkToValue.\nThe Knora API server automatically updates direct links and reifications for standoff resource references when text values are updated. To do this, it keeps track of the number of text values in each resource that contain at least one standoff reference to a given target resource. It stores this number as the reference count of the LinkValue (see LinkValue) describing the direct link. Each time this number changes, it makes a new version of the LinkValue, with an updated reference count. When the reference count reaches zero, it removes the direct link and makes a new version of the LinkValue, marked with kb:isDeleted.\nFor example, if data:R1 is a resource with a text value in which the resource data:R2 is referenced, the repository could contain the following triples:\ndata:R1 ex:hasComment data:V1 .\n\ndata:V1 rdf:type kb:TextValue ;\n    kb:valueHasString \"This link is internal.\" ;\n    kb:valueHasStandoff data:SO1 .\n\ndata:SO1 rdf:type kb:StandoffLinkTag ;\n    kb:standoffTagHasStart: 5 ;\n    kb:standoffTagHasEnd: 9 ;\n    kb:standoffTagHasLink data:R2 .\n\ndata:R1 kb:hasStandoffLinkTo data:R2 .\ndata:R1 kb:hasStandoffLinkToValue data:LV1 .\n\ndata:LV1 rdf:type kb:LinkValue ;\n    rdf:subject data:R1 ;\n    rdf:predicate kb:hasStandoffLinkTo ;\n    rdf:object data:R2 ;\n    kb:valueHasRefCount 1 .\nThe result can be visualized like this:\nLink values created automatically for resource references in standoff are visible to all users, and the creator of these link values is always kb:SystemUser (see Users and Groups). The Knora API server allows a user to see a standoff link if the user has permission to see the source and target resources.","title":"StandoffLinkTag"},{"location":"/02-knora-ontologies/knora-base.html#internal-links-in-a-textvalue","text":"Internal links in a TextValue can be represented using the data type standoff class StandoffInternalReferenceTag or a subclass of it. It has the following property:\nstandoffTagHasInternalReference (1) Points to a StandoffTag that belongs to the same TextValue. It has an objectClassConstraint of StandoffTag.\nFor links to a kb:Resource, see StandoffLinkTag.","title":"Internal Links in a TextValue"},{"location":"/02-knora-ontologies/knora-base.html#mapping-to-create-standoff-from-xml","text":"A mapping allows for the conversion of an XML document to RDF-standoff and back. A mapping defines one-to-one relations between XML elements (with or without a class) and attributes and standoff classes and properties (see XML to Standoff Mapping).\nA mapping is represented by a kb:XMLToStandoffMapping which contains one or more kb:MappingElement. A kb:MappingElement maps an XML element (including attributes) to a standoff class and standoff properties. It has the following properties:\nmappingHasXMLTagname (1) The name of the XML element that is mapped to a standoff class. mappingHasXMLNamespace (1) The XML namespace of the XML element that is mapped to a standoff class. If no namespace is given, noNamespace is used. mappingHasXMLClass (1) The name of the class of the XML element. If it has no class, noClass is used. mappingHasStandoffClass (1) The standoff class the XML element is mapped to. mappingHasXMLAttribute (0-n) Maps XML attributes to standoff properties using MappingXMLAttribute. See below. mappingHasStandoffDataTypeClass (0-1) Indicates the standoff data type class of the standoff class the XML element is mapped to. mappingElementRequiresSeparator (1) Indicates if there should be an invisible word separator inserted after the XML element in the RDF-standoff representation. Once the markup is stripped, text segments that belonged to different elements may be concatenated.\nA MappingXMLAttribute has the following properties:\nmappingHasXMLAttributename The name of the XML attribute that is mapped to a standoff property. mappingHasXMLNamespace The namespace of the XML attribute that is mapped to a standoff property. If no namespace is given, noNamespace is used. mappingHasStandoffProperty The standoff property the XML attribute is mapped to.\nKnora includes a standard mapping used by the SALSAH GUI. It has the IRI http://rdfh.ch/standoff/mappings/StandardMapping and defines mappings for a few elements used to write texts with simple markup.","title":"Mapping to Create Standoff From XML"},{"location":"/02-knora-ontologies/knora-base.html#standoff-in-digital-editions","text":"Knora’s standoff is designed to make it possible to convert XML documents to standoff and back. One application for this feature is an editing workflow in which an editor works in an XML editor, and the resulting XML documents are converted to standoff and stored in Knora, where they can be searched and annotated.\nIf an editor wants to correct text that has been imported from XML into standoff, the text can be exported as XML, edited, and imported again. To preserve annotations on standoff tags across edits, each tag can automatically be given a UUID. In a future version of the Knora base ontology, it will be possible to create annotations that point to UUIDs rather than to IRIs. When a text is exported to XML, the UUIDs can be included in the XML. When the edited XML is imported again, it can be converted to new standoff tags with the same UUIDs. Annotations that applied to standoff tags in the previous version of the text will therefore also apply to equivalent tags in the new version.\nWhen text is converted from XML into standoff, tags are also given indexes, which are numbered from 0 within the context of a particular text. This makes it possible to order tags that share the same position, and to preserve the hierarchy of the original XML document. An ordinary, hierarchical XML tag is converted to a standoff tag that has one index, as well as the index of its parent tag, if any. The Knora base ontology also supports non-hierarchical markup such as CLIX, which enables overlapping markup to be represented in XML. When non-hierarchical markup is converted to standoff, both the start position and the end position of the standoff tag have indexes and parent indexes.\nTo support these features, a standoff tag can have these additional properties:\nstandoffTagHasStartIndex (0-1) The index of the start position. standoffTagHasEndIndex (0-1) The index of the end position, if this is a non-hierarchical tag. standoffTagHasStartParent (0-1) The IRI of the tag, if any, that contains the start position. standoffTagHasEndParent (0-1) The IRI of the tag, if any, that contains the end position, if this is a non-hierarchical tag. standoffTagHasUUID (0-1) A UUID that can be used to annotate a standoff tag that may be present in different versions of a text, or in different layers of a text (such as a diplomatic transcription and an edited critical text).","title":"Standoff in Digital Editions"},{"location":"/02-knora-ontologies/knora-base.html#querying-standoff-in-sparql","text":"A future version of the Knora API server will provide an API for querying standoff markup. In the meantime, it is possible to query it directly in SPARQL. For example, here is a SPARQL query (using RDFS inference) that finds all the text values texts that have a standoff date tag referring to Christmas Eve 2016, contained in a StandoffItalicTag:\nPREFIX knora-base: <http://www.knora.org/ontology/knora-base#>\nPREFIX standoff: <http://www.knora.org/ontology/standoff#>\n\nselect * where {\n    ?standoffTag a knora-base:StandoffDateTag  .\n\n    ?standoffTag knora-base:valueHasStartJDN ?dateStart .\n    ?standoffTag knora-base:valueHasEndJDN ?dateEnd .\n\n    FILTER (2457747  <= ?dateEnd && 2457747  >= ?dateStart)\n\n    ?standoffTag knora-base:standoffTagHasStartParent ?parent .\n    ?parent a standoff:StandoffItalicTag .\n\n    ?textValue knora-base:valueHasStandoff ?standoffTag .\n    ?textValue knora-base:valueHasString ?string .\n\n    ?standoffTag knora-base:standoffTagHasStart ?startPos .\n    ?standoffTag knora-base:standoffTagHasEnd ?endPos .  \n}","title":"Querying Standoff in SPARQL"},{"location":"/02-knora-ontologies/knora-base.html#authorisation","text":"","title":"Authorisation"},{"location":"/02-knora-ontologies/knora-base.html#users-and-groups","text":"Each Knora user is represented by an object belonging to the class kb:User, which is a subclass of foaf:Person, and has the following properties:\nuserid (1) A unique identifier that the user must provide when logging in. password (1) A cryptographic hash of the user’s password. email (0-n) Email addresses belonging to the user. isInProject (0-n) Projects that the user is a member of. isInGroup (0-n) Project-specific groups that the user is a member of. foaf:familyName (1) The user’s family name. foaf:givenName (1) The user’s given name.\nKnora’s concept of access control is that an object (a resource or value) can grant permissions to groups of users (but not to individual users). There are four built-in groups:\nUnknownUser Any user who has not logged into the Knora API server is automatically assigned to this group. KnownUser Any user who has logged into the Knora API server is automatically assigned to this group. ProjectMember When checking a user’s permissions on an object, the user is automatically assigned to this group if she is a member of the project that the object belongs to. Creator When checking a user’s permissions on an object, the user is automatically assigned to this group if he is the creator of the object.\nA project-specific ontology can define additional groups, which must belong to the OWL class kb:UserGroup.\nThere is one built-in SystemUser, which is the creator of link values created automatically for resource references in standoff markup (see StandoffLinkTag).","title":"Users and Groups"},{"location":"/02-knora-ontologies/knora-base.html#permissions","text":"An object can grant the following permissions, which are stored in a compact format in a single string. This string is the object of the predicate kb:hasPermissions, which is required on every kb:Resource and kb:Value.\nRestricted view permission (RV) Allows a restricted view of the object, e.g. a view of an image with a watermark. View permission (V) Allows an unrestricted view of the object. Having view permission on a resource only affects the user’s ability to view information about the resource other than its values. To view a value, she must have view permission on the value itself. Modify permission (M) For values, this permission allows a new version of a value to be created. For resources, this allows the user to create a new value (as opposed to a new version of an existing value), or to change information about the resource other than its values. When he wants to make a new version of a value, his permissions on the containing resource are not relevant. However, when he wants to change the target of a link, the old link must be deleted and a new one created, so he needs modify permission on the resource. Delete permission (D) Allows the item to be marked as deleted. Change rights permission (CR) Allows the permissions granted by the object to be changed.\nEach permission in the above list implies all lower-numbered permissions. A user’s permission level on a particular object is calculated in the following way:\nMake a list of the groups that the user belongs to, including Creator and/or ProjectMember if applicable. Make a list of the permissions that she can obtain on the object, by iterating over the permissions that the object grants. For each permission, if she is in the specified group, add the specified permission to the list of permissions she can obtain. From the resulting list, select the highest-level permission. If the result is that she would have no permissions, give her whatever permission UnknownUser would have.\nTo view a link between resources, a user needs permission to view the source and target resources. He also needs permission to view the LinkValue representing the link, unless the link property is hasStandoffLinkTo (see StandoffLinkTag).\nThe format of the object of kb:hasPermissions is as follows:\nEach permission is represented by the one-letter or two-letter abbreviation given above. Each permission abbreviation is followed by a space, then a comma-separated list of groups that the permission is granted to. The IRIs of built-in groups are shortened using the knora-base prefix. Multiple permissions are separated by a vertical bar (|).\nFor example, if an object grants view permission to unknown and known users, and modify permission to project members, the resulting permission literal would be:\nV knora-base:UnknownUser,knora-base:KnownUser|M knora-base:ProjectMember","title":"Permissions"},{"location":"/02-knora-ontologies/knora-base.html#consistency-checking","text":"Knora tries to enforce repository consistency by checking constraints that are specified in the Knora base ontology and in project-specific ontologies. Three types of consistency rules are enforced:\nCardinalities in OWL class definitions must be satisfied. Constraints on the types of the subjects and objects of OWL object properties must be satisfied. A datatype property may not have an empty string as an object.\nThe implementation of consistency checking is partly triplestore-dependent; Knora may be able to provide stricter checks with some triplestores than with others.","title":"Consistency Checking"},{"location":"/02-knora-ontologies/knora-base.html#owl-cardinalities","text":"As noted in Resources, each subclass of Resource must use OWL cardinality restrictions to specify the properties it can have. More specifically, a resource is allowed to have a property that is a subproperty of kb:hasValue or kb:hasLinkTo only if the resource’s class has some cardinality for that property. Similarly, a value is allowed to have a subproperty of kb:valueHas only if the value’s class has some cardinality for that property.\nKnora supports, and attempts to enforce, the following cardinality constraints:\nowl:cardinality 1 A resource of this class must have exactly one instance of the specified property. owl:minCardinality 1 A resource of this class must have at least one instance of the specified property. owl:maxCardinality 1 A resource of this class may have zero or one instance of the specified property. owl:minCardinality 0 A resource of this class may have zero or more instances of the specified property.\nKnora requires cardinalities to be defined using blank nodes, as in the following example from knora-base:\n:Representation rdf:type owl:Class ;\n    rdfs:subClassOf :Resource ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasFileValue ;\n          owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] .\n\n:StillImageRepresentation rdf:type owl:Class ;\n    rdfs:subClassOf :Representation ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasStillImageFileValue ;\n          owl:minCardinality \"1\"^^xsd:nonNegativeInteger ] .\nEach owl:Restriction may have the predicate salsah-gui:guiOrder to indicate the order in which properties should be displayed in a GUI (see The SALSAH GUI Ontology).\nA resource class inherits cardinalities from its superclasses. This follows from the rules of RDFS inference. Also, in Knora, cardinalities in the subclass can override cardinalities that would otherwise be inherited from the superclass. Specifically, if a superclass has a cardinality on a property P, and a subclass has a cardinality on a subproperty of P, the subclass’s cardinality overrides the superclass’s cardinality. In the example above, hasStillImageFileValue is a subproperty of hasFileValue. Therefore, the cardinality on hasStillImageFileValue overrides (i.e. replaces) the one on hasFileValue.\nNote that, unlike cardinalities, predicates of properties are not inherited. If :foo rdfs:subPropertyOf :bar, this does not mean that :foo inherits anything from :bar. Any predicates of :foo that are also needed by :bar must be defined explicitly on :bar. This design decision was made because property predicate inheritance is not provided by RDFS inference, and would make it more difficult to check the correctness of ontologies, while providing little practical benefit.\nFor more information about OWL cardinalities, see the OWL 2 Primer.","title":"OWL Cardinalities"},{"location":"/02-knora-ontologies/knora-base.html#constraints-on-the-types-of-property-subjects-and-objects","text":"When a project-specific ontology defines a property, it must indicate the types that are allowed as objects (and, if possible, as subjects) of the property. This is done using the following Knora-specific properties:\nsubjectClassConstraint Specifies the class that subjects of the property must belong to. This constraint is recommended but not required. Knora will attempt to enforce this constraint. objectClassConstraint If the property is an object property, specifies the class that objects of the property must belong to. Every subproperty of kb:hasValue or a kb:hasLinkTo (i.e. every property of a resource that points to a kb:Value or to another resource) is required to have this constraint, because the Knora API server relies on it to know what type of object to expect for the property. Knora will attempt to enforce this constraint. objectDatatypeConstraint If the property is a datatype property, specifies the type of literals that can be objects of the property. Knora will not attempt to enforce this constraint, but it is useful for documentation purposes.\nNote that it is possible for a subproperty to have a more restrictive contraint than its base property, by specifing a subject or object class that is a subclass of the one specified in the base property. However, it is not possible for the subproperty to make the base property’s constraint less restrictive.","title":"Constraints on the Types of Property Subjects and Objects"},{"location":"/02-knora-ontologies/knora-base.html#consistency-constraint-example","text":"A project-specific ontology could define consistency constraints as in this simplified example:\n:book rdf:type owl:Class ;\n    rdfs:subClassOf knora-base:Resource ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasTitle ;\n          owl:cardinality \"1\"^^xsd:nonNegativeInteger ] ,\n        [ rdf:type owl:Restriction ;\n          owl:onProperty :hasAuthor ;\n          owl:minCardinality \"0\"^^xsd:nonNegativeInteger ] .\n\n:hasTitle rdf:type owl:ObjectProperty ;\n    knora-base:subjectClassConstraint :book ;\n    knora-base:objectClassConstraint knora-base:TextValue .\n\n:hasAuthor rdf:type owl:ObjectProperty ;\n    knora-base:subjectClassConstraint :book ;\n    knora-base:objectClassConstraint knora-base:TextValue .","title":"Consistency Constraint Example"},{"location":"/02-knora-ontologies/knora-base.html#summary-of-restrictions-on-project-specific-ontologies","text":"","title":"Summary of Restrictions on Project-Specific Ontologies"},{"location":"/02-knora-ontologies/knora-base.html#restrictions-on-classes","text":"Each class must be a subclass of either kb:Resource or kb:StandoffTag, but not both (note that this forbids project-specific subclasses of kb:Value). All the cardinalities that a class defines directly (i.e. does not inherit from kb:Resource) must be on properties that are defined in the triplestore. Within the cardinalities of a class, there must be a link value property for each link property and vice versa. Each class must be a subclass of all the classes that are subject class constraints of the properties in its cardinalities. If it’s a resource class, all its directly defined cardinalities must be on Knora resource properties (subproperties of kb:hasValue or kb:hasLinkTo), and all its base classes with Knora IRIs must also be resource classes. A cardinality on kb:resourceProperty or kb:hasValue is forbidden. It must also have an rdfs:label. If it’s a standoff class, none of its cardinalities may be on Knora resource properties, and all its base classes with Knora IRIs must also be standoff classes.","title":"Restrictions on Classes"},{"location":"/02-knora-ontologies/knora-base.html#restrictions-on-properties","text":"The property’s subject class constraint, if provided, must be a subclass of kb:Resource or kb:StandoffTag, and must be a subclass of the subject class constraints of all its base properties. Its object class constraint, if provided, must be a subclass of the object class constraints of all its base properties. If the property is a Knora resource property, it must have an object class constraint and an rdfs:label. It can’t be a subproperty of both kb:hasValue and kb:hasLinkTo. It can’t be a subproperty of kb:hasFileValue. Each of its base properties that has a Knora IRI must also be a Knora resource property.","title":"Restrictions on properties"},{"location":"/02-knora-ontologies/knora-base.html#standardisation","text":"The DaSCH intends to coordinate the standardisation of generally useful entities proposed in project-specific ontologies. We envisage a process in which two or more projects would initiate the process by starting a public discussion on proposed entities to be shared. Once a consensus was reached, the DaSCH would publish these entities in an ontology that could be used by multiple projects, and would ensure that such ontologies are not subsequently modified in ways that break compatibility with existing data. Functionality may be added to the Knora API server to facilitate this process.","title":"Standardisation"},{"location":"/02-knora-ontologies/salsah-gui.html","text":"","title":"The SALSAH GUI Ontology"},{"location":"/02-knora-ontologies/salsah-gui.html#the-salsah-gui-ontology","text":"","title":"The SALSAH GUI Ontology"},{"location":"/02-knora-ontologies/salsah-gui.html#overview","text":"The SALSAH GUI ontology provides entities that can be used in project-specific ontologies to indicate to SALSAH (or to another GUI) how data should be entered and displayed.\nThe SALSAH GUI ontology is identified by the IRI http://www.knora.org/ontology/salsah-gui. In the Knora documentation in general, it is identified by the prefix salsah-gui, but for brevity, we omit the prefix in this document.","title":"Overview"},{"location":"/02-knora-ontologies/salsah-gui.html#properties","text":"guiOrder Can be attached to an owl:Restriction representing a cardinality in a resource class, to indicate the order in which properties should be displayed in the GUI. The object is a non-negative integer. For example, a property with guiOrder 0 would be displayed first, followed by a property with guiOrder 1, and so on. guiElement Can be attached to a property definition to indicate which SALSAH GUI element should be used to enter data for the property. This should be one of the individuals of class Guielement described below. guiAttribute Can be attached to a property definition to provide attributes for the GUI element specified in guiElement. The objects of this predicate are written in a DSL with the following syntax:\nobject = attribute name, \"=\", attribute value ;\n\nattribute name = identifier ;\n\nidentifier = letter , { letter } ;\n\nattribute value = integer | decimal | percent | string | iri ;\n\npercent = integer, \"%\" ;\n\niri = \"<\", string, \">\" ;\nThe attributes used with each GUI element are described below under Individuals.\nguiAttributeDefinition Used only in the salsah-gui ontology itself, as a predicate attached to instances of Guielement (see [salsah-gui-individuals]{role=“ref”}), to specify the attributes that can be given as objects of guiAttribute when a given Guielement. is used. The objects of this predicate are written in a DSL with the following syntax:\nobject = attribute name, [ \"(required)\" ], \":\", attribute type, [ enumerated values ] ;\n\nenumerated values = \"(\", enumerated value, { \"|\", enumerated value } \")\" ;\n\nattribute name = identifier ;\n\nattribute type = \"integer\" | \"decimal\" | \"percent\" | \"string\" | \"iri\" ;\n\nenumerated value = identifier ;\n\nidentifier = letter , { letter } ;\nEnumerated values are allowed only if `attribute type` is `string`.\nIf enumerated values are provided for an attribute, the attribute\nvalue given via `guiAttribute` must be one of the enumerated values.","title":"Properties"},{"location":"/02-knora-ontologies/salsah-gui.html#classes","text":"Guielement The instances of this class are individuals representing SALSAH GUI elements for data entry.","title":"Classes"},{"location":"/02-knora-ontologies/salsah-gui.html#individuals","text":"Colorpicker A GUI element for selecting a color. A property definition that uses this element may also contain a guiAttribute predicate whose object is a string in the form \"ncolors=N\", where N is an integer specifying the number of colors to display. Date A GUI element for selecting a date. Geometry A GUI element for selecting the geometry of a two-dimensional region. Geonames A GUI element for selecting a Geonames identifier. Interval A GUI element for selecting a time interval in an audio or video recording. List A GUI element for selecting an item in a hierarchical list (see [knora-base-list-value]{role=“ref”}). A property definition that uses this element must also contain this guiAttribute predicate: \"hlist=<LIST_IRI>\", where LIST_IRI is the IRI of a knora-base:ListNode. Pulldown A GUI element for selecting an item in a flat list (see [knora-base-list-value]{role=“ref”}) using a pull-down menu. A property definition that uses this element must also contain this guiAttribute predicate: \"hlist=<LIST_IRI>\", where LIST_IRI is the IRI of a knora-base:ListNode. Radio A GUI element for selecting an item in a flat list (see [knora-base-list-value]{role=“ref”}) using radio buttons. A property definition that uses this element must also contain this guiAttribute predicate: \"hlist=<LIST_IRI>\", where LIST_IRI is the IRI of a knora-base:ListNode. Richtext A GUI element for editing multi-line formatted text. Searchbox A GUI element for searching for a resource by matching text in its rdfs:label. For Knora API v1, a property definition that uses this element may also contain this guiAttribute predicate: \"numprops=N\", where N is an integer specifying the number of describing properties to be returned for each found resource. For Knora API v2, the guiAttribute has no effect. SimpleText A GUI element for editing a single line of unformatted text. A property definition that uses this element may also contain a guiAttribute predicate with one or both of the following objects: \"size=N\", where N is an integer specifying the size of the text field. \"maxlength=N\", where N is an integer specifying the maximum length of the string to be input. Slider A GUI element for choosing numerical values using a slider. A property definition that uses this element must also contain a guiAttribute predicate with both of the following objects: \"min=N\", where N is an integer specifying the minimum value of the input. \"max=N\", where N is an integer specifying the maximum value of the input. Spinbox A GUI element for choosing numerical values using a spinbox. A property definition that uses this element may also contain a guiAttribute predicate with one or both of the following objects: \"min=N\", where N is an integer specifying the minimum value of the input. \"max=N\", where N is an integer specifying the maximum value of the input. Textarea A GUI element for editing multi-line unformatted text. A property definition that uses this element may also contain a guiAttribute predicate with one or more of the following objects: \"width=N\", where N is a percentage of the window width (an integer followed by %). \"cols=N\", where N is an integer representing the number of colums in the text entry box. \"rows=N\", where N is an integer specifying the height of the text entry box in rows. \"wrap=W\", where W is soft or hard (see wrap). Checkbox A GUI element for choosing a boolean value using a checkbox. Fileupload A GUI element for uploading a file.","title":"Individuals"},{"location":"/03-webapi/index.html","text":"","title":"The Knora API Server"},{"location":"/03-webapi/index.html#the-knora-api-server","text":"The Knora API server implements Knora’s HTTP-based APIs, and manages data stored in an RDF triplestore and in files.\nDeployment Getting Started with the Knora API Server Design Knora API Server Design Overview Futures with Akka HTTP Module Responders Module Store Module Shared Packages How to Add an API Route Triplestore Updates Consistency Checking Authentication in the Knora API Server Administration (Users, Projects, Groups, Institutions, Permissions) Knora API v2 Design Development Overview Starting Fuseki 3 Starting GraphDB Build Process Setup IntelliJ for development of Knora Testing Docker Cheat Sheet Monitoring the Webapi Server Knora API v1 Introduction: Using API V1 Reading and Searching Resources XML to Standoff Mapping Adding Resources Reading Values Adding a Value Changing a Value Deleting Resources and Values Knora API v2 Introduction: Using API V2 Knora IRIs Reading and Searching Resources XML to Standoff Mapping KnarQL: Knora Query Language Querying, Creating, and Updating Ontologies Response Formats Knora Admin API Introduction: Using the Admin API","title":"The Knora API Server"},{"location":"/03-webapi/deployment/index.html","text":"","title":"Deployment"},{"location":"/03-webapi/deployment/index.html#deployment","text":"Getting Started with the Knora API Server","title":"Deployment"},{"location":"/03-webapi/deployment/webapi-getting-started.html","text":"","title":"Getting Started with the Knora API Server"},{"location":"/03-webapi/deployment/webapi-getting-started.html#getting-started-with-the-knora-api-server","text":"There is a quick installation guide here.","title":"Getting Started with the Knora API Server"},{"location":"/03-webapi/deployment/webapi-getting-started.html#choosing-and-setting-up-a-triplestore","text":"The Knora API server requires a standards-compliant RDF triplestore. A number of triplestore implementations are available, including free software as well as proprietary options.\nThe Knora API server is designed to work with any standards-compliant triplestore. It is primarily tested with Ontotext GraphDB, a high-performance, proprietary triplestore. We recommend GraphDB Standard Edition, but GraphDB Free (which is proprietary but available free of charge) also works.\nKnora includes support for Apache Jena, which is free software, but use of Jena is deprecated, and support for it will probably be removed in the future.\nBuilt-in support and configuration for other triplestores is planned.\nSee the chapters on Starting GraphDB and Starting Fuseki for more details.","title":"Choosing and Setting Up a Triplestore"},{"location":"/03-webapi/deployment/webapi-getting-started.html#creating-repositories-and-loading-test-data","text":"To create a test repository called knora-test and load test data into it, go to webapi/scripts and run the script for the triplestore you have chosen.\nFor GraphDB SE:   - If you are running GraphDB directly from its installation\n    directory (using its `graphdb` script), run\n    `graphdb-se-local-init-knora-test.sh`.\n  - If you are running GraphDB from a Docker image, run\n    `graphdb-se-docker-init-knora-test.sh`.\n For GraphDB Free:   - Configuration is currently provided only for running GraphDB\n    Free in Docker. To create a test repository, run\n    `graphdb-free-init-knora-test.sh`\n For Fuseki, run fuseki-load-test-data.sh.\nYou can create your own scripts based on these scripts, to create new repositories and optionally to load existing Knora-compliant RDF data into them.\nIf you are using GraphDB, you must create your repository using a repository configuration file that specifies the file KnoraRules.pie as its owlim:ruleset. This enables RDFS inference and Knora-specific consistency rules. When using GraphDB, the Knora API server uses RDFS inference to improve query performance. The Knora-specific consistency rules help ensure that your data is internally consistent and conforms to the Knora ontologies.\nWhen testing with GraphDB, you may sometimes get an error when loading the test data that says that there are multiple IDs for the same repository knora-test. In that case, something went wrong when dropping and recreating the repository. You can solve this by deleting the repository manually and starting over. Make sure you don’t delete important data. To delete the repository, stop GraphDB, delete the data directory in your GraphDB installation, and restart GraphDB.","title":"Creating Repositories and Loading Test Data"},{"location":"/03-webapi/deployment/webapi-getting-started.html#creating-a-test-installation","text":"","title":"Creating a Test Installation"},{"location":"/03-webapi/deployment/webapi-getting-started.html#run-a-supported-triplestore","text":"See the chapters on Starting GraphDB and Starting Fuseki on how to start a supported triplestore.","title":"Run a supported triplestore"},{"location":"/03-webapi/deployment/webapi-getting-started.html#creating-and-running-the-webapi-server-distribution-package","text":"To create a deployment package for the WEBAPI Server, please run from inside the knora/webapi folder the following commands:\n$ sbt stage\n$ cd target/universal/stage\n$ ./bin/webapi","title":"Creating and running the WEBAPI Server distribution package"},{"location":"/03-webapi/deployment/webapi-getting-started.html#downloading-and-running-sipi","text":"Download Sipi and install from source by following the Sipi Manual. For running and setting up Sipi for Knora, please see The Sipi Media Server.","title":"Downloading and running Sipi"},{"location":"/03-webapi/deployment/webapi-getting-started.html#transforming-data-when-ontologies-change","text":"When there is a change in Knora’s ontologies or in a project-specific ontology, it may be necessary to update existing data to conform to the new ontology. This can be done directly in SPARQL, but for simple transformations, Knora includes a command-line program that works on RDF data files in Turtle format. You can run it from SBT:\n> runMain org.knora.webapi.util.TransformData --help\n    [info] Running org.knora.webapi.util.TransformData --help\n    [info]\n    [info] Updates the structure of Knora repository data to accommodate changes in Knora.\n    [info]\n    [info] Usage: org.knora.webapi.util.TransformData -t [deleted|permissions|strings|standoff|all] input output\n    [info]\n    [info]   -t, --transform  <arg>   Selects a transformation. Available transformations:\n    [info]                            'deleted' (adds missing 'knora-base:isDeleted'\n    [info]                            statements), 'permissions' (combines old-style\n    [info]                            multiple permission statements into single permission\n    [info]                            statements), 'strings' (adds missing valueHasString),\n    [info]                            'standoff' (transforms old-style standoff into\n    [info]                            new-style standoff), 'creator' (transforms existing\n    [info]                            'knora-base:Owner' group inside permissions to\n    [info]                            'knora-base:Creator'), 'owner' (gives\n    [info]                            'knora-base:Creator' CR permissions to correspond to\n    [info]                            the previous behaviour for owners - use with care as\n    [info]                            it will add permissions that where not there before),\n    [info]                            'all' (all of the above minus 'owner')\n    [info]       --help               Show help message\n    [info]\n    [info]  trailing arguments:\n    [info]   input (required)    Input Turtle file\n    [info]   output (required)   Output Turtle file\nThe currently available transformations are:\ndeleted Adds knora-base:isDeleted false to resources and values that don’t have a knora-base:isDeleted predicate. permissions Combines old-style permission statements (hasViewPermission, hasModifyPermission, etc.) into one hasPermissions statement per resource or value, as described in Permissions. strings Adds missing valueHasString statements to Knora value objects. standoff Transforms old-style standoff markup (containing tag names as strings) to new-style standoff markup (using different OWL class names for different tags). creator Transforms existing knora-base:Owner group inside permissions to knora-base:Creator. owner Gives knora-base:Creator CR permissions to correspond to the previous behaviour for owners. Use with care as it will add permissions that where not there before. all Runs all of the above transformations.\nTransformations that are not needed have no effect, so it is safe to use -t all.\nThe program uses the Turtle parsing and formatting library from RDF4J. Additional transformations can be implemented as subclasses of org.eclipse.rdf4j.rio.RDFHandler.","title":"Transforming Data When Ontologies Change"},{"location":"/03-webapi/deployment/webapi-getting-started.html#selectively-disabling-routes","text":"In application.conf the setting app.routes-to-reject contains a list of strings, representing routes which should be rejected.\nFor Example, the string \"v1/users\" would lead to rejection of any route which contains this string.","title":"Selectively Disabling Routes"},{"location":"/03-webapi/deployment/webapi-getting-started.html#startup-flags","text":"There is a number of flags that can be set on startup, they will override any value set in the application configuration file:\nloadDemoData, --loadDemoData, -d: Loads the demo data. allowReloadOverHTTP, --allow-reload-over-http, -r: Allows reloading of data over HTTP. -p: Starts the Prometheus monitoring reporter. -z: Starts the Zipkin monitoring reporter. -j: Starts the Jaeger monitoring reporter. -c: Print the configuration at startup. --help: Shows the help message with all startup flags.","title":"Startup Flags"},{"location":"/03-webapi/design/index.html","text":"","title":"Design"},{"location":"/03-webapi/design/index.html#design","text":"Knora API Server Design Overview Futures with Akka HTTP Module Responders Module Store Module Shared Packages How to Add an API Route Triplestore Updates Consistency Checking Authentication in the Knora API Server Administration (Users, Projects, Groups, Institutions, Permissions) Knora API v2 Design","title":"Design"},{"location":"/03-webapi/design/design-overview.html","text":"","title":"Knora API Server Design Overview"},{"location":"/03-webapi/design/design-overview.html#knora-api-server-design-overview","text":"Introduction Design Diagram Modules HTTP Module Responders Module Store Module Shared Between Modules Actor Supervision and Creation Concurrency What the Responders Do Store Module (org.knora.webapi.store package) Triplestore Access Error Handling Transformation of Exception to Client Responses API Routing JSON","title":"Knora API Server Design Overview"},{"location":"/03-webapi/design/design-overview.html#introduction","text":"The Knora API server implements Knora’s web-based Application Programming Interface (API). It is responsible for receiving HTTP requests from clients (which may be web browsers or other software), performing authentication and authorisation, querying and updating the RDF triplestore, transforming the results of SPARQL queries into Knora API responses, and returning these responses to the client. It is written in Scala, using the Akka framework for message-based concurrency. It is designed to work with any standards-compliant triplestore. It can communicate with triplestores either via the SPARQL 1.1 Protocol or by embedding the triplestore in the API server as a library.","title":"Introduction"},{"location":"/03-webapi/design/design-overview.html#design-diagram","text":"","title":"Design Diagram"},{"location":"/03-webapi/design/design-overview.html#modules","text":"","title":"Modules"},{"location":"/03-webapi/design/design-overview.html#http-module","text":"org.knora.webapi.http org.knora.webapi.routes","title":"HTTP Module"},{"location":"/03-webapi/design/design-overview.html#responders-module","text":"org.knora.webapi.responders","title":"Responders Module"},{"location":"/03-webapi/design/design-overview.html#store-module","text":"org.knora.store","title":"Store Module"},{"location":"/03-webapi/design/design-overview.html#shared-between-modules","text":"org.knora.webapi org.knora.webapi.util org.knora.webapi.messages","title":"Shared Between Modules"},{"location":"/03-webapi/design/design-overview.html#actor-supervision-and-creation","text":"At system start, the supervisor actors are created in KnoraService.scala:\nval responderManager = system.actorOf(Props(new ResponderManagerV1 with LiveActorMaker), name = \"responderManager\")\nval storeManager = system.actorOf(Props(new StoreManager with LiveActorMaker), name = \"storeManager\")\nEach supervisor creates and maintains a pool of workers, with an Akka router that dispatches messages to the workers according to some strategy. For now, all the pools use the ‘round-robin’ strategy. The pools and routers are configured in application.conf:\nactor {\n    deployment {\n        user/storeManager/triplestoreRouter {\n            router = round-robin-pool\n            nr-of-instances = 50\n        }\n\n        user/responderManager/resourcesRouter {\n            router = round-robin-pool\n            nr-of-instances = 20\n        }\n\n        user/responderManager/valuesRouter {\n            router = round-robin-pool\n            nr-of-instances = 20\n        }\n\n        user/responderManager/representationsRouter {\n            router = round-robin-pool\n            nr-of-instances = 20\n        }\n\n        user/responderManager/usersRouter {\n            router = round-robin-pool\n            nr-of-instances = 20\n        }\n    }\n}\nAdditionally, in KnoraService also the akka-http layer is started:\nval host = settings.httpInterface\nval port = settings.httpPort\nval bindingFuture: Future[ServerBinding] = Http().bindAndHandle(Route.handlerFlow(apiRoutes), host, port)\nprintln(s\"Knora API Server started. You can access it on http://${settings.httpInterface}:${settings.httpPort}.\")\n\nbindingFuture.onFailure {\n    case ex: Exception =>\n    log.error(ex, s\"Failed to bind to ${settings.httpInterface}:${settings.httpPort}!\")\n}","title":"Actor Supervision and Creation"},{"location":"/03-webapi/design/design-overview.html#concurrency","text":"Except for a bit of caching, the Knora API server is written in a purely functional style and has no mutable state, shared or otherwise, not even within actors. This makes it easier to reason about concurrency, and eliminates an important potential source of bugs (see Out of the Tar Pit).\nThere is a pool of HTTP workers that handle HTTP requests concurrently using the spray routes in the routing package. Each spray route constructs a request message and sends it to ResponderManagerV1, which forwards it to a worker actor in one of its pools. So the size of the HTTP worker pool sets the maximum number of concurrent HTTP requests, and the size of the worker pool for each responder sets the maximum number of concurrent messages for that responder. Whenever a responder needs to do a SPARQL query, it sends a message to the store manager, which forwards it to a triplestore actor. The size of the pool(s) of triplestore actors sets the maximum number of concurrent SPARQL queries.\nThe routes and actors in the Knora API server uses Akka’s ask pattern, rather than the tell pattern, to send messages and receive responses, because this simplifies the code considerably (using tell would require actors to maintain complex mutable state), with no apparent reduction in performance.\nTo manage asynchronous communication between actors, the Knora API server uses Scala’s Future monad extensively. See Futures with Akka for details.\nWe use Akka’s asynchronous logging interface (see Akka Logging).","title":"Concurrency"},{"location":"/03-webapi/design/design-overview.html#what-the-responders-do","text":"In the Knora API server, a ‘responder’ is an actor that receives a request message (a Scala case class) in the ask pattern, gets data from the triplestore, and turns that data into a reply message (another case class). These reply messages are are defined in the schemas package. A responder can produce a reply representing a complete API response, or part of a response that will be used by another responder. If it’s a complete API response, it will extend KnoraJsonResponse, which can be converted directly into JSON by calling its toJsValue method (see the section on JSON below).\nAll messages to responders go through the responder supervisor actor (ResponderManagerV1).","title":"What the Responders Do"},{"location":"/03-webapi/design/design-overview.html#store-module-org-knora-webapi-store-package-","text":"The Store module is used for accessing the triplestore and other external storage providers.\nAll access to the Store module goes through the StoreManager supervisor actor. The StoreManager creates pools of actors, such as HttpTriplestoreActor, that interface with the storage providers.\nThe contents of the store package are not used directly by other packages, which interact with the store package only by sending messages to StoreManager.\nGeneration and parsing of SPARQL are handled by this module.\nSee Store Module for a deeper discussion.","title":"Store Module (org.knora.webapi.store package)"},{"location":"/03-webapi/design/design-overview.html#triplestore-access","text":"SPARQL queries are generated from templates, using the Twirl template engine. For example, if we’re querying a resource, the template will contain a placeholder for the resource’s IRI. The templates can be found under src/main/twirl/queries/sparql/v1. So far we have been able to avoid generating different SPARQL for different triplestores.\nThe org.knora.webapi.store package contains actors for communicating with triplestores in different ways: a triplestore can be accessed over HTTP via the SPARQL 1.1 Protocol, or it can be embedded in the Knora API server. However, a responder is not expected to know which triplestore is being used or how the triplestore is accessed. To perform a SPARQL query, a responder sends a message to the storeManager actor, like this:\nprivate val storeManager = context.actorSelection(\"/user/storeManager\")\n\n// ...\n\nprivate def getSomeValue(resourceIri: IRI): Future[String] = {\n    for {\n        sparqlQuery <- Future(queries.sparql.v1.txt.someTemplate(resourceIri).toString())\n        queryResponse <- (storeManager ? SparqlSelectRequest(sparqlQuery)).mapTo[SparqlSelectResponse]\n        someValue = // get some value from the query response\n    } yield someValue\n}","title":"Triplestore Access"},{"location":"/03-webapi/design/design-overview.html#error-handling","text":"The error-handling design has these aims:\nSimplify the error-handling code in actors as much as possible. Produce error messages that clearly indicate the context in which the error occurred (i.e. what the application was trying to do). Ensure that clients receive an appropriate error message when an error occurs. Ensure that ask requests are properly terminated with an akka.actor.Status.Failure message in the event of an error, without which they will simply time out (see Ask: Send and Receive Future). When a actor encounters an error that isn’t the client’s fault (e.g. a triplestore failure), log it, but don’t do this with errors caused by bad input. When logging errors, include the full JVM stack trace.\nThe design does not yet include, but could easily accommodate, translations of error messages into different languages.\nA hierarchy of exception classes is defined in Exceptions.scala, representing different sorts of errors that could occur. The hierarchy has two main branches:\nRequestRejectedException, an abstract class for errors that are the client’s fault. These errors are not logged. InternalServerException, an abstract class for errors that are not the client’s fault. These errors are logged.\nException classes in this hierarchy can be defined to include a wrapped cause exception. When an exception is logged, its stack trace will be logged along with the stack trace of its cause. It is therefore recommended that low-level code should catch low-level exceptions, and wrap them in one of our higher-level exceptions, in order to clarify the context in which the error occurred.\nTo simplify error-handling in responders, a utility method called future2Message is provided in ActorUtils. It is intended to be used in an actor’s receive method to respond to messages in the ask pattern. If the responder’s computation is successful, it is sent to the requesting actor as a response to the ask. If the computation fails, the exception representing the failure is wrapped in a Status.Failure, which is sent as a response to the ask. If the error is a subclass of RequestRejectedException, only the sender is notified of the error; otherwise, the error is also logged and rethrown (so that the KnoraExceptionHandler can handle the exception).\nIn many cases, we transform data from the triplestore into a Map object. To simplify checking for required values in these collections, the class ErrorHandlingMap is provided. You can wrap any Map in an ErrorHandlingMap. You must provide a function that will generate an error message when a required value is missing, and optionally a function that throws a particular exception. Rows of SPARQL query results are already returned in ErrorHandlingMap objects.\nIf you want to add a new exception class, see the comments in Exceptions.scala for instructions.","title":"Error Handling"},{"location":"/03-webapi/design/design-overview.html#transformation-of-exception-to-client-responses","text":"The org.knora.webapi.KnoraExceptionHandler is brought implicitly into scope of akka-http, and by doing so registered and used to handle the transformation of all KnoraExceptions into HttpResponses. This handler handles only exceptions thrown inside the route and not the actors. However, the design of reply message passing from actors (by using future2Message), makes sure that any exceptions thrown inside actors, will reach the route, where they will be handled.\nSee also Fuures with Akka.","title":"Transformation of Exception to Client Responses"},{"location":"/03-webapi/design/design-overview.html#api-routing","text":"The API routes in the routing package are defined using the DSL provided by the akka-http library. A routing function has to do the following:\nAuthenticate the client. Figure out what the client is asking for. Construct an appropriate request message and send it to ResponderManagerV1, using the ask pattern. Return a result to the client.\nTo simplify the coding of routing functions, they are contained in objects that extend org.knora.webapi.routing.Authenticator. Each routing function performs the following operations:\nAuthenticator.getUserProfileV1 is called to authenticate the user. The request parameters are interpreted and validated, and a request message is constructed to send to the responder. If the request is invalid, BadRequestException is thrown. If the request message is requesting an update operation, it must include a UUID generated by UUID.randomUUID, so the responder can obtain a write lock on the resource being updated.\nThe routing function then passes the message to org.knora.webapi.routing.RouteUtils.runJsonRoute(), which takes care of sending the message to ResponderManagerV1 and returning a response to the client. Any exceptions thrown befor calling org.knora.webapi.routing.RouteUtils.runJsonRoute() are handled by the KnoraExceptionHandler.\nSee How to Add an API Route for an example.","title":"API Routing"},{"location":"/03-webapi/design/design-overview.html#json","text":"The Knora API server parses and generate JSON using the spray-json library.\nThe triplestore returns results in JSON, and these are parsed into SparqlSelectResponse objects in the store package (by SparqlUtils, which can be used by any actor in that package). A SparqlSelectResponse has a structure that’s very close to the JSON returned by a triplestore via the SPARQL 1.1 Protocol: it contains a header (listing the variables that were used in the query) and a body (containing rows of query results). Each row of query results is represented by a VariableResultsRow, which contains a Map[String, String] of variable names to values.\nThe Jsonable trait marks classes that can convert themselves into spray-json AST objects when you call their toJsValue method; it returns a JsValue object, which can then be converted to text by calling its prettyPrint or compactPrint methods. Case classes representing complete API responses extend the KnoraResponseV1 trait, which extends Jsonable. Case classes representing Knora values extend the ApiValueV1 trait, which also extends Jsonable. To make the responders reusable, the JSON for API responses is generated only at the last moment, by the RouteUtils.runJsonRoute() function.","title":"JSON"},{"location":"/03-webapi/design/futures-with-akka.html","text":"","title":"Futures with Akka"},{"location":"/03-webapi/design/futures-with-akka.html#futures-with-akka","text":"Introduction Handling Errors with Futures Using recover on Futures Designing with Futures Mixing Futures with non-Futures How to Write For-Comprehensions Execution Contexts","title":"Futures with Akka"},{"location":"/03-webapi/design/futures-with-akka.html#introduction","text":"Scala’s documentation on futures introduces them in this way:\nFutures provide a nice way to reason about performing many operations in parallel – in an efficient and non-blocking way. The idea is simple, a Future is a sort of a placeholder object that you can create for a result that does not yet exist. Generally, the result of the Future is computed concurrently and can be later collected. Composing concurrent tasks in this way tends to result in faster, asynchronous, non-blocking parallel code.\nThe rest of that page is well worth reading to get an overview of how futures work and what you can do with them.\nIn Akka, one of the standard patterns for communication between actors is the ask pattern, in which you send a message to an actor and you expect a reply. When you call the ask function (which can be written as a question mark, ?, which acts as an infix operator), it immediately returns a Future, which will complete when the reply is sent. As the Akka documentation explains in Use with Actors, it is possible to block the calling thread until the future completes, using Await.result. However, they say: ‘Blocking is discouraged though as it will cause performance problems.’ In particular, by not blocking, you can do several ask requests in parallel.\nOne way to avoid blocking is to register a callback on the future, which will be called when it completes (perhaps by another thread), like this:\nfuture.onComplete {\n    case Success(result) => println(result)\n    case Failure(ex) => ex.printStackTrace()\n}\nBut this won’t work if you’re writing a method that needs return a value based on the result of a future. In this case, you can register a callback that transforms the result of a future into another future:\nval newFuture = future.map(x => x + 1)\nHowever, registering callbacks explicitly gets cumbersome when you need to work with several futures together. In this case, the most convenient alternative to blocking is to use Future as a monad. The links above explain what this means in detail, but the basic idea is that a special syntax, called a for-comprehension, allows you to write code that uses futures as if they were complete, without blocking. In reality, a for-comprehension is syntactic sugar for calling methods like map, but it’s much easier to write and to read. You can do things like this:\nval fooFuture = (fooActor ? GetFoo(\"foo\")).mapTo[Foo]\nval barFuture = (barActor ? GetBar(\"bar\")).mapTo[Bar]\n\nval totalFuture = for {\n    foo: Foo <- fooFuture\n    bar: Bar <- barFuture\n\n    total = foo.getCount + bar.getCount\n} yield total\nHere the messages to fooActor and barActor are sent and processed in parallel, but you’re guaranteed that total won’t be calculated until the values it needs are available. Note that if you construct fooFuture and barFuture inside the for comprehension, they won’t be run in parallel (see Scala for-comprehension with concurrently running futures).","title":"Introduction"},{"location":"/03-webapi/design/futures-with-akka.html#handling-errors-with-futures","text":"The constructors and methods of Future (like those of Try) catch exceptions, which cause the future to fail. This very useful property of futures means that you usually don’t need try-catch blocks when using the Future monad (although it is sometimes helpful to include them, in order to catch low-level exceptions and wrap them in higher-level ones). Any exception thrown in code that’s being run asynchronously by Future (including in the yield expression of a for comprehension) will be caught, and the result will be a Future containing a Failure. Also, in the previous example, if fooActor or barActor returns a Status.Failure message, the for-comprehension will also yield a failed future.\nHowever, you need to be careful with the first line of the for-comprehension. For example, this code doesn’t handle exceptions correctly:\nprivate def doFooQuery(iri: IRI): Future[String] = {\n    for {\n        queryResponse <- (storeManager ? SparqlSelectRequest(queries.sparql.v1.txt.getFoo(iri).toString())).mapTo[SparqlSelectResponse]\n        ...\n   } yield ...\n}\nThe getFoo() method calls a Twirl template function to generate SPARQL. The ? operator returns a Future. However, the template function is not run asynchronously, because it is called before the Future constructor is called. So if the template function throws an exception, it won’t be caught here. Instead, you can do this:\nprivate def doFooQuery(iri: IRI): Future[String] = {\n    for {\n        queryString <- Future(queries.sparql.v1.txt.getFoo(iri).toString())\n        queryResponse <- (storeManager ? SparqlSelectRequest(queryString)).mapTo[SparqlSelectResponse]\n        ...\n   } yield ...\n}\nHere the Future constructor will call the template function asynchronously, and catch any exceptions it throws. This is only necessary if you need to call the template function at the very beginning of a for-comprehension. In the rest of the for comprehension, you’ll already implicitly have a Future object.","title":"Handling Errors with Futures"},{"location":"/03-webapi/design/futures-with-akka.html#using-recover-on-futures","text":"By using recover on a  Future, an apt error message can be thrown if the Future fails. This is particularly useful when an an error message should be made more clear depending on the context the Future is used in.\nFor example, we are asking the resources responder to query for a certain resource in order to process it in a special way. However, the client does not know that the resources responder is sent a request and in case the resource cannot be found, the message sent back from the resources responder (NotFoundException) would not make sense to it. Instead, we would like to handle the message in a way so that it makes sense for the operation the client actually executed. We can do this by calling recover on a Future.\nprivate def mySpecialResourceRequest(iri: IRI, userProfile: UserProfileV1): Future[...] = {\n\n    val resourceRequestFuture = for {\n        resResponse: ResourceFullResponseV1 <- (responderManager ? ResourceFullGetRequestV1(iri = iri, userProfile = userProfile, getIncoming = false)).mapTo[ResourceFullResponseV1]\n    } yield resResponse\n\n    val resourceRequestFutureRecovered = resourceRequestFuture.recover {\n        case notFound: NotFoundException => throw BadRequestException(s\"Special resource handling failed because the resource could not be found: ${notFound.message}\")\n    }\n\n    for {\n\n        res <- resourceRequestFutureRecovered\n\n        ...\n\n    } yield ...\n\n}\nPlease note that the content of the Future has to be accessed using <- to make this work correctly. Otherwise the content will never be looked at.","title":"Using recover on Futures"},{"location":"/03-webapi/design/futures-with-akka.html#designing-with-futures","text":"In the current design, the Knora API Server almost never blocks to wait for a future to complete. The normal flow of control works like this:\nIncoming HTTP requests are handled by an actor called KnoraHttpService, which delegates them to routing functions (in the routing package). For each request, a routing function gets a spray-http RequestContext, and calls RouteUtils.runJsonRoute to send a message to a supervisor actor to fulfil the request. Having sent the message, the runJsonRoute gets a future in return. It does not block to wait for the future to complete, but instead registers a callback to process the result of the future when it becomes available. The supervisor forwards the message to be handled by the next available actor in a pool of responder actors that are able to handle that type of message. The responder’s receive method receives the message, and calls some private method that produces a reply message inside a future. This usually involves sending messages to other actors using ask, getting futures back, and combining them into a single future containing the reply message. The responder passes that future to ActorUtils.future2Message, which registers a callback on it. When the future completes (perhaps in another thread), the callback sends the reply message. In the meantime, the responder doesn’t block, so it can start handling the next request. When the responder’s reply becomes available (causing the future created by RouteUtils.runJsonRoute to complete), the callback registered in (2) calls complete on the RequestContext, which sends an HTTP response to the client.\nThe basic rule of thumb is this: if you’re writing a method in an actor, and anything in the method needs to come from a future (e.g. because you need to use ask to get some information from another actor), have the method return a future.","title":"Designing with Futures"},{"location":"/03-webapi/design/futures-with-akka.html#mixing-futures-with-non-futures","text":"If you have a match ... case or if expression, and one branch obtains some data in a future, but another branch can produce the data immediately, you can wrap the result of the latter branch in a future, so that both branches have the same type. Here we use an alternative implementation of scala.concurrent.Future, found in akka.http.scaladsl.util.FastFuture, which tries to avoid scheduling to an scala.concurrent.ExecutionContext if possible, i.e. if the given future value is already present:\ndef getTotalOfFooAndBar(howToGetFoo: String): Future[Int] = {\n    for {\n        foo <- howToGetFoo match {\n            case \"askForIt\" => (fooActor ? GetFoo(\"foo\")).mapTo[Foo]\n            case \"createIt\" => FastFuture.successful(new Foo())\n        }\n\n        bar <- (barActor ? GetBar(\"bar\")).mapTo[Bar]\n\n        total = foo.getCount + bar.getCount\n    } yield total\n}","title":"Mixing Futures with non-Futures"},{"location":"/03-webapi/design/futures-with-akka.html#how-to-write-for-comprehensions","text":"Here are some basic rules for writing for-comprehensions:\nThe first line of a for-comprehension has to be a “generator”, i.e. it has to use the <- operator. If you want to write an assignment (using =) as the first line, the workaround is to wrap the right-hand side in a monad (like Future) and use <- instead. Assignments (using =) are written without val. You’re not allowed to write statements that throw away their return values, so if you want to call something like println that returns Unit, you have to assign its return value to _.\nThe yield returns an object of the same type as the generators, which all have to produce the same type (e.g. Future).","title":"How to Write For-Comprehensions"},{"location":"/03-webapi/design/futures-with-akka.html#execution-contexts","text":"Whenever you use a future, there has to be an implicit ‘execution context’ in scope. Scala’s documentation on futures says, ‘you can think of execution contexts as thread pools’.\nIf you don’t have an execution context in scope, you’ll get a compile error asking you to include one, and suggesting that you could use import scala.concurrent.ExecutionContext.Implicits.global. Don’t do this, because the global Scala execution context is not the most efficient option. Instead, you can use the one provided by the Akka ActorSystem:\nimplicit val executionContext = system.dispatcher\nAkka’s execution contexts can be configured (see Dispatchers). You can see a Listing of the Reference Configuration.","title":"Execution Contexts"},{"location":"/03-webapi/design/http-module.html","text":"","title":"HTTP Module"},{"location":"/03-webapi/design/http-module.html#http-module","text":"The http module holds only a convenience method for adding CORS support to api routes. The CORS implementation uses the akka-http-cors directives implementation.","title":"HTTP Module"},{"location":"/03-webapi/design/responders-module.html","text":"","title":"Responders Module"},{"location":"/03-webapi/design/responders-module.html#responders-module","text":"Version 1.0 Responders ResponderManagerV1 CkanResponderV1 HierarchicalListsResponderV1 OntologyResponderV1 ProjectsResponderV1 RepresentationsResponderV1 ResourcesResponderV1 SearchResponderV1 UsersResponderV1 ValuesResponderV1 Shared","title":"Responders Module"},{"location":"/03-webapi/design/responders-module.html#version-1-0-responders","text":"","title":"Version 1.0 Responders"},{"location":"/03-webapi/design/responders-module.html#respondermanagerv1","text":"","title":"ResponderManagerV1"},{"location":"/03-webapi/design/responders-module.html#ckanresponderv1","text":"","title":"CkanResponderV1"},{"location":"/03-webapi/design/responders-module.html#hierarchicallistsresponderv1","text":"","title":"HierarchicalListsResponderV1"},{"location":"/03-webapi/design/responders-module.html#ontologyresponderv1","text":"The ontology responder provides information derived from all the ontologies in the repository, including Knora ontologies as well as project-specific ontologies. Most importantly, it provides information about resource classes and properties. This includes the cardinalities defined on each resource class, and takes into account the rules of cardinality inheritance, as described in the section OWL Cardinalities in OWL Cardinalities.\nFor performance reasons, all ontology data is loaded and cached at application startup. Currently, to refresh the cache, you must restart the application. The responder calculates class hierarchies and cardinality inheritance in Scala.","title":"OntologyResponderV1"},{"location":"/03-webapi/design/responders-module.html#projectsresponderv1","text":"","title":"ProjectsResponderV1"},{"location":"/03-webapi/design/responders-module.html#representationsresponderv1","text":"","title":"RepresentationsResponderV1"},{"location":"/03-webapi/design/responders-module.html#resourcesresponderv1","text":"","title":"ResourcesResponderV1"},{"location":"/03-webapi/design/responders-module.html#searchresponderv1","text":"","title":"SearchResponderV1"},{"location":"/03-webapi/design/responders-module.html#usersresponderv1","text":"","title":"UsersResponderV1"},{"location":"/03-webapi/design/responders-module.html#valuesresponderv1","text":"","title":"ValuesResponderV1"},{"location":"/03-webapi/design/responders-module.html#shared","text":"","title":"Shared"},{"location":"/03-webapi/design/store-module.html","text":"","title":"Store Module"},{"location":"/03-webapi/design/store-module.html#store-module","text":"Overview Lifecycle HTTP-based Triplestores GraphDB Fuseki 2 Embedded Triplestores Apache Jena TDB Concurrency Implementation Configuration TDB Disk Persisted Store Actor Messages","title":"Store Module"},{"location":"/03-webapi/design/store-module.html#overview","text":"The store module houses the different types of data stores supported by the Knora API server. At the moment, only triplestores are supported. The triplestore support is implemented in the org.knora.webapi.store.triplestore package.","title":"Overview"},{"location":"/03-webapi/design/store-module.html#lifecycle","text":"At the top level, the store package houses the StoreManager-Actor which is started when the Knora API server starts. The StoreManager then starts the TripleStoreManagerActor which in turn starts the correct actor implementation (e.g., GraphDB, Fuseki, embedded Jena, etc.).","title":"Lifecycle"},{"location":"/03-webapi/design/store-module.html#http-based-triplestores","text":"HTTP-based triplestore support is implemented in the org.knora.webapi.triplestore.http package.\nAn HTTP-based triplestore is one that is accessed remotly over the HTTP protocol. We have implemented support for the following triplestores:\nOntotext GraphDB Fuseki 2","title":"HTTP-based Triplestores"},{"location":"/03-webapi/design/store-module.html#graphdb","text":"","title":"GraphDB"},{"location":"/03-webapi/design/store-module.html#fuseki-2","text":"","title":"Fuseki 2"},{"location":"/03-webapi/design/store-module.html#embedded-triplestores","text":"Embedded triplestores is implemented in the org.knora.webapi.triplestore.embedded package.\nAn embedded triplestore is one that runs in the same JVM as the Knora API server.","title":"Embedded Triplestores"},{"location":"/03-webapi/design/store-module.html#apache-jena-tdb","text":"The support for embedded Jena TDB is currently dropped. The documentation and the code will remain in the repository. You can use it at your own risk.\nThe support for the embedded Jena-TDB triplestore is implemented in org.knora.webapi.triplestore.embedded.JenaTDBActor.\nThe relevant Jena libraries that are used are the following:\nJena API - The library used to work programmatically with RDF data Jena TDB - Their implementation of a triple store","title":"Apache Jena TDB"},{"location":"/03-webapi/design/store-module.html#concurrency","text":"Jena provides concurrency on different levels.\nOn the Jena TDB level there is the Dataset object, representing the triple store. On every access, a transaction (read or write) can be started.\nOn the Jena API level there is a Model object, which is equivalent to an RDF Graph. Here we can lock the model, so that MRSW (Multiple Reader Single Writer) access is allowed.\nhttps://jena.apache.org/documentation/tdb/tdb_transactions.html https://jena.apache.org/documentation/notes/concurrency-howto.html","title":"Concurrency"},{"location":"/03-webapi/design/store-module.html#implementation","text":"We employ transactions on the Dataset level. This means that every thread that accesses the triplestore, starts a read or write enabled transaction.\nThe transaction mechanism in TDB is based on write-ahead-logging. All changes made inside a write-transaction are written to journals, then propagated to the main database at a suitable moment. This design allows for read-transactions to proceed without locking or other overhead over the base database.\nTransactional TDB supports one active write transaction, and multiple read transactions at the same time. Read-transactions started before a write-transaction commits see the database in a state without any changes visible. Any transaction starting after a write-transaction commits sees the database with the changes visible, whether fully propagates back to the database or not. There can be active read transactions seeing the state of the database before the updates, and read transactions seeing the state of the database after the updates running at the same time.","title":"Implementation"},{"location":"/03-webapi/design/store-module.html#configuration","text":"In application.conf set to use the embedded triplestore:\ntriplestore {\n        dbtype = \"embedded-jena-tdb\"\n\n        embedded-jena-tdb {\n            persisted = true // \"false\" -> memory, \"true\" -> disk\n            loadExistingData = false // \"false\" -> use data if exists, \"false\" -> create a fresh store\n            storage-path = \"_TMP\" // ignored if \"memory\"\n        }\n\n        reload-on-start = false // ignored if \"memory\" as it will always reload\n\n        rdf-data = [\n            {\n                path = \"../knora-ontologies/knora-base.ttl\"\n                name = \"http://www.knora.org/ontology/knora-base\"\n            }\n            {\n                path = \"../knora-ontologies/salsah-gui.ttl\"\n                name = \"http://www.knora.org/ontology/salsah-gui\"\n            }\n            {\n                path = \"_test_data/ontologies/incunabula-onto.ttl\"\n                name = \"http://www.knora.org/ontology/0803/incunabula\"\n            }\n            {\n                path = \"_test_data/demo_data/incunabula-demo-data.ttl\"\n                name = \"http://www.knora.org/data/incunabula\"\n            }\n            {\n                path = \"_test_data/ontologies/images-onto.ttl\"\n                name = \"http://www.knora.org/ontology/0804/dokubib\"\n            }\n            {\n                path = \"_test_data/demo_data/images-demo-data.ttl\"\n                name = \"http://www.knora.org/data/dokubib\"\n            }\n        ]\n    }\nHere the storage is set to persistent, meaning that a Jena TDB store will be created under the defined tdb-storage-path. The reload-on-start flag, if set to true would reload the triplestore with the data referenced in rdf-data.","title":"Configuration"},{"location":"/03-webapi/design/store-module.html#tdb-disk-persisted-store","text":"Make sure to set reload-on-start to true if run for the first time. This will create a TDB store and load the data.\nIf only read access is performed, then Knora can be run once with reloading enabled. After that, reloading can be turned off, and the persisted TDB store can be reused, as any data found under the tdb-storage-path will be reused.\nIf the TDB storage files get corrupted, then just delete the folder and reload the data anew.","title":"TDB Disk Persisted Store"},{"location":"/03-webapi/design/store-module.html#actor-messages","text":"ResetTripleStoreContent(rdfDataObjects: List[RdfDataObject]) ResetTripleStoreContentACK()\nThe embedded Jena TDB can receive reset messages, and will ACK when reloading of the data is finished. RdfDataObject is a simple case class, containing the path and name (the same as rdf-data in the config file)\nAs an example, to use it inside a test you could write something like:\nval rdfDataObjects = List (\n           RdfDataObject(path = \"../knora-ontologies/knora-base.ttl\",\n                         name = \"http://www.knora.org/ontology/knora-base\"),\n           RdfDataObject(path = \"../knora-ontologies/salsah-gui.ttl\",\n                         name = \"http://www.knora.org/ontology/salsah-gui\"),\n           RdfDataObject(path = \"_test_data/ontologies/incunabula-onto.ttl\",\n                         name = \"http://www.knora.org/ontology/0803/incunabula\"),\n           RdfDataObject(path = \"_test_data/all_data/incunabula-data.ttl\",\n                         name = \"http://www.knora.org/data/incunabula\")\n    )\n\n    \"Reload data \" in {\n        storeManager ! ResetTripleStoreContent(rdfDataObjects)\n        expectMsg(300.seconds, ResetTripleStoreContentACK())\n    }","title":"Actor Messages"},{"location":"/03-webapi/design/shared-packages.html","text":"","title":"Shared Packages"},{"location":"/03-webapi/design/shared-packages.html#shared-packages","text":"TODO","title":"Shared Packages"},{"location":"/03-webapi/design/how-to-add-a-route.html","text":"","title":"How to Add an API Route"},{"location":"/03-webapi/design/how-to-add-a-route.html#how-to-add-an-api-route","text":"Write SPARQL templates Write Responder Request and Response Messages Write a Responder Write a Route","title":"How to Add an API Route"},{"location":"/03-webapi/design/how-to-add-a-route.html#write-sparql-templates","text":"Add any SPARQL templates you need to src/main/twirl/queries/sparql/v1, using the Twirl template engine.","title":"Write SPARQL templates"},{"location":"/03-webapi/design/how-to-add-a-route.html#write-responder-request-and-response-messages","text":"Add a file to the org.knora.webapi.messages.v1respondermessages package, containing case classes for your responder’s request and response messages. Add a trait that the responder’s request messages extend. Each request message type should contain a UserProfileV1.\nResponse message classes that represent a complete API response must extend KnoraResponseV1, and must therefore have a toJsValue method that converts the response message to a JSON AST using spray-json.","title":"Write Responder Request and Response Messages"},{"location":"/03-webapi/design/how-to-add-a-route.html#write-a-responder","text":"Write an Akka actor class that extends ResponderV1, and add it to the org.knora.webapi.responders.v1 package.\nGive your responder a receive() method that handles each of your request message types by generating a Future containing a response message, and passing the Future to ActorUtils.futureToMessage(). See Futures with Akka and Error Handling for details.\nSee Triplestore Access for details of how to access the triplestore in your responder.\nAdd an actor pool for your responder to application.conf, under actor.deployment.\nIn ResponderManagerV1, add a reference to your actor pool. Then add a case to the receive() method in ResponderManagerV1, to match messages that extend your request message trait, and forward them to that pool.","title":"Write a Responder"},{"location":"/03-webapi/design/how-to-add-a-route.html#write-a-route","text":"Add an object to the org.knora.webapi.routing.v1 package for your route. Your object should look something like this:\nimport akka.actor.ActorSystem\nimport akka.event.LoggingAdapter\nimport org.knora.webapi.SettingsImpl\nimport org.knora.webapi.messages.v1respondermessages.SampleGetRequestV1\nimport org.knora.webapi.routing.RouteUtils\nimport spray.routing.Directives._\nimport spray.routing._\nimport org.knora.webapi.util.StringConversions\nimport org.knora.webapi.BadRequestException\n\nobject SampleRouteV1 extends Authenticator {\n\n    def knoraApiPath(_system: ActorSystem, settings: SettingsImpl, log: LoggingAdapter): Route = {\n        implicit val system: ActorSystem = _system\n        implicit val executionContext = system.dispatcher\n        implicit val timeout = settings.defaultTimeout\n        val responderManager = system.actorSelection(\"/user/responderManager\")\n\n        path(\"sample\" / Segment) { iri =>\n            get { requestContext =>\n                val userProfile = getUserProfileV1(requestContext)\n                val requestMessage = makeRequestMessage(iri, userProfile)\n\n                RouteUtils.runJsonRoute(\n                    requestMessage,\n                    requestContext,\n                    settings,\n                    responderManager,\n                    log\n                )\n            }\n        }\n    }\n\n    private def makeRequestMessage(iriStr: String, userProfile: UserProfileV1): SampleGetRequestV1 = {\n        val iri = StringConversions.toIri(iriStr, () => throw BadRequestException(s\"Invalid IRI: $iriStr\"))\n        SampleGetRequestV1(iri, userProfile)\n    }\n}\nFinally, add your knoraApiPath() function to the apiRoutes member variable in KnoraService. Any exception thrown inside the route (e.g., input validation, getUserProfile, etc.) will be handled by the KnoraExceptionHandler, so that the correct client response (status code, format) will be returned.","title":"Write a Route"},{"location":"/03-webapi/design/triplestore-updates.html","text":"","title":"Triplestore Updates"},{"location":"/03-webapi/design/triplestore-updates.html#triplestore-updates","text":"Requirements General Permissions Ontology Constraints Duplicate and Redundant Values Versioning Deleting Linking Design Responsibilities of Responders Application-level Locking Ensuring Data Consistency SPARQL Update Examples Finding a value IRI in a value’s version history Creating the initial version of a value Adding a new version of a value Getting all versions of a value","title":"Triplestore Updates"},{"location":"/03-webapi/design/triplestore-updates.html#requirements","text":"","title":"Requirements"},{"location":"/03-webapi/design/triplestore-updates.html#general","text":"The supported update operations are:\nCreate a new resource with its initial values. Add a new value. Change a value. Delete a value (i.e. mark it as deleted). Delete a resource (i.e. mark it as deleted).\nUsers must be able to edit the same data concurrently.\nEach update must be atomic and leave the database in a consistent, meaningful state, respecting ontology constraints and permissions.\nThe application must not use any sort of long-lived locks, because they tend to hinder concurrent edits, and it is difficult to ensure that they are released when they are no longer needed. Instead, if a user requests an update based on outdated information (because another user has just changed something, and the first user has not found out yet), the update must be not performed, and the application must notify the user who requested it, suggesting that the user should check the relevant data and try again if necessary. (We may eventually provide functionality to help users merge edits in such a situation. The application can also encourage users to coordinate with one another when they are working on the same data, and may eventually provide functionality to facilitate this coordination.)\nWe can assume that each SPARQL update operation will run in its own database transaction with an isolation level of ‘read committed’. This is what GraphDB does when it receives a SPARQL update over HTTP (see GraphDB SE Transactions). We cannot assume that it is possible to run more than one SPARQL update in a single database transaction. (The SPARQL 1.1 Protocol does not provide a way to do this, and currently it can be done only by embedding the triplestore in the application and using a vendor-specific API, but we cannot require this in Knora.)","title":"General"},{"location":"/03-webapi/design/triplestore-updates.html#permissions","text":"To create a new value (as opposed to a new version of an existing value), the user must have knora-base:hasModifyPermission on the containing resource.\nTo create a new version of an existing value, the user needs only to have knora-base:hasModifyPermission on the current version of the value; no permissions on the resource are needed.\nSince changing a link requires deleting the old link and creating a new one (as described in Linking), a user wishing to change a link must have modify permission on both the containing resource and the knora-base:LinkValue for the existing link.\nWhen a new value is created, it is given the default permissions specified in the definition of its property. These are subproperties of knora-base:hasDefaultPermission, and are converted into the corresponding subproperties of knora-base:hasPermission. Similarly, when a new resource is created, it is given the default permissions specified in the definition of its OWL class.","title":"Permissions"},{"location":"/03-webapi/design/triplestore-updates.html#ontology-constraints","text":"Knora must not allow an update that would violate an ontology constraint.\nWhen creating a new value (as opposed to adding a new version of an existing value), Knora must not allow the update if the containing resource’s OWL class does not contain a cardinality restriction for the submitted property, or if the new value would violate the cardinality restriction.\nIt must also not allow the update if the type of the submitted value does not match the knora-base:objectClassConstraint of the property, or if the property has no knora-base:objectClassConstraint. In the case of a property that points to a resource, Knora must ensure that the target resource belongs to the OWL class specified in the property’s knora-base:objectClassConstraint, or to a subclass of that class.","title":"Ontology Constraints"},{"location":"/03-webapi/design/triplestore-updates.html#duplicate-and-redundant-values","text":"When creating a new value, or changing an existing value, Knora checks whether the submitted value would duplicate an existing value for the same property in the resource. The definition of ‘duplicate’ depends on the type of value; it does not necessarily mean that the two values are strictly equal. For example, if two text values contain the same Unicode string, they are considered duplicates, even if they have different Standoff markup. If resource R has property P with value V1, and V1 is a duplicate of V2, the API server must not add another instance of property P with value V2. However, if the requesting user does not have permission to see V2, the duplicate is allowed, because forbidding it would reveal the contents of V2 to the user.\nWhen creating a new version of a value, Knora also checks whether the new version is redundant, given the existing value. It is possible for the definition of ‘redundant’ can depend on the type of value, but in practice, it means that the values are strictly equal: any change, however trivial, is allowed.","title":"Duplicate and Redundant Values"},{"location":"/03-webapi/design/triplestore-updates.html#versioning","text":"Each Knora value (i.e. something belonging to an OWL class derived from knora-base:Value) is versioned. This means that once created, a value is never modified. Instead, ‘changing’ a value means creating a new version of the value — actually a new value — that points to the previous version using knora-base:previousValue. The versions of a value are a singly-linked list, pointing backwards into the past. When a new version of a value is made, the triple that points from the resource to the old version (using a subproperty of knora-base:hasValue) is removed, and a triple is added to point from the resource to the new version. Thus the resource always points only to the current version of the value, and the older versions are available only via the current version’s knora-base:previousValue predicate.\nUnlike values, resources (members of OWL classes derived from knora-base:Resource) are not versioned. The data that is attached to a resource, other than its values, can be modified.","title":"Versioning"},{"location":"/03-webapi/design/triplestore-updates.html#deleting","text":"Knora does not actually delete resources or values; it only marks them as deleted. Deleted data is normally hidden. All resources and values must have the predicate knora- base:isDeleted, whose object is a boolean. If a resource or value has been marked as deleted, it has knora-base:isDeleted true and has a knora-base:deleteDate. An optional knora-base:deleteComment may be added to explain why the resource or value has been marked as deleted.\nNormally, a value is marked as deleted without creating a new version of it. However, link values must be treated as a special case. Before a LinkValue can be marked as deleted, its reference count must be decremented to 0. Therefore, a new version of the LinkValue is made, with a reference count of 0, and it is this new version that is marked as deleted.\nSince it is necessary to be able to find out when a resource was deleted, it is not possible to undelete a resource. Moreover, to simplify the checking of cardinality constraints, and for consistency with resources, it is not possible to undelete a value, and no new versions of a deleted value can be made. Instead, if desired, a new resource or value can be created by copying data from a deleted resource or value.","title":"Deleting"},{"location":"/03-webapi/design/triplestore-updates.html#linking","text":"Knora API v1 treats a link between two resources as a value, but in RDF, links must be treated differently to other types of values. Knora needs to maintain information about the link, including permissions and a version history. Since the link does not have a unique IRI of its own, Knora uses RDF reifications for this purpose. Each link between two resources has exactly one (non-deleted) knora-base:LinkValue. The resource itself has a predicate that points to the LinkValue, using a naming convention in which the word Value is appended to the name of the link predicate to produce the link value predicate. For example, if a resource representing a book has a predicate called hasAuthor that points to another resource, it must also have a predicate called hasAuthorValue that points to the LinkValue in which information about the link is stored. To find a particular LinkValue, one can query it either by using its IRI (if known), or by using its rdf:subject, rdf:predicate, and rdf:object (and excluding link values that are marked as deleted).\nLike other values, link values are versioned. The link value predicate always points from the resource to the current version of the link value, and previous versions are available only via the current version’s knora-base:previousValue predicate. Deleting a link means deleting the triple that links the two resources, and making a new version of the link value, marked with knora-base:isDeleted. A triple then points from the resource to this new, deleted version (using the link value property).\nThe API allows a link to be ‘changed’ so that it points to a different target resource. This is implemented as follows: the existing triple connecting the two resources is removed, and a new triple is added using the same link property and pointing to the new target resource. A new version of the old link’s LinkValue is made, marked with knora-base:isDeleted. A new LinkValue is made for the new link. The new LinkValue has no connection to the old one.\nWhen a resource contains knora-base:TextValue with Standoff markup that includes a reference to another resource, this reference is materialised as a direct link between the two resources, to make it easier to query. A special link property, knora-base:hasStandoffLinkTo, is used for this purpose. The corresponding link value property, knora-base:hasStandoffLinkToValue, points to a LinkValue. This LinkValue contains a reference count, indicated by knora-base:valueHasRefCount, that represents the number of text values in the containing resource that include one or more Standoff references to the specified target resource. Each time this number changes, a new version of this LinkValue is made. When the reference count reaches zero, the triple with knora-base:hasStandoffLinkTo is removed, and a new version of the LinkValue is made and marked with knora-base:isDeleted. If the same resource reference later appears again in a text value, a new triple is added using knora-base:hasStandoffLinkTo, and a new LinkValue is made, with no connection to the old one.\nFor consistency, every LinkValue contains a reference count. If the link property is not knora-base:hasStandoffLinkTo, the reference count will always be either 1 (if the link exists) or 0 (if it has been deleted, in which case the link value will also be marked with knora-base:isDeleted).\nWhen a LinkValue is created for a standoff resource reference, it is given the same permissions as the text value containing the reference.","title":"Linking"},{"location":"/03-webapi/design/triplestore-updates.html#design","text":"","title":"Design"},{"location":"/03-webapi/design/triplestore-updates.html#responsibilities-of-responders","text":"ResourcesResponderV1 has sole responsibility for generating SPARQL to create and updating resources, and ValuesResponderV1 has sole responsibility for generating SPARQL to create and update values. When a new resource is created with its values, ValuesResponderV1 generates SPARQL statements that can be included in the WHERE and INSERT clauses of a SPARQL update to create the values, and ResourcesResponderV1 adds these statements to the SPARQL update that creates the resource. This ensures that the resource and its values are created in a single SPARQL update operation, and hence in a single triplestore transaction.","title":"Responsibilities of Responders"},{"location":"/03-webapi/design/triplestore-updates.html#application-level-locking","text":"The ‘read committed’ isolation level cannot prevent a scenario where two users want to add the same data at the same time. It is possible that both requests would do pre-update checks and simultaneously find that it is OK to add the data, and that both updates would then succeed, inserting redundant data and possibly violating ontology constraints. Therefore, Knora uses short-lived, application-level write locks on resources, to ensure that only one request at a time can update a given resource. Before each update, the application acquires a resource lock. It then does the pre-update checks and the update, then releases the lock. The lock implementation (in ResourceLocker) requires each API request message to include a random UUID, which is generated in the API Routing package. Using application-level locks allows us to do pre-update checks in their own transactions, and finally to do the SPARQL update in its own transaction.","title":"Application-level Locking"},{"location":"/03-webapi/design/triplestore-updates.html#ensuring-data-consistency","text":"Knora enforces consistency constraints using three redundant mechanisms:\nBy doing pre-update checks using SPARQL SELECT queries and cached ontology data. By doing checks in the WHERE clauses of SPARQL updates. By using GraphDB’s built-in consistency checker (see Consistency Checking).\nWe take the view that redundant consistency checks are a good thing.\nPre-update checks are SPARQL SELECT queries that are executed while holding an application-level lock on the resource to be updated. These checks should work with any triplestore, and can return helpful, Knora-specific error messages to the client if the request would violate a consistency constraint.\nHowever, the SPARQL update itself is our only chance to do pre-update checks in the same transaction that will perform the update. The design of the SPARQL 1.1 Update standard makes it possible to ensure that if certain conditions are not met, the update will not be performed. In our SPARQL update code, each update contains a WHERE clause, possibly a DELETE clause, and an INSERT clause. The WHERE clause is executed first. It performs consistency checks and provides values for variables that are used in the DELETE and/or INSERT clauses. In our updates, if the expectations of the WHERE clause are not met (e.g. because the data to be updated does not exist), the WHERE clause should return no results; as a result, the update will not be performed.\nRegardless of whether the update changes the contents of the triplestore, it returns nothing. If the update did nothing because the conditions of the WHERE clause were not met, the only way to find out is to do a SELECT afterwards. Moreover, in this case, there is no straightforward way to find out which conditions was not met. This is one reason why Knora does pre-update checks using separate SELECT queries and/or cached ontology data, before performing the update. This makes it possible to return specific error messages to the user to indicate why an update cannot be performed.\nMoreover, while some checks are easy to do in a SPARQL update, others are difficult, impractical, or impossible. Easy checks include checking whether a resource or value exists or is deleted, and checking that the knora-base:objectClassConstraint of a predicate matches the rdf:type of its intended object. Cardinality checks are not very difficult, but they perform poorly on Jena. Knora does not do permission checks in SPARQL, because its permission-checking algorithm is too complex to be implemented in SPARQL. For this reason, Knora’s check for duplicate values cannot be done in SPARQL update code, because it relies on permission checks.\nIn a bulk import operation, which can create a large number of resources in a single SPARQL update, a WHERE clause can become very expensive for the triplestore, in terms of memory as well as execution time. Moreover, RDF4J (and hence GraphDB) uses a recursive algorithm to parse SPARQL queries with WHERE clauses, so the size of a WHERE clause is limited by the stack space available to the Java Virtual Machine. Therefore, in bulk import operations, Knora uses INSERT DATA, which does not involve a WHERE clause. Bulk imports thus rely on checks (1) and (3) above.","title":"Ensuring Data Consistency"},{"location":"/03-webapi/design/triplestore-updates.html#sparql-update-examples","text":"The following sample SPARQL update code is simpler than what Knora actually does. It is included here to illustrate the way Knora’s SPARQL updates are structured and how concurrent updates are handled.","title":"SPARQL Update Examples"},{"location":"/03-webapi/design/triplestore-updates.html#finding-a-value-iri-in-a-values-version-history","text":"We will need this query below. If a value is present in a resource property’s version history, the query returns everything known about the value, or nothing otherwise:\nprefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix knora-base: <http://www.knora.org/ontology/knora-base#>\n\nSELECT ?p ?o\nWHERE {\n    BIND(IRI(\"http://data.knora.org/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://www.knora.org/ontology/0803/incunabula#book_comment\") as ?property)\n    BIND(IRI(\"http://data.knora.org/c5058f3a/values/testComment002\") as ?searchValue)\n\n    ?resource ?property ?currentValue .\n    ?currentValue knora-base:previousValue* ?searchValue .\n    ?searchValue ?p ?o .\n}","title":"Finding a value IRI in a value’s version history"},{"location":"/03-webapi/design/triplestore-updates.html#creating-the-initial-version-of-a-value","text":"prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix knora-base: <http://www.knora.org/ontology/knora-base#>\n\nWITH <http://www.knora.org/ontology/0803/incunabula>\nINSERT {\n    ?newValue rdf:type ?valueType ;\n              knora-base:valueHasString \"\"\"Comment 1\"\"\" ;\n              knora-base:attachedToUser <http://data.knora.org/users/91e19f1e01> ;\n              knora-base:attachedToProject <http://data.knora.org/projects/77275339> ;\n              knora-base:hasPermissions \"V knora-admin:KnownUser,knora-admin:UnknownUser|M knora-admin:ProjectMember\"  ;\n              knora-base:valueTimestamp ?currentTime .\n\n    ?resource ?property ?newValue .\n} WHERE {\n    BIND(IRI(\"http://data.knora.org/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://www.knora.org/ontology/0803/incunabula#book_comment\") as ?property)\n    BIND(IRI(\"http://data.knora.org/c5058f3a/values/testComment001\") AS ?newValue)\n    BIND(IRI(\"http://www.knora.org/ontology/knora-base#TextValue\") AS ?valueType)\n    BIND(NOW() AS ?currentTime)\n\n    # Do nothing if the resource doesn't exist.\n    ?resource rdf:type ?resourceClass .\n\n    # Do nothing if the submitted value has the wrong type.\n    ?property knora-base:objectClassConstraint ?valueType .\n}\nTo find out whether the insert succeeded, the application can use the query in Finding a value IRI in a value’s version history to look for the new IRI in the property’s version history.","title":"Creating the initial version of a value"},{"location":"/03-webapi/design/triplestore-updates.html#adding-a-new-version-of-a-value","text":"prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix knora-base: <http://www.knora.org/ontology/knora-base#>\n\nWITH <http://www.knora.org/ontology/0803/incunabula>\nDELETE {\n    ?resource ?property ?currentValue .\n} INSERT {\n    ?newValue rdf:type ?valueType ;\n              knora-base:valueHasString \"\"\"Comment 2\"\"\" ;\n              knora-base:previousValue ?currentValue ;\n              knora-base:attachedToUser <http://data.knora.org/users/91e19f1e01> ;\n              knora-base:attachedToProject <http://data.knora.org/projects/77275339> ;\n              knora-base:hasPermissions \"V knora-admin:KnownUser,knora-admin:UnknownUser|M knora-admin:ProjectMember\"  ;\n              knora-base:valueTimestamp ?currentTime .\n\n    ?resource ?property ?newValue .\n} WHERE {\n    BIND(IRI(\"http://data.knora.org/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://data.knora.org/c5058f3a/values/testComment001\") AS ?currentValue)\n    BIND(IRI(\"http://data.knora.org/c5058f3a/values/testComment002\") AS ?newValue)\n    BIND(IRI(\"http://www.knora.org/ontology/knora-base#TextValue\") AS ?valueType)\n    BIND(NOW() AS ?currentTime)\n\n    ?resource ?property ?currentValue .\n    ?property knora-base:objectClassConstraint ?valueType .\n}\nThe update request must contain the IRI of the most recent version of the value (http://data.knora.org/c5058f3a/values/c3295339). If this is not in fact the most recent version (because someone else has done an update), this operation will do nothing (because the WHERE clause will return no rows). To find out whether the update succeeded, the application will then need to do a SELECT query using the query in Finding a value IRI in a value’s version history. In the case of concurrent updates, there are two possibilities:\nUsers A and B are looking at version 1. User A submits an update and it succeeds, creating version 2, which user A verifies using a SELECT. User B then submits an update to version 1 but it fails, because version 1 is no longer the latest version. User B’s SELECT will find that user B’s new value IRI is absent from the value’s version history. Users A and B are looking at version 1. User A submits an update and it succeeds, creating version 2. Before User A has time to do a SELECT, user B reads the new value and updates it again. Both users then do a SELECT, and find that both their new value IRIs are present in the value’s version history.","title":"Adding a new version of a value"},{"location":"/03-webapi/design/triplestore-updates.html#getting-all-versions-of-a-value","text":"prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\nprefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nprefix knora-base: <http://www.knora.org/ontology/knora-base#>\n\nSELECT ?value ?valueTimestamp ?previousValue\nWHERE {\n    BIND(IRI(\"http://data.knora.org/c5058f3a\") as ?resource)\n    BIND(IRI(\"http://www.knora.org/ontology/0803/incunabula#book_comment\") as ?property)\n    BIND(IRI(\"http://data.knora.org/c5058f3a/values/testComment002\") AS ?currentValue)\n\n    ?resource ?property ?currentValue .\n    ?currentValue knora-base:previousValue* ?value .\n\n    OPTIONAL {\n        ?value knora-base:valueTimestamp ?valueTimestamp .\n    }\n\n    OPTIONAL {\n        ?value knora-base:previousValue ?previousValue .\n    }\n}\nThis assumes that we know the current version of the value. If the version we have is not actually the current version, this query will return no rows.","title":"Getting all versions of a value"},{"location":"/03-webapi/design/consistency-checking.html","text":"","title":"Consistency Checking"},{"location":"/03-webapi/design/consistency-checking.html#consistency-checking","text":"Requirements Design Empty string as object Subject and object class constraints Cardinality constraints\nOntotext GraphDB provides a mechanism for checking the consistency of data in a repository each time an update transaction is committed. Knora provides GraphDB-specific consistency rules that take advantage of this feature to provide an extra layer of consistency checks, in addition to the checks that are implemented in the Knora API server.","title":"Consistency Checking"},{"location":"/03-webapi/design/consistency-checking.html#requirements","text":"The Knora API server is designed to prevent inconsistencies in RDF data, as far as is practical, in a triplestore-independent way (see Triplestore Updates). However, it is also useful to enforce consistency constraints in the triplestore itself, for two reasons:\nTo prevent inconsistencies resulting from bugs in the Knora API server. To prevent users from inserting inconsistent data directly into the triplestore, bypassing the Knora API server.\nThe design of the knora-base ontology supports two ways of specifying constraints on data (see knora-base: Consistency Checking for details):\nA property definition should specify the types that are allowed as subjects and objects of the property, using knora-base:subjectClassConstraint and (if it is an object property) knora-base:objectClassConstraint. Every subproperty of knora-base:hasValue or a knora-base:hasLinkTo (i.e. every property of a resource that points to a knora-base:Value or to another resource) is required have this constraint, because the Knora API server relies on it to know what type of object to expect for the property. Use of knora-base:subjectClassConstraint is recommended but not required. A class definition should use OWL cardinalities (see OWL 2 Quick Reference Guide) to indicate the properties that instances of the class are allowed to have, and to constrain the number of objects that each property can have. Subclasses of knora-base:Resource are required to have a cardinality for each subproperty of knora-base:hasValue or a knora-base:hasLinkTo that resources of that class can have.\nSpecifically, consistency checking should prevent the following:\nAn object property or datatype property has a subject of the wrong class, or an object property has an object of the wrong class (GraphDB’s consistency checke cannot check the types of literals). An object property has an object that does not exist (i.e. the object is an IRI that is not used as the subject of any statements in the repository). This can be treated as if the object is of the wrong type (i.e. it can cause a violation of knora-base:objectClassConstraint, because there is no compatible rdf:type statement for the object). A class has owl:cardinality 1 or owl:minCardinality 1 on an object property or datatype property, and an instance of the class does not have that property. A class has owl:cardinality 1 or owl:maxCardinality 1 on an object property or datatype property, and an instance of the class has more than one object for that property. An instance of knora-base:Resource has an object property pointing to a knora-base:Value or to another Resource, and its class has no cardinality for that property. An instance of knora-base:Value has a subproperty of knora-base:valueHas, and its class has no cardinality for that property. A datatype property has an empty string as an object.\nCardinalities in base classes are inherited by derived classes. Derived classes can override inherited cardinalities by making them more restrictive, i.e. by specifying a subproperty of the one specified in the original cardinality.\nInstances of Resource and Value can be marked as deleted, using the property isDeleted. This must be taken into account as follows:\nWith owl:cardinality 1 or owl:maxCardinality 1, if the object of the property can be marked as deleted, the property must not have more than one object that has not been marked as deleted. In other words, it’s OK if there is more than one object, as long only one of them has knora-base:isDeleted false. With owl:cardinality 1 or owl:minCardinality 1, the property must have an object, but it’s OK if the property’s only object is marked as deleted. We allow this because the subject and object may have different owners, and it may not be feasible for them to coordinate their work. The owner of the object should always be able to mark it as deleted. (It could be useful to notify the owner of the subject when this happens, but that is beyond the scope of consistency checking.)","title":"Requirements"},{"location":"/03-webapi/design/consistency-checking.html#design","text":"When a repository is created in GraphDB, a set of consistency rules can be provided, and GraphDB’s consistency checker can be turned on to ensure that each update transaction respects these rules, as described in the section Reasoning of the GraphDB documentation. Like custom inference rules, consistency rules are defined in files with the .pie filename extension, in a GraphDB-specific syntax.\nWe have added rules to the standard RDFS inference rules file builtin_RdfsRules.pie, to create the file KnoraRules.pie. The .ttl configuration file that is used to create the repository must contain these settings:\nowlim:ruleset \"/path/to/KnoraRules.pie\" ;\nowlim:check-for-inconsistencies \"true\" ;\nThe path to KnoraRules.pie must be an absolute path. The scripts provided with Knora to create test repositories set this path automatically.\nConsistency checking in GraphDB relies on reasoning. GraphDB’s reasoning is Forward-chaining, which means that reasoning is applied to the contents of each update, before the update transaction is committed, and the inferred statements are added to the repository.\nA GraphDB rules file can contain two types of rules: inference rules and consistency rules. Before committing an update transaction, GraphDB applies inference rules, then consistency rules. If any of the consistency rules are violated, the transaction is rolled back.\nAn inference rule has this form:\nId: <rule_name>\n    <premises> <optional_constraints>\n    -------------------------------\n    <consequences> <optional_constraints>\nThe premises are a pattern that tries to match statements found in the data. Optional constraints, which are enclosed in square brackets, make it possible to specify the premises more precisely, or to specify a named graph (see examples below). Consequences are the statements that will be inferred if the premises match. A line of hyphens separates premises from consequences.\nA GraphDB consistency rule has a similar form:\nConsistency: <rule_name>\n    <premises> <optional_constraints>\n    -------------------------------\n    <consequences> <optional_constraints>\nThe differences between inference rules and consistency rules are:\nA consistency rule begins with Consistency instead of Id. In a consistency rule, the consequences are optional. Instead of representing statements to be inferred, they represent statements that must exist if the premises are satisfied. In other words, if the premises are satisfied and the consequences are not found, the rule is violated. If a consistency rule doesn’t specify any consequences, and the premises are satisfied, the rule is violated.\nRules use variable names for subjects, predicates, and objects, and they can use actual property names.","title":"Design"},{"location":"/03-webapi/design/consistency-checking.html#empty-string-as-object","text":"If subject i has a predicate p whose object is an empty string, the constraint is violated:\nConsistency: empty_string\n    i p \"\"\n    ------------------------------------","title":"Empty string as object"},{"location":"/03-webapi/design/consistency-checking.html#subject-and-object-class-constraints","text":"If subject i has a predicate p that requires a subject of type t, and i is not a t, the constraint is violated:\nConsistency: subject_class_constraint\n    p <knora-base:subjectClassConstraint> t\n    i p j\n    ------------------------------------\n    i <rdf:type> t\nIf subject i has a predicate p that requires an object of type t, and the object of p is not a t, the constraint is violated:\nConsistency: object_class_constraint\n    p <knora-base:objectClassConstraint> t\n    i p j\n    ------------------------------------\n    j <rdf:type> t","title":"Subject and object class constraints"},{"location":"/03-webapi/design/consistency-checking.html#cardinality-constraints","text":"A simple implementation of a consistency rule to check owl:maxCardinality 1, for objects that can be marked as deleted, could look like this:\nConsistency: max_cardinality_1_with_deletion_flag\n    i <rdf:type> r\n    r <owl:maxCardinality> \"1\"^^xsd:nonNegativeInteger\n    r <owl:onProperty> p\n    i p j\n    i p k [Constraint j != k]\n    j <knora-base:isDeleted> \"false\"^^xsd:boolean\n    k <knora-base:isDeleted> \"false\"^^xsd:boolean\n    ------------------------------------\nThis means: if resource i is a subclass of an owl:Restriction r with owl:maxCardinality 1 on property p, and the resource has two different objects for that property, neither of which is marked as deleted, the rule is violated. Note that this takes advantage of the fact that Resource and Value have owl:cardinality 1 on isDeleted (isDeleted must be present even if false), so we do not need to check whether i is actually something that can be marked as deleted.\nHowever, this implementation would be much too slow. We therefore use two optimisations suggested by Ontotext:\nAdd custom inference rules to make tables (i.e. named graphs) of pre-calculated information about the cardinalities on properties of subjects, and use those tables to simplify the consistency rules. Use the [Cut] constraint to avoid generating certain redundant compiled rules (see Entailment rules).\nFor example, to construct a table of subjects belonging to classes that have owl:maxCardinality 1 on some property p, we use the following custom inference rule:\nId: maxCardinality_1_table\n    i <rdf:type> r\n    r <owl:maxCardinality> \"1\"^^xsd:nonNegativeInteger\n    r <owl:onProperty> p\n    ------------------------------------\n    i p r [Context <onto:_maxCardinality_1_table>]\nThe constraint [Context <onto:_maxCardinality_1_table>] means that the inferred triples are added to the context (i.e. the named graph) http://www.ontotext.com/_maxCardinality_1_table. (Note that we have defined the prefix onto as http://www.ontotext.com/ in the Prefices section of the rules file.) As the GraphDB documentation on Rules explains:\nIf the context is provided, the statements produced as rule consequences are not ‘visible’ during normal query answering. Instead, they can only be used as input to this or other rules and only when the rule premise explicitly uses the given context.\nNow, to find out whether a subject belongs to a class with that cardinality on a given property, we only need to match one triple. The revised implementation of the rule max_cardinality_1_with_deletion_flag is as follows:\nConsistency: max_cardinality_1_with_deletion_flag\n    i p r [Context <onto:_maxCardinality_1_table>]\n    i p j [Constraint j != k]\n    i p k [Cut]\n    j <knora-base:isDeleted> \"false\"^^xsd:boolean\n    k <knora-base:isDeleted> \"false\"^^xsd:boolean\n    ------------------------------------\nThe constraint [Constraint j != k] means that the premises will be satisfied only if the variables j and k do not refer to the same thing.\nWith these optimisations, the rule is faster by several orders of magnitude.\nSince properties whose objects can be marked as deleted must be handled differently to properties whose objects cannot be marked as deleted, the knora-base ontology provides a property called objectCannotBeMarkedAsDeleted. All properties in knora-base whose objects cannot take the isDeleted flag (including datatype properties) should be derived from this property. This is how it is used to check owl:maxCardinality 1 for objects that cannot be marked as deleted:\nConsistency: max_cardinality_1_without_deletion_flag\n    i p r [Context <onto:_maxCardinality_1_table>]\n    p <rdfs:subPropertyOf> <knora-base:objectCannotBeMarkedAsDeleted>\n    i p j [Constraint j != k]\n    i p k [Cut]\n    ------------------------------------\nTo check owl:minCardinality 1, we do not care whether the object can be marked as deleted, so we can use this simple rule:\nConsistency: min_cardinality_1_any_object\n    i p r [Context <onto:_minCardinality_1_table>]\n    ------------------------------------\n    i p j\nThis means: if a subject i belongs to a class that has owl:minCardinality 1 on property p, and i has no object for p, the rule is violated.\nTo check owl:cardinality 1, we need two rules: one that checks whether there are too few objects, and one that checks whether there are too many. To check whether there are too few objects, we don’t care whether the objects can be marked as deleted, so the rule is the same as min_cardinality_1_any_object, except for the cardinality:\nConsistency: cardinality_1_not_less_any_object\n    i p r [Context <onto:_cardinality_1_table>]\n    ------------------------------------\n    i p j\nTo check whether there are too many objects, we need to know whether the objects can be marked as deleted or not. In the case where the objects can be marked as deleted, the rule is the same as max_cardinality_1_with_deletion_flag, except for the cardinality:\nConsistency: cardinality_1_not_greater_with_deletion_flag\n    i p r [Context <onto:_cardinality_1_table>]\n    i p j [Constraint j != k]\n    i p k [Cut]\n    j <knora-base:isDeleted> \"false\"^^xsd:boolean\n    k <knora-base:isDeleted> \"false\"^^xsd:boolean\n    ------------------------------------\nIn the case where the objects cannot be marked as deleted, the rule is the same as max_cardinality_1_without_deletion_flag, except for the cardinality:\nConsistency: cardinality_1_not_less_any_object\n    i p r [Context <onto:_cardinality_1_table>]\n    ------------------------------------\n    i p j\nKnora allows a subproperty of knora-base:hasValue or knora-base:hasLinkTo to be a predicate of a resource only if the resource’s class has some cardinality for the property. For convenience, knora-base:hasValue and knora-base:hasLinkTo are subproperties of knora-base:resourceProperty, which is used to check this constraint in the following rule:\nConsistency: resource_prop_cardinality_any\n    i <knora-base:resourceProperty> j\n    ------------------------------------\n    i p j\n    i <rdf:type> r\n    r <owl:onProperty> p\nIf resource i has a subproperty of knora-base:resourceProperty, and i is not a member of a subclass of an owl:Restriction r with a cardinality on that property (or on one of its base properties), the rule is violated.\nA similar rule, value_prop_cardinality_any, ensures that if a value has a subproperty of knora-base:valueHas, the value’s class has some cardinality for that property.","title":"Cardinality constraints"},{"location":"/03-webapi/design/authentication.html","text":"","title":"Authentication in the Knora API Server"},{"location":"/03-webapi/design/authentication.html#authentication-in-the-knora-api-server","text":"Scope Implementation Usage V1 Login and Logout Submitting Credentials Checking Credentials Usage Scenarios Usage V2 Login and Logout Submitting Credentials Checking Credentials Usage Scenarios Skipping Authentication Sipi (Media Server) Improving Security","title":"Authentication in the Knora API Server"},{"location":"/03-webapi/design/authentication.html#scope","text":"Authentication is the process of making sure that if someone is accessing something then this someone is actually also the someone he pretends to be. The process of making sure that someone is authorized, i.e. has the permission to access something, is handled as described in Authorisation).","title":"Scope"},{"location":"/03-webapi/design/authentication.html#implementation","text":"The authentication in Knora is based on Basic Auth HTTP basic authentication, URL parameters, JSON Web Token, and cookies. This means that on every request (to any of the routes), credentials need to be sent either via authorization header, URL parameters or cookie header.\nAll routes are always accessible and if there are no credentials provided, a default user is assumed. If credentials are sent and they are not correct (e.g., wrong username, password incorrect, token expired), then the request will end in an error message.\nThere are some differences in V1 and V2 of the API regarding authentication. They differ mainly in the format of the response and that creation of session cookies are only supported in V1 and tokens in V2. After login via either version, all routes (V1 and V2) are accessible.","title":"Implementation"},{"location":"/03-webapi/design/authentication.html#usage-v1","text":"","title":"Usage V1"},{"location":"/03-webapi/design/authentication.html#login-and-logout","text":"When a client accesses the /v1/session?login route successfully, it gets back headers requesting that a cookie is created, which will store the session token. On all subsequent calls to any route, this session token needs to be sent with each request. Normally, a web browser does this automatically, i.e. sends the cookie on every request. The session token is used by the server to retrieve the user profile. If successful, the user is deemed authenticated.\nTo logout the client can call the same route and provide the logout parameter /v1/session?logout. This will invalidate the session token and return headers for removing the cookie on the client.","title":"Login and Logout"},{"location":"/03-webapi/design/authentication.html#submitting-credentials","text":"For login, credentials in form of email and password need to be sent with the request.\nThere are two possibilities to do so:\nin the URL submitting the parameters email and password (e.g., http://knora-host/v1/resources/resIri?email=userUrlEncodedEmail&password=pw) in the HTTP authorization header (HTTP basic authentication) when doing a HTTP request to the API When using Python’s module requests, the credentials can simply be submitted as a tuple with each request using the param auth (python requests).\nAn alternative way for accessing all routes is to simply supply the email and password credentials on each request either as URL parameters or in the HTTP authorization header.","title":"Submitting Credentials"},{"location":"/03-webapi/design/authentication.html#checking-credentials","text":"To check the credentials, there is a special route called /v1/authenticate, which can be used to check if the credentials are valid.","title":"Checking Credentials"},{"location":"/03-webapi/design/authentication.html#usage-scenarios","text":"Create session by logging-in, send session token on each subsequent request, and logout when finished. Send email/password credentials on every request.","title":"Usage Scenarios"},{"location":"/03-webapi/design/authentication.html#usage-v2","text":"","title":"Usage V2"},{"location":"/03-webapi/design/authentication.html#login-and-logout","text":"A client sends a POST request (e.g., {\"email\":\"usersemail\", \"password\":\"userspassword\"}) to the /v2/authentication route with email and password in the body. If the credentials are valid, a JSON WEB Token (JWT) will be sent back in the response (e.g., {\"token\": \"eyJ0eXAiOiJ...\"}). On all subsequent calls to any route, this token can be sent with each request (instead of email/*password*). If the token is successfully validated, then the user is deemed authenticated.\nTo logout the client sends a DELETE request to the same route /v2/authentication and the token (either as an URL parameter or authorization header). This will invalidate the token.","title":"Login and Logout"},{"location":"/03-webapi/design/authentication.html#submitting-credentials","text":"When accessing any route and email/*password* credentials would need to be sent, we support two options to do so:\nin the URL submitting the parameters email and password (e.g., http://knora-host/v1/resources/resIri?email=userUrlEncodedEmail&password=pw) in the HTTP header (HTTP basic authentication) when doing a HTTP request to the API When using Python’s module requests, the credentials can simply be submitted as a tuple with each request using the param auth (python requests).\nWhen accessing any route and the token would need to be sent, we support two options to do so:\nin the URL submitting the parameter token (e.g., http://knora-host/v1/resources/resIri?token=1234567890) in the HTTP authorization header with the HTTP bearer scheme.","title":"Submitting Credentials"},{"location":"/03-webapi/design/authentication.html#checking-credentials","text":"To check the credentials, there is a special route called /v1/authenticate, which can be used to check if the credentials are valid.","title":"Checking Credentials"},{"location":"/03-webapi/design/authentication.html#usage-scenarios","text":"Create token by logging-in, send token on each subsequent request, and logout when finished. Send email/password credentials on every request.","title":"Usage Scenarios"},{"location":"/03-webapi/design/authentication.html#skipping-authentication","text":"There is the possibility to turn skipping authentication on and use a hardcoded user (Test User). In application.conf set the skip-authentication = true and Test User will be always assumed.","title":"Skipping Authentication"},{"location":"/03-webapi/design/authentication.html#sipi-media-server-","text":"For authentication to work with the media server, we need to add support for cookies. At the moment the SALSAH-App would set BasicAuth heathers, but this only works for AJAX requests using SALSAH.ApiGet (Put, etc.). Since the medias are embedded as source tags, the browser would get them on his own, and doesn’t know anything about the needed AuthHeathers. With cookies, the browser would send those automatically with every request. The media server can use the credentials of the user requesting something for accessing the RepresentationsRouteV1, i.e. make this request in the name of the user so to speak, then the RepresentationResponderV1 should have all the information it needs to filter the result based on the users permissions.","title":"Sipi (Media Server)"},{"location":"/03-webapi/design/authentication.html#improving-security","text":"In the first iteration, the email/password would be sent in clear text. Since we will use HTTPS this shouldn’t be a problem. The second iteration, could encrypt the email/password.","title":"Improving Security"},{"location":"/03-webapi/design/administration.html","text":"","title":"Administration (Users, Projects, Groups, Institutions, Permissions)"},{"location":"/03-webapi/design/administration.html#administration-users-projects-groups-institutions-permissions-","text":"Scope Implementation Overview Permissions Object Access Permissions Administrative Permissions Default Object Access Permissions Permission Precedence Rules Implicit Permissions Permission Templates Template: OPEN Template: CLOSED Default Permissions Matrix for new Projects Basic Workflows involving Permissions Creating a new Resource Accessing a Resource/Value Project / Group Administration Implementation Permission Class Hierarchy and Structure Querying Permission Instances Example Data stored in the permissions graph Use Cases UC01: Teaching a Class UC02: Unibas Librarian UC03: Crowdsourcing Project UC04: User “left” Knora Webapi Components Users Endpoint Projects Endpoint Groups Endpoint Permissions Endpoint Redesign / Questions June 2016","title":"Administration (Users, Projects, Groups, Institutions, Permissions)"},{"location":"/03-webapi/design/administration.html#scope","text":"This Section includes management (creation, updating, deletion) of Users, Projects, Groups, Institutions, and Permissions.","title":"Scope"},{"location":"/03-webapi/design/administration.html#implementation","text":"All administration functions will be implemented as part of the Knora API in the webapi codebase. There is also a separate web-application as part of the salsah codebase using this API, allowing basic management operations.","title":"Implementation"},{"location":"/03-webapi/design/administration.html#overview","text":"During the initial deployment of a Knora server, the main administration user (*root*) is created. This root user has the right to do anything.\nKnora’s concept of access control is that permissions can only be granted to groups (or the whole project, i.e. all members of a project) and not to individual users. There are two distinct ways of granting permission. Firstly, an object (a resource or value) can grant permissions to groups of users, and secondly, permissions can be granted directly to a group of users (not bound to a specific object). There are six built-in groups: UnknownUser, KnownUser, Creator, ProjectMember, ProjectAdmin, and SystemAdmin. These groups can be used in the same way as normal user created groups for permission management, i.e. can be used to give certain groups of users, certain permissions, without the need to explicitly create them.\nA user becomes implicitly a member of such a group by satisfying certain conditions:\nknora-base:UnknownUser: Any user who has not logged into the Knora API server is automatically assigned to this group. knora-base:KnownUser: Any user who has logged into the Knora API server is automatically assigned to this group. knora-base:Creator: When checking a user’s permissions on an object, the user is automatically assigned to this group if he is the creator of the object. knora-base:ProjectMember: When checking a user’s permissions, the user is automatically assigned to this group by being a member of a project designated by the knora-base:isInProject property. knora-base:ProjectAdmin: When checking a user’s permission, the user is automatically assigned to this group through the knora-base:isInProjectAdminGroup property, which points to the project in question. knora-base:SystemAdmin: Membership is received by setting the property knora-base:isInSystemAdminGroup to true on a knora-base:User.\nTo use these build-in groups as values for properties (Object Access and Default Permissions), the IRI is constructed by appending the name of the built-in group to knora-base, e.g., knora-base:KnownUser where knora-base corresponds to http://www.knora.org/ontology/knora-base#.","title":"Overview"},{"location":"/03-webapi/design/administration.html#permissions","text":"Up until know, we have mentioned two groups of permissions. The first called object access permissions, which contains permissions that point from explicit objects (resources/values) to groups. The second group of permissions called administrative permissions, and which contains permissions that are put on instances of knora-base:Permission objects directly affecting groups. There is another, third group of permissions, called default object access permissions which is also put on instances of knora-base:Permission, and which also directly affect groups.","title":"Permissions"},{"location":"/03-webapi/design/administration.html#object-access-permissions","text":"An object (resource / value) can grant the following permissions, which are stored in a compact format in a single string, which is the object of the predicate knora-base:hasPermissions:\nRestricted view permission (RV): Allows a restricted view of the object, e.g. a view of an image with a watermark. View permission (V): Allows an unrestricted view of the object. Having view permission on a resource only affects the user’s ability to view information about the resource other than its values. To view a value, she must have view permission on the value itself. Modify permission (M): For values, this permission allows a new version of a value to be created. For resources, this allows the user to create a new value (as opposed to a new version of an existing value), or to change information about the resource other than its values. When he wants to make a new version of a value, his permissions on the containing resource are not relevant. However, when he wants to change the target of a link, the old link must be deleted and a new one created, so he needs modify permission on the resource. Delete permission (D): Allows the item to be marked as deleted. Change rights permission (CR): Allows the permissions granted by the object to be changed.\nEach permission in the above list implies all lower-numbered permissions.\nA user’s permission level on a particular object is calculated in the following way:\nMake a list of the groups that the user belongs to, including Creator and/or ProjectMember and/or ProjectAdmin if applicable. Make a list of the permissions that she can obtain on the object, by iterating over the permissions that the object grants. For each permission, if she is in the specified group, add the specified permission to the list of permissions she can obtain. From the resulting list, select the highest-level permission. If the result is that she would have no permissions, give her whatever permission UnknownUser would have.\nThe format of the object of knora-base:hasPermissions is as follows:\nEach permission is represented by the one-letter or two-letter abbreviation given above. Each permission abbreviation is followed by a space, then a comma-separated list of groups that the permission is granted to. The IRIs of built-in groups are shortened using the knora-base prefix. Multiple permissions are separated by a vertical bar (|).\nFor example, if an object grants view permission to unknown and known users, and modify permission to project members, the resulting permission literal would be: :\nV knora-base:UnknownUser,knora-base:KnownUser|M knora-base:ProjectMember","title":"Object Access Permissions"},{"location":"/03-webapi/design/administration.html#administrative-permissions","text":"The following permissions can be set via instances of knora-base:AdministrativePermission on any group belonging to a project. For users that are members of a number of groups with administrative permissions attached, the final set of permissions is additive and most permissive. The administrative permissions are stored in a compact format in a single string, which is the object of the predicate knora-base:hasPermissions attached to an instance of the knora-base:AdministrativePermission class. The following permission values can be used:\nResource / Value Creation Permissions: 1) ProjectResourceCreateAllPermission: description: gives the permission to create resources inside the project. usage: used as a value for knora-base:hasPermissions. 2) ProjectResourceCreateRestrictedPermission: description: gives restricted resource creation permission inside the project. usage: used as a value for knora-base:hasPermissions. value: RestrictedProjectResourceCreatePermission followed by a comma-separated list of ResourceClasses the user should only be able to create instances of. Project Administration Permissions: 1) ProjectAdminAllPermission: description: gives the user the permission to do anything on project level, i.e. create new groups, modify all existing groups (*group info*, group membership, resource creation permissions, project administration permissions, and default permissions). usage: used as a value for knora-base:hasPermissions. 2) ProjectAdminGroupAllPermission: description: gives the user the permission to modify group info and group membership on all groups belonging to the project. usage: used as a value for the knora-base:hasPermissions property. 3) ProjectAdminGroupRestrictedPermission: description: gives the user the permission to modify group info and group membership on certain groups belonging to the project. usage: used as a value for knora-base:hasPermissions value: ProjectGroupAdminRestrictedPermission followed by a comma-separated list of knora-base:UserGroup. 4) ProjectAdminRightsAllPermission: description: gives the user the permission to change the permissions on all objects belonging to the project (e.g., default permissions attached to groups and permissions on objects). usage: used as a value for the knora-base:hasPermissions property. Ontology Administration Permissions: 1) ProjectAdminOntologyAllPermission: description: gives the user the permission to administer the project ontologies usage: used as a value for the knora-base:hasPermissions property.\nThe administrative permissions are stored in a compact format in a single string, which is the object of the predicate knora-base:hasPermissions attached to an instance of the knora-base:AdministrativePermission class.\nThe format of the object of knora-base:hasPermissions is as follows: Each permission is represented by the name given above. Each permission is followed by a space, then if applicable, by a comma separated list of IRIs, as defined above. The IRIs of built-in values (e.g., built-in groups, resource classes, etc.) are shortened using the knora-base prefix knora-base:. Multiple permissions are separated by a vertical bar (|).\nFor example, if an administrative permission grants the knora-base:ProjectMember group the permission to create all resources (*ProjectResourceCreateAllPermission*), the resulting administrative permission object with the compact form literal would be: :\n<http://rdfh.ch/permissions/001\n        rdf:type knora-base:AdministrativePermission ;\n        knora-base:forProject <http://rdfh.ch/projects/00FF>;\n        knora-base:forGroup knora-base:ProjectMember ;\n        knora-base:hasPermissions \"ProjectResourceCreateAllPermission\"^^xsd:string .","title":"Administrative Permissions"},{"location":"/03-webapi/design/administration.html#default-object-access-permissions","text":"Default Object Access Permissions are used when new objects (resources and/or values) are created. They represent object access permissions with which the new object will be initially outfitted. As with administrative permissions, these default object access permissions can be defined for any number of groups. Additionally, they can be also defined for resource classes and properties.\nThe following default object access permissions can be attached to groups, resource classes and/or properties via instances of knora-base:DefaultObjectAccessPermission (described further bellow). The default object access permissions correspond to the earlier described object access permission:\nDefault Restricted View Permission (RV): description: any object, created by a user inside a group holding this permission, is restricted to carry this permission value: RV followed by a comma-separated list of knora-base:UserGroup Default View Permission (V): description: any object, created by a user inside a group holding this permission, is restricted to carry this permission value: V followed by a comma-separated list of knora-base:UserGroup Default Modify Permission (M) accompanied by a list of groups. description: any object, created by a user inside a group holding this permission, is restricted to carry this permission value: M followed by a comma-separated list of knora-base:UserGroup Default Delete Permission (D) accompanied by a list of groups. description: any object, created by a user inside a group holding this permission, is restricted to carry this permission value: D followed by a comma-separated list of knora-base:UserGroup Default Change Rights Permission (CR) accompanied by a list of groups. description: any object, created by a user inside a group holding this permission, is restricted to carry this permission value: CR followed by a comma-separated list of knora-base:UserGroup\nA single instance of knora-base:DefaultObjectAccessPermission must always reference a project, but can only reference either a group (knora-base:forGroup property), a resource class (knora-base:forResourceClass), a property (knora-base:forProperty), or a combination of resource class and property.\nExample default object access permission instance:\n<http://rdfh.ch/permissions/002\n        rdf:type knora-base:DefaultObjectAccessPermission ;\n        knora-base:forProject <http://rdfh.ch/projects/00FF>;\n        knora-base:forGroup knora-base:ProjectMember ;\n        knora-base:hasPermissions \"CR knora-base:Creator|M knora-base:ProjectMember|V knora-base:KnownUser\"^^xsd:string .\nThis instance is setting default object access permissions to the project member group of a project, giving change right permission to the creator, modify permission to all project members, and view permission to known users. Further, this implicitly applies to all resource classes and all their properties inside the project.","title":"Default Object Access Permissions"},{"location":"/03-webapi/design/administration.html#permission-precedence-rules","text":"For both administrative permissions and default object access permissions, the resulting permissions are derived by applying precedence rules, for the case that the user is member of more than one group.\nThe following list is sorted by the permission precedence level in descending order:\npermissions on knora-base:ProjectAdmin (highest level) permissions on resource classes and property combination (own project) permissions on resource classes and property combination (knora-base:SystemProject) permissions on resource classes / properties (own project) permissions on resource classes / properties (knora-base:SystemProject) permissions on custom groups permissions on knora-base:ProjectMember permissions on knora-base:KnownUser (lowest level)\nThe permissions on resource classes / properties are only relevant for default object access permissions.\nAdministrative Permissions: When a user performs an operation requiring administrative permissions, then only the permissions from the highest level are taken into account. If a user is a member of more than one group on the same level (only possible for custom groups) then the defined permissions are summed up and all are taken into account.\nDefault Object Access Permissions: When a user creates a resource or value, then only the default object permissions from the highest level are applied. If a user is a member of more than one group on the same level (only possible for custom groups) then the defined permissions are summed up and the most permissive are applied.\nIn the case of users belonging to the SystemAdmin group, but which are not members of a project and thus no group belonging to the project, the default object access permissions from the highest defined level will apply.\nIn the case of users belonging to the SystemAdmin group, but which are not members of a project and thus not members of any group belonging to the project, the default object access permissions from the ProjectAdmin, ProjectMember, or KnownUser group will be applied in the order of precedence. If no permissions are defined on either of these groups, then the resulting permission will be CR knora-base:Creator.\nAlso, in the case that no default object access permissions are defined for the project, the resulting permission will be CR knora-base:Creator.","title":"Permission Precedence Rules"},{"location":"/03-webapi/design/administration.html#implicit-permissions","text":"The knora-base:SystemAdmin group receives implicitly the following permissions:\nreceives implicitly ProjectAllAdminPermission for all projects. receives implicitly ProjectResourceCreateAllPermission for all projects. receives implicitly CR on all objects from all projects.\nTheses permissions are baked into the system, and cannot be changed.","title":"Implicit Permissions"},{"location":"/03-webapi/design/administration.html#permission-templates","text":"The permission capabilities of Knora are very large, as it needs to be able to satisfy a broad set of requirements. To simplify permission management for the users, we provide permission templates, which can be used during creation of new projects, or applied to existing projects. A permission template defines a set of administrative and default object access permission. Currently, two different templates will be defined OPEN, CLOSED.","title":"Permission Templates"},{"location":"/03-webapi/design/administration.html#template-open","text":"The OPEN template defines the following permissions:\nThe knora-base:ProjectAdmin group: receives explicitly ProjectResourceCreateAllPermission. receives explicitly ProjectAllAdminPermission. The knora-base:ProjectMember group: receives explicitly ProjectResourceCreateAllPermission. receives explicitly CR for the knora-base:Creator and knora-base:ProjectAdmin group. receives explicitly M for the ProjectMember group. receives explicitly V for the knora-base:KnownUser group.","title":"Template: OPEN"},{"location":"/03-webapi/design/administration.html#template-closed","text":"The CLOSED template, defined the following permissions:\nThe knora-base:ProjectAdmin group: receives explicitly ProjectResourceCreateAllPermission. receives explicitly ProjectAllAdminPermission. The knora-base:ProjectMember group: receives explicitly ProjectResourceCreateAllPermission. receives explicitly CR for the knora-base:ProjectAdmin group. receives explicitly M for the ProjectMember group.","title":"Template: CLOSED"},{"location":"/03-webapi/design/administration.html#default-permissions-matrix-for-new-projects","text":"The access control matrix defines what are the default operations a subject (i.e. User), being a member of a built-in group (represented by row headers), is permitted to perform on an object (represented by column headers). The different operation abbreviations used are defined as follows:\nC: Create - the subject inside the group is allowed to create the object. U: Update - the subject inside the group is allowed to update the object. R: Read - the subject inside the group is allowed to read all information about the object. D: Delete - the subject inside the group is allowed to delete the object. P: Permission - the subject inside the group is allowed to change the permissions on the object. -: none - none or not applicable\nBuilt-In Group Project Group User Resource Value SystemAdmin CRUD CRUDP CRUDP all CRUDP all CRUDP all ProjectAdmin -RUD CRUDP CRUDP +/- project CRUDP (in project) CRUDP (in project) ProjectMember ---- ----- ----- CRUD- (in project) ----- (in project) Creator ---- ----- ----- -RUDP (his resource) ----- (his value) KnownUser C--- C---- CRUD- himself R---- (in project) R---- (in project)\nDefault Permissions Matrix for new Projects","title":"Default Permissions Matrix for new Projects"},{"location":"/03-webapi/design/administration.html#basic-workflows-involving-permissions","text":"","title":"Basic Workflows involving Permissions"},{"location":"/03-webapi/design/administration.html#creating-a-new-resource","text":"","title":"Creating a new Resource"},{"location":"/03-webapi/design/administration.html#accessing-a-resource-value","text":"","title":"Accessing a Resource/Value"},{"location":"/03-webapi/design/administration.html#project-group-administration","text":"","title":"Project / Group Administration"},{"location":"/03-webapi/design/administration.html#implementation","text":"The requirements for defining default permissions imposed by all the different use cases are very broad. Potentially, we need to be able to define default permissions per project, per group, per resource class, per resource property, and all their possible combinations.\nFor this reason, we introduce the knora-base:Permission class with two sub-classes, namely knora-base:AdministrativePermission and knora-base:DefaultObjectAccessPermission, which instances will carry all the necessary information.","title":"Implementation"},{"location":"/03-webapi/design/administration.html#permission-class-hierarchy-and-structure","text":"The following graphs show the class hierarchy and the structure of each permission class.\nPermission Class Hierarchy\nAdministrative Permission Structure:\nand the same as RDF:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:AdministrativePermission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forGroup <http://rdfh.ch/groups/[shortcode]/[UUID]> ;\n     knora-base:hasPermissions \"ProjectResourceCreateAllPermission|\n                                ProjectResourceCreateRestrictedPermission \"<Resource Class IRI>\"|\n                                ProjectAdminAllPermission|\n                                ProjectAdminGroupAllPermission|\n                                ProjectAdminGroupRestrictedPermission \"<http://rdfh.ch/groups/[shortcode]/[UUID]>, <http://rdfh.ch/groups/[shortcode]/[UUID]>\"|\n                                ProjectAdminRightsAllPermission|\n                                ProjectAdminOntologyAllPermission\"^^xsd:string .\nDefault Object Access Permission Structure:\nand the same as RDF:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:DefaultObjectAccessPermission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forGroup <http://rdfh.ch/groups/[shortcode]/[UUID]> ;\n     knora-base:forResourceClass \"Resource Class Name\" ;\n     knora-base:forProperty \"Resource Property Name\" ;\n     knora-base:hasPermissions \"RV <http://rdfh.ch/groups/[shortcode]/[UUID]>|\n                                 V <http://rdfh.ch/groups/[shortcode]/[UUID]>|\n                                 M <http://rdfh.ch/groups/[shortcode]/[UUID]>|\n                                 D <http://rdfh.ch/groups/[shortcode]/[UUID]>|\n                                CR <http://rdfh.ch/groups/[shortcode]/[UUID]>\"^^xsd:string .","title":"Permission Class Hierarchy and Structure"},{"location":"/03-webapi/design/administration.html#querying-permission-instances","text":"The properties forProject and either of forGroup, forResourceClass, and forProperty form together a compound key, allowing finding existing permission instances, that address the same set of Project / Group / ResourceClass / Property combination, thus making it possible to extend or change the attached permissions.\nAdministrative Permission Instances: For each group inside the project, there can be zero or one instance holding administrative permission information. Querying is straitforward by using the knora-base:forProject and knora-base:forGroup properties as the compound key.\nDefault Object Access Permission Instances: For each group, resource class, or property inside the project, there can be zero or one instances holding default object access permission informations. Querying is straitforward by using the knora-base:forProject and either knora-base:forGroup, knora-base:forResourceClass, or knora-base:forProperty properties as part of the compound key.","title":"Querying Permission Instances"},{"location":"/03-webapi/design/administration.html#example-data-stored-in-the-permissions-graph","text":"Administrative permissions on a ‘ProjectAdmin’ group:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:AdministrativePermission ;\n     knora-base:forProject <http://rdfh.ch/projects/00FF> ;\n     knora-base:forGroup knora-base:ProjectAdmin ;\n     knora-base:hasPermissions \"ProjectResourceCreateAllPermission|\n                                ProjectAdminAllPermission\"^^xsd:string .\nAdministrative permissions on a ‘ProjectMember’ group:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:AdministrativePermission ;\n     knora-base:forProject <http://rdfh.ch/projects/00FF> ;\n     knora-base:forGroup knora-base:ProjectMember ;\n     knora-base:hasPermissions \"ProjectResourceCreateAllPermission\"^^xsd:string .\nAdministrative permission restricting project admin permission on a group:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:Permission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forGroup <http://rdfh.ch/groups/[shortcode]/[UUID]> ;\n     knora-base:hasPermissions \"ProjectGroupAdminRestrictedPermission <http://rdfh.ch/groups/[shortcode]/[UUID]>\"^^xsd:string .\nAdministrative permission restricting resource creation for a group:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:AdministrativePermission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forGroup <http://rdfh.ch/groups/[shortcode]/[UUID]> ;\n     knora-base:hasPermissions \"ProjectResourceCreateRestrictedPermission <http://www.knora.org/ontology/00FF/images#Person>\"^^xsd:string .\nDefault object access permission on a ‘ProjectMember’ group:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:DefaultObjectAccessPermission ;\n     knora-base:forProject <http://rdfh.ch/projects/00FF> ;\n     knora-base:forGroup knora-base:ProjectMember ;\n     knora-base:hasPermissions \"CR knora-base:Creator|\n                                 M <http://rdfh.ch/groups/[shortcode]/[UUID]>|\n                                 V knora-base:KnownUser\"^^xsd:string .\nDefault object access permission on a resource class:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:DefaultObjectAccessPermission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forResourceClass <http://www.knora.org/ontology/00FF/images#person> ;\n     knora-base:hasPermissions \"CR knora-base:Creator,knora-base:ProjectMember|\n                                 V knora-base:KnownUser,knora-base:UnknownUser\"^^xsd:string .\nDefault object access permission on a resource property:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:DefaultObjectAccessPermission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forProperty <http://www.knora.org/ontology/00FF/images#lastname> ;\n     knora-base:hasPermissions \"D knora-base:ProjectMember,knora-base:Creator|\n                                V knora-base:KnownUser,knora-base:UnknownUser\"^^ .\nDefault object access permission on a resource class and property:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:DefaultObjectAccessPermission ;\n     knora-base:forProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:forResourceClass <http://www.knora.org/ontology/00FF/images#person> ;\n     knora-base:forProperty <http://www.knora.org/ontology/00FF/images#lastname> ;\n     knora-base:hasPermissions \"CR knora-base:Creator,knora-base:ProjectMember|\n                                 V knora-base:KnownUser,knora-base:UnknownUser\"^^xsd:string .\nDefault object access permission on a knora-base property:\n<http://rdfh.ch/permissions/[UUID]> rdf:type knora-base:DefaultObjectAccessPermission ;\n     knora-base:forProject knora-base:SystemProject ;\n     knora-base:forProperty <http://www.knora.org/ontology/knora-base#hasStillImageFileValue> ;\n     knora-base:hasPermissions \"RV knora-base:UnknownUser|\n                                 V knora-base:KnownUser|\n                                 M knora-base:ProjectMember,knora-base:Creator\"^^xsd:string .\nA the time the user’s UserProfile is queried, all permissions for all projects and groups the user is a member of are also queried. This information is then stored as an easy accessible object inside the UserProfile, being readily available wherever needed. As this is a somewhat expensive operation, built-in caching mechanism at different levels (e.g., UsersResponder, PermissionsResponder), will be applied.","title":"Example Data stored in the permissions graph"},{"location":"/03-webapi/design/administration.html#use-cases","text":"","title":"Use Cases"},{"location":"/03-webapi/design/administration.html#uc01-teaching-a-class","text":"Description: I’m teaching a class and I have the names and email addresses of all the students. I want to create a project, divide the students into groups (which will only be relevant to this project, e.g. one group for each section of the class), and put some students in each group. I don’t want people to be able to join the project or the group by themselves. Solution: The teacher creates different groups and adds users to those groups. Additionally, the teacher can give TA’s GroupAdmin privileges, and let the TA’s add students to the different groups.","title":"UC01: Teaching a Class"},{"location":"/03-webapi/design/administration.html#uc02-unibas-librarian","text":"Description: I’m a Unibas librarian managing several archiving projects. I need to give everyone at the university permission to view all these projects. I want to create a group called UnibasUser that everyone with a Unibas email address will automatically belong to. Most of the resources in those projects can then grant view permission to UnibasUser. Or perhaps the group will be SwitchUser, for anyone at a Swiss university. Or something even broader. Solution: These can be solved by creating Smart Groups, where the user can define what properties need to be set, so that an user is automatically part of this group. This will be implemented at a later time, as it is not trivial and should also include all special groups (e.g., KnownUser, ProjectMember, ProjectAdmin, etc.) that are currently hard-coded inside the system.","title":"UC02: Unibas Librarian"},{"location":"/03-webapi/design/administration.html#uc03-crowdsourcing-project","text":"Description: I’m doing a crowdsourcing project, which involves several different groups that work on different tasks. I’m hoping for thousands of users, and I’d like anyone to be able to join the project and add themselves to any group they want (as long as Knora verifies their email address), without needing approval from me. Solution: This can be solved by allowing self-assignment to a group.","title":"UC03: Crowdsourcing Project"},{"location":"/03-webapi/design/administration.html#uc04-user-knora","text":"Description: An user who was an active collaborator, decides to “quit”, and wants to delete his user. Solution: The user’s IRI is saved on each value change as part of the versioning mechanism. Exchanging the user’s IRI in those places would count as ‘rewriting history’. So deleting a user will not be possible, instead the user will be set as not active.","title":"UC04: User “left” Knora"},{"location":"/03-webapi/design/administration.html#webapi-components","text":"For the management of users, projects, and groups, the Knora API following a resource centric approach, provides three endpoints corresponding to the three classes of objects that they have an effect on, namely:\nUsers Endpoint: http://server:port/v1/users - knora-base:User Projects Endpoint: http://server:port/v1/projects - knora-base:knoraProject Groups Endpoint: http://server:port/v1/groups - knora-base:UserGroup\nAll information regarding users, projects and groups is stored in the http://www.knora.org/admin named graph.","title":"Webapi Components"},{"location":"/03-webapi/design/administration.html#users-endpoint","text":"Get users GET: /v1/users Get user GET:/v1/users/<userIri> Create user: Required permission: none, self-registration is allowed Required information: email (unique), given name, family name, password, password, status, systemAdmin Returns information about the newly created user TypeScript Docs: userFormats - CreateUserApiRequestV1 POST: /v1/users/ BODY:\n{\n  \"email\": \"donald.duck@example.org\",\n  \"givenName\": \"Donald\",\n  \"familyName\": \"Duck\",\n  \"password\": \"test\",\n  \"status\": true,\n  \"lang\": \"en\",\n  \"systemAdmin\": false\n}\nUpdate user information: Required permission: SystemAdmin / User Changeable information: email, given name, family name, password, status, SystemAdmin membership Remark: There are four distinct use case / payload combination. It is not possible to mix cases, e.g., sending newUserStatus and basic user information at the same time will result in an error: (1) change password: oldPassword, newPassword, (2) change status: newUserStatus, (3) change system admin membership: newSystemAdminMembershipStatus, and (4) change basic user information: email, givenName, familyName, lang TypeScript Docs: userFormats - ChangeUserApiRequestV1 PUT: /v1/users/<userIri> BODY:\n{\n  \"email\": \"donald.big.duck@example.org\",\n  \"givenName\": \"Big Donald\",\n  \"familyName\": \"Duckmann\",\n  \"lang\": \"de\"\n}\nUpdate user’s password Required permission: User Changeable information: password PUT: /v1/users/<userIri> BODY:\n{\n  \"oldPassword\": \"test\",\n  \"newPassword\": \"test1234\"\n}\nDelete user: Required permission: SystemAdmin / User Remark: The same as updating a user and changing status to false. To un-delete, set status to true. PUT: /v1/users/<userIri> BODY:\n{\n  \"status\": false // true or false\n}\nDelete user (-\\update user) Required permission: SystemAdmin / User Remark: The same as updating a user and changing status to false. To un-delete, set status to true. DELETE: /v1/projects/<projectIri> BODY: empty Get user’s project memberships GET: /v1/users/projects/<userIri> Add/remove user to/from project: Required permission: SystemAdmin / ProjectAdmin / User (if project self-assignment is enabled) Required information: project IRI, user IRI Effects: knora-base:isInProject user property POST / DELETE: /v1/users/projects/<userIri>/<projectIri> BODY: empty Get user’s project admin memberships GET: /v1/users/projects-admin/<userIri> Add/remove user to/from project admin group Required permission: SystemAdmin / ProjectAdmin Required information: project IRI, user IRI Effects: knora-base:isInProjectAdminGroup user property POST / DELETE: /v1/users/projects-admin/<userIri>/<projectIri> BODY: empty Get user’s group memberships GET: /v1/users/groups/<userIri> Add/remove user to/from ‘normal’ group (not SystemAdmin or ProjectAdmin): Required permission: SystemAdmin / hasProjectAllAdminPermission / hasProjectAllGroupAdminPermission / hasProjectRestrictedGroupAdminPermission (for this group) / User (if group self-assignment is enabled) Required information: group IRI, user IRI Effects: knora-base:isInGroup POST / DELETE: /v1/users/groups/<userIri>/<groupIri> BODY: empty Add/remove user to/from system admin group: Required permission: SystemAdmin / User Effects property: knora-base:isInSystemAdminGroup with value true or false PUT: /v1/users/<userIri> BODY:\n{\n  \"newSystemAdminMembershipStatus\": false // true or false\n}\nExample User Information stored in admin graph: :\n<http://rdfh.ch/users/91e19f1e01> rdf:type knora-base:User ;\n     knora-base:email \"test@test.ch\"^^xsd:string ;\n     knora-base:givenName \"Administrator\"^^xsd:string ;\n     knora-base:familyName \"Admin\"^^xsd:string ;\n     knora-base:password \"$2a$10$fTEr/xVjPq7UBAy1O6KWKOM1scLhKGeRQdR4GTA997QPqHzXv0MnW\"^^xsd:string ;\n     knora-base:phone \"123456\" ;\n     knora-base:preferredLanguage \"de\"^^xsd:string ;\n     knora-base:status \"true\"^^xsd:boolean ;\n     knora-base:isInProject <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:isInSystemAdminGroup \"true\"^^xsd:boolean ;\n     knora-base:isInProjectAdminGroup <http://rdfh.ch/projects/[shortcode]> ;\n     knora-base:isInGroup <http://rdfh.ch/groups/[shortcode]/[UUID]> .","title":"Users Endpoint"},{"location":"/03-webapi/design/administration.html#projects-endpoint","text":"Create project: Required permission: SystemAdmin Required information: shortname (unique; used for named graphs), status, selfjoin Optional information: longname, description, keywords, logo Returns information about the newly created project Remark: There are two distinct use cases / payload combination: (1) change ontology and data graph: ontologygraph, datagraph, (2) basic project information: shortname, longname, description, keywords, logo, institution, status, selfjoin TypeScript Docs: projectFormats - CreateProjectApiRequestV1 POST: /v1/projects/ BODY:\n{\n  \"shortname\": \"newproject\",\n  \"longname\": \"project longname\",\n  \"description\": \"project description\",\n  \"keywords\": \"keywords\",\n  \"logo\": \"/fu/bar/baz.jpg\",\n  \"status\": true,\n  \"selfjoin\": false\n}\nUpdate project information: Required permission: SystemAdmin / ProjectAdmin Changeable information: shortname, longname, description, keywords, logo, status, selfjoin TypeScript Docs: projectFormats - ChangeProjectApiRequestV1 PUT: /v1/projects/<projectIri> BODY:\n{\n  \"shortname\": \"newproject\",\n  \"longname\": \"project longname\",\n  \"description\": \"project description\",\n  \"keywords\": \"keywords\",\n  \"logo\": \"/fu/bar/baz.jpg\",\n  \"status\": true,\n  \"selfjoin\": false\n}\nGet project members Required permission: SystemAdmin / ProjectAdmin Required information: project IRI GET: /v1/projects/members/<projectIri> Delete project (-\\update project): Required permission: SystemAdmin / ProjectAdmin Remark: The same as updating a project and changing status to false. To un-delete, set status to true. DELETE: /v1/projects/<projectIri> BODY: empty\nExample Project Information stored in admin named graph: :\n<http://rdfh.ch/projects/[shortcode]>\n     rdf:type knora-base:knoraProject ;\n     knora-base:projectShortname \"images\" ;\n     knora-base:projectShortcode \"00FF\" ;\n     knora-base:projectLongname \"Images Collection Demo\" ;\n     knora-base:projectOntology <http://www.knora.org/ontology/00FF/images> ;\n     knora-base:isActiveProject \"true\"^^xsd:boolean ;\n     knora-base:hasSelfJoinEnabled \"false\"^^xsd:boolean .\nMigration Notes:\nThe knora-base:projectOntologyGraph was renamed to knora-base:projectOntology. Also before it was a xsd:string, where now it needs to be an IRI. The knora-base:projectDataGraph is removed. The knora-base:projectShortcode property was added.","title":"Projects Endpoint"},{"location":"/03-webapi/design/administration.html#groups-endpoint","text":"Create group: Required permission: SystemAdmin / hasProjectAllAdminPermission / hasProjectAllGroupAdminPermission Required information: name (unique inside project), project IRI Optional information: group description Returns information about the newly created group TypeScript Docs: groupFormats - CreateGroupApiRequestV1 POST: /v1/groups BODY:\n{\n  \"name\": \"NewGroup\",\n  \"description\": \"NewGroupDescription\",\n  \"project\": \"http://rdfh.ch/projects/00FF\",\n  \"status\": true,\n  \"selfjoin\": false\n}\nUpdate group information: Required permission: SystemAdmin / hasProjectAllAdminPermission / hasProjectAllGroupAdminPermission / hasProjectRestrictedGroupAdminPermission (for this group) Changeable information: name, description, status, selfjoin TypeScript Docs: groupFormats - ChangeGroupApiRequestV1 PUT: /v1/groups/<groupIri> BODY:\n{\n  \"name\": \"UpdatedGroupName\",\n  \"description\": \"UpdatedGroupDescription\".\n  \"status\": true,\n  \"selfjoin\": false\n}\nDelete group (-\\update group): Required permission: SystemAdmin / hasProjectAllAdminPermission Remark: The same as updating a group and changing status to false. To un-delete, set status to true. DELETE: /v1/groups/<groupIri>\nExample Group Information stored in admin named graph: :\n<http://rdfh.ch/groups/[shortcode]/[UUID]>\n     rdf:type knora-base:UserGroup ;\n     knora-base:groupName \"Name of the group\" ;\n     knora-base:groupDescription \"A description of the group\" ;\n     knora-base:belongsToProject <http://rdfh.ch/projects/[UUID]> ;\n     knora-base:status \"true\"^^xsd:boolean ;\n     knora-base:hasSelfJoinEnabled \"false\"^^xsd:boolean .","title":"Groups Endpoint"},{"location":"/03-webapi/design/administration.html#permissions-endpoint","text":"Add/change/delete administrative permissions: Required permission: SystemAdmin / hasProjectAllAdminPermission / hasProjectRightsAdminPermission Add/change/delete default object access permissions: Required permission: SystemAdmin / hasProjectAllAdminPermission / hasProjectRightsAdminPermission","title":"Permissions Endpoint"},{"location":"/03-webapi/design/administration.html#redesign-questions-june-2016","text":"Permissions constrained to groups Why this constraint? This is just the way we are doing it. Makes it a bit simpler.\nResource owner permission to disruptive\nknora-base:attachedToUser gives owner status to the person who created the resource. Proposed change: remove this altogether or make institution/project owner of the resource. Should hiwis be “owners” of resources they create on behalf of their professor? If the creator should have max permission, then give it explicitly. Owner will be renamed to creator. We need this for provenance. Does not give any permissions automatically. The permissions depend on what is defined for the project and the creator smart group.\nResource creation permission to course\nbeing part of a projects gives resource creation permission. What if some project members are not allowed to create new resources (or only certain types; Lumiere Lausanne requirement), but are only allowed to change existing resources? These kind of permissions can be set on groups. A project can have different groups, giving different kind of permissions.\nSupport Default Permissions\nAllow for a project to define permissions that a newly created resource inside a project should receive (current Salsah behavior) Lumiere Lausanne requirement Will be allowed.\nGroups\nDo groups belong to projects, i.e. are they seen as extensions to projects? Does someone need to be part of a project to belong to a group of that project? Every group needs to belong to a project. No GroupAdmins. ProjectAdmins with additional GroupAdmin permissions.\nroot\nShould the ‘root’ / SystemAdmin user have ‘implicitly’ or ‘explicitly’ all permissions? Has implicitly all permissions. Does the has all permissions also extend to projects? Is the root user going to be part of every project? If yes, then again implicitly or explicitly? Since ‘root’ / SystemAdmin already has all permissions, doesn’t really matter if part of a project or group\nIvan’s Use Case\nThe system administrator creates the project and sets Ivan as the project administrator. As the project administrator, I have all permissions on all objects (Resources/Values; Project Groups) belonging to the project (knora-base:attachedToProject). Nobody outside of the project should be allowed to see anything that is created as part of Ivan’s project. He wants to be able to create two groups: Reviewer, Creator. The Reviewer group should only give read-access to someone inside the group to resources pointing to this group, but allow the creation of annotations. Further, annotations should only be readable by users inside the Reviewer group. The Creator group should give a user create permission and modify permission on the objects the user has created. Any resources created belong to the project. The Creator group is meant for contributors helping out with the project, e.g., Hiwis. Covered\nLausanne Projects\nA project wants to restrict the permissions of newly created resources to a fixed set Covered. Will be able do define ‘default permissions’ and restrict the creation of new resources to these permissions This means for the current implementation, that any permissions supplied during the resource creation request need to be checked and if needed overriden. Covered. Also in the new design, the backend will need to always check the suplied permissions for newly created resources as we cannot ve sure that the GUI will behave correctly (e.g., many different “Salsah” implementations) Restrict creation/access of certain classes of resources to certain groups, e.g., group A is able to create/access resources of class A but not of class B. Covered. Will be able to give a certain group only create permission for specific classes\nResults\nOwner renamed to Creator Some permissions are attached to groups (e.g., Add Resource (Class), Modify Ontology, etc.), and some are attached to resources (e.g., this group has read/modify permission, etc.) Ontologien Benutzung einschränken (nur auf bestimmte Gruppen, oder frei zur Verfügung) System Admin Rechte implizit Gruppen immer an Projekt gebunden Keine Gruppen-Admins. Soll über Rollen vom Projekt-Admin geregelt werden können.","title":"Redesign / Questions June 2016"},{"location":"/03-webapi/design/api-v2.html","text":"","title":"Knora API v2 Design"},{"location":"/03-webapi/design/api-v2.html#knora-api-v2-design","text":"General Principles API Schemas Implementation JSON-LD Parsing and Formatting Operation Wrappers Smart IRIs Usage Implementation","title":"Knora API v2 Design"},{"location":"/03-webapi/design/api-v2.html#general-principles","text":"Knora API v2 requests and responses are RDF documents. Currently only JSON-LD documents are supported. Support for XML is planned. Each class or property used in a request or response has a definition in an ontology, which the Knora API server can serve. Response formats are reused for different requests whenever possible, to minimise the number of different response formats a client has to handle. For example, any request for one or more resources (such as a search result, or a request for one specific resource) returns a response in the same format. Response size is limited by design. Large amounts of data must be retrieved by requesting small pages of data, one after the other. Responses that provide data are distinct from responses that provide definitions (i.e. ontology entities). Data responses indicate which types are used, and the client can request information about these types separately.","title":"General Principles"},{"location":"/03-webapi/design/api-v2.html#api-schemas","text":"The types used in the triplestore are not exposed directly in the API. Instead, they are mapped onto API ‘schemas’. Two schemas are currently provided.\nA default schema, which is suitable both for reading and for editing data. The default schema represents values primarily as complex objects. A simple schema, which is suitable for reading data but not for editing it. The simple schema facilitates interoperability between Knora ontologies and non-Knora ontologies, since it represents values primarily as literals.\nEach schema has its own type IRIs, which are derived from the ones used in the triplestore. For details of these different IRI formats, see Knora IRIs.","title":"API Schemas"},{"location":"/03-webapi/design/api-v2.html#implementation","text":"","title":"Implementation"},{"location":"/03-webapi/design/api-v2.html#json-ld-parsing-and-formatting","text":"Each API response is represented by a class that extends KnoraResponseV2, which has a method toJsonLDDocument that specifies the target schema. It is currently up to each route to determine what the appropriate response schema should be. Some routes will support only one response schema. Others will allow the client to choose, and there will be one or more standard ways for the client to specify the desired response schema.\nA route calls RouteUtilV2.runJsonRoute, passing a request message and a response schema. When RouteUtilV2 gets the response message from the responder, it calls toJsonLDDocument on it, specifying that schema. The response message returns a JsonLDDocument, which is a simple data structure that is then converted to Java objects and passed to the JSON-LD Java library for formatting. In general, toJsonLDDocument is implemented in two stages: first the object converts itself to the target schema, and then the resulting object is converted to a JsonLDDocument.\nA route that receives JSON-LD requests should use JsonLDUtil.parseJsonLD to convert each request to a JsonLDDocument.","title":"JSON-LD Parsing and Formatting"},{"location":"/03-webapi/design/api-v2.html#operation-wrappers","text":"Whenever possible, the same data structures are used for input and output. Often more data is available in output than in input. For example, when a value is read from the triplestore, its IRI is available, but when it is being created, it does not yet have an IRI. In such cases, there is a class like ValueContentV2, which represents the data that is used both for input and for output. When a value is read, a ValueContentV2 is wrapped in a ReadValueV2, which additionally contains the value’s IRI. When a value is created, it is wrapped in a CreateValueV2, which has the resource IRI and the property IRI, but not the value IRI.\nA Read* wrapper can be wrapped in another Read* wrapper; for example, a ReadResourceV2 contains ReadValueV2 objects.\nEach *Content* class should extend KnoraContentV2 and thus have a toOntologySchema method or converting itself between internal and external schemas, in either direction.\nEach Read* wrapper class should have a method for converting itself to JSON-LD in a particular external schema. If the Read* wrapper is a KnoraResponseV2, this method is toJsonLDDocument.","title":"Operation Wrappers"},{"location":"/03-webapi/design/api-v2.html#smart-iris","text":"","title":"Smart IRIs"},{"location":"/03-webapi/design/api-v2.html#usage","text":"The SmartIri trait can be used to parse and validate IRIs, and in particular for converting Knora type IRIs between internal and external schemas. It validates each IRI it parses. To use it, import the following:\nimport org.knora.webapi.util.{SmartIri, StringFormatter}\nimport org.knora.webapi.util.IriConversions._\nEnsure that an implicit instance of StringFormatter is in scope:\nimplicit val stringFormatter: StringFormatter = StringFormatter.getGeneralInstance\nThen, if iriStr is a string representing an IRI, you can can convert it to a SmartIri like this:\nval iri: SmartIri = iriStr.toSmartIri\nIf the IRI came from a request, use this method to throw a specific exception if the IRI is invalid:\nval iri: SmartIri = iriStr.toSmartIriWithErr(\n    () => throw BadRequestException(s\"Invalid IRI: $iriStr\")\n)\nYou can then use methods such as SmartIri.isKnoraApiV2EntityIri and SmartIri.getProjectCode to obtain information about the IRI. To convert it to another schema, call SmartIri.toOntologySchema. Converting a non-Knora IRI returns the same IRI.\nIf the IRI represents a Knora internal value class such as knora-base:TextValue, converting it to the ApiV2Simple schema will return the corresponding simplified type, such as xsd:string. But this conversion is not performed in the other direction (external to internal), since this would require knowledge of the context in which the IRI is being used.\nThe performance penalty for using a SmartIri instead of a string is very small. Instances are automatically cached once they are constructed. Parsing and caching a SmartIri instance takes about 10-20 µs, and retrieving a cached SmartIri takes about 1 µs.\nThere is no advantage to using SmartIri for data IRIs, since they are not schema-specific (and are not cached). If a data IRI has been received from a client request, it is better just to validate it using StringFormatter.validateAndEscapeIri.","title":"Usage"},{"location":"/03-webapi/design/api-v2.html#implementation","text":"The smart IRI implementation, SmartIriImpl, is nested in the StringFormatter class, because it uses the Knora API server’s hostname, which isn’t available until the Akka ActorSystem has started. However, this means that the type of a SmartIriImpl instance is dependent on the instance of StringFormatter that constructed it. Therefore, instances of SmartIriImpl created by different instances of StringFormatter can’t be compared directly.\nThere are in fact two instances of StringFormatter:\none returned by StringFormatter.getGeneralInstance which is available after Akka has started and has the API server’s hostname (and can therefore provide SmartIri instances capable of parsing IRIs containing that hostname). This instance is used throughout the Knora API server. one returned by StringFormatter.getInstanceForConstantOntologies, which is available before Akka has started, and is used only by the hard-coded constant knora-api ontologies.\nThis is the reason for the existence of the SmartIri trait, which is a top-level definition and has its own equals and hashCode methods. Instances of SmartIri can thus be compared (e.g. to use them as unique keys in collections), regardless of which instance of StringFormatter created them.","title":"Implementation"},{"location":"/03-webapi/development/index.html","text":"","title":"Development"},{"location":"/03-webapi/development/index.html#development","text":"Overview Starting Fuseki 3 Starting GraphDB Build Process Setup IntelliJ for development of Knora Testing Docker Cheat Sheet Monitoring the Webapi Server","title":"Development"},{"location":"/03-webapi/development/overview.html","text":"","title":"Overview"},{"location":"/03-webapi/development/overview.html#overview","text":"Knora Github Repository Triplestore Sipi Build Sipi Docker Image Running Sipi\nDeveloping for the Knora API server requires a complete local installation of Knora. The different parts are:\nThe cloned Knora Github repository One of the supplied triplestores in the Knora Github repository (GraphDB-SE 8 or Fuseki 3). Sipi by building from source or using the docker image","title":"Overview"},{"location":"/03-webapi/development/overview.html#knora-github-repository","text":"$ git clone https://github.com/dhlab-basel/Knora","title":"Knora Github Repository"},{"location":"/03-webapi/development/overview.html#triplestore","text":"A number of triplestore implementations are available, including free software as well as proprietary options. The Knora API server is designed to work with any standards-compliant triplestore. It is primarily tested with Ontotext GraphDB, a high-performance, proprietary triplestore. We recommend GraphDB Standard Edition, but GraphDB Free (which is proprietary but available free of charge) also works.\nKnora includes support for Apache Jena, which is free software, but use of Jena is deprecated, and support for it will probably be removed in the future.\nBuilt-in support and configuration for other triplestores is planned.\nSee the chapters on Starting GraphDB and Starting Fuseki for more details.","title":"Triplestore"},{"location":"/03-webapi/development/overview.html#sipi","text":"","title":"Sipi"},{"location":"/03-webapi/development/overview.html#build-sipi-docker-image","text":"The Sipi docker image needs to be build by hand, as it requires the Kakadu distribution.\nTo build the image, and push it to the docker hub, follow the following steps:\n$ git clone https://github.com/dhlab-basel/docker-sipi\n(copy the Kakadu distribution ``v7_8-01382N.zip`` to the ``docker-sipi`` directory)\n$ docker build -t dhlabbasel/sipi\n$ docker run --name sipi --rm -it -p 1024:1024 dhlabbasel/sipi\n(Ctrl-c out of terminal will stop and delete container)\n$ docker push dhlabbasel/sipi\nPushing the image to the docker hub requires prior authentication with $ docker login. The user needs to be registered on hub.docker.com. Also, the user needs to be allowed to push to the dblabbasel organisation.","title":"Build Sipi Docker Image"},{"location":"/03-webapi/development/overview.html#running-sipi","text":"To use the docker image stored locally or on the docker hub repository type:\n$ docker run --name sipi -d -p 1024:1024 dhlabbasel/sipi\nThis will create and start a docker container with the dhlabbasel/sipi image in the background. The default behaviour is to start Sipi by calling the following command:\n$ /sipi/local/bin/sipi -config /sipi/config/sipi.knora-test-config.lua\nTo override this default behaviour, start the container by supplying another config file:\n$ docker run --name sipi \\\n             -d \\\n             -p 1024:1024 \\\n             dhlabbasel/sipi \\\n             /sipi/local/bin/sipi -config /sipi/config/sipi.config.lua\nYou can also mount a directory (the local directory in this example), and use a config file that is outside of the docker container:\n$ docker run --name sipi \\\n             -d \\\n             -p 1024:1024 \\\n             -v $PWD:/localdir \\\n             dhlabbasel/sipi \\\n             /sipi/local/bin/sipi -config /localdir/sipi.knora-test-config.lua","title":"Running Sipi"},{"location":"/03-webapi/development/fuseki.html","text":"","title":"Starting Fuseki 3"},{"location":"/03-webapi/development/fuseki.html#starting-fuseki-3","text":"","title":"Starting Fuseki 3"},{"location":"/03-webapi/development/fuseki.html#locally","text":"Inside the Knora API server git repository, there is a folder called triplestores/fuseki containing a script named fuseki-server. All needed configuration files are in place. To start Fuseki 3, just run this script:\n$ ./fuseki-server","title":"Locally"},{"location":"/03-webapi/development/fuseki.html#inside-docker","text":"We can use the dhlabbasel:fuseki docker image from docker hub:\n$ docker run --rm -it -p 3030:3030 dhlabbasel/fuseki","title":"Inside Docker"},{"location":"/03-webapi/development/graphdb.html","text":"","title":"Starting GraphDB"},{"location":"/03-webapi/development/graphdb.html#starting-graphdb","text":"","title":"Starting GraphDB"},{"location":"/03-webapi/development/graphdb.html#graphdb-se","text":"Inside the Knora API server git repository, there is a folder called /triplestores/graphdb-se containing the latest supported version of the GraphDB-SE distribution archive.","title":"GraphDB SE"},{"location":"/03-webapi/development/graphdb.html#running-locally","text":"Unzip graphdb-se-x.x.x-dist.zip to a place of your choosing and run the following:\n$ cd /to/unziped/location\n$ ./bin/graphdb -Dgraphdb.license.file=/path/to/GRAPHDB_SE.license","title":"Running Locally"},{"location":"/03-webapi/development/graphdb.html#running-inside-docker","text":"","title":"Running inside Docker"},{"location":"/03-webapi/development/graphdb.html#important-steps","text":"To be able to successfully run GraphDB inside docker two important steps need to be done beforhand:\nInstall Docker from http://docker.com. Copy the GraphDB-SE license file into a folder of you choosing and name it GRAPHDB_SE.license. We will mount this folder into the docker container, so that the license can be used by GraphDB running inside the container.","title":"Important Steps"},{"location":"/03-webapi/development/graphdb.html#usage","text":"$ docker run --rm -it -v /path/to/license/folder:/external -p 7200:7200 dhlabbasel/graphdb\n--rm removes the container as soon as you stop it -p forwards the exposed port to your host (or if you use boot2docker to this IP) -it allows interactive mode, so you see if something gets deployed\nAfter the GraphDB inside the docker container has started, you can find the GraphDB workbench here: http://localhost:7200\nAbove, we create and start a transient container (--rm flag). To create a container that we can stop and start again at a later time, follow the following steps:\n$ docker run --name graphdb -d -t -v /path/to/license/folder:/external -p 7200:7200 dhlabbasel/graphdb\n\n(to see the console output, attach to the container; to detach press Ctrl-c)\n$ docker attach graphdb\n\n(to stop the container)\n$ docker stop graphdb\n\n(to start the container again)\n$ docker start graphdb\n\n(to remove the container; needs to be stopped)\n$ docker rm graphdb\n--name give the container a name -d run container in background and print container ID -t allocate a pseudo TTY, so you see the console output -p forwards the exposed port to your host","title":"Usage"},{"location":"/03-webapi/development/graphdb.html#graphdb-free","text":"You can run GraphDB Free locally as described for GraphDB SE above, or you can use Knora’s pre-built GraphDB Free Docker image:\n$ docker run --rm -p 7200:7200 dhlabbasel/graphdb-free","title":"GraphDB Free"},{"location":"/03-webapi/development/build-process.html","text":"","title":"Build Process"},{"location":"/03-webapi/development/build-process.html#build-process","text":"Building and Running Using Fuseki Using GraphDB Running the automated tests Running Tests with Fuseki Running Tests with GraphDB Load Testing on Mac OS X Continuous Integration SBT Build Configuration Webapi Server Startup-Flags loadDemoData - Flag allowReloadOverHTTP - Flag\nTODO: complete this file.\nSBT Using GraphDB for development and how to initialize the ‘knora-test-unit’ repository Using Fuseki for development","title":"Build Process"},{"location":"/03-webapi/development/build-process.html#building-and-running","text":"","title":"Building and Running"},{"location":"/03-webapi/development/build-process.html#using-fuseki","text":"Start the provided Fuseki triplestore:\n$ cd KNORA_PROJECT_DIRECTORY/triplestores/fuseki\n$ ./fuseki-server\nThen in another terminal, load some test data into the triplestore:\n$ cd KNORA_PROJECT_DIRECTORY/webapi/scripts\n$ ./fuseki-load-test-data.sh\nThen go back to the webapi root directory and use SBT to start the API server:\n$ cd KNORA_PROJECT_DIRECTORY/webapi\n$ sbt\n> compile\n> re-start\nTo shut down the Knora API server:\n> re-stop","title":"Using Fuseki"},{"location":"/03-webapi/development/build-process.html#using-graphdb","text":"The archive with the newest supported version of the GraphDB SE triplestore is provided under triplestores/graphdb-se. Please keep in mind that GraphDB-SE must be licensed separately by the user, and that no license file is provided in the repository. GraphDB SE will not run without a license file.\nUnzip graphdb-se-x.x.x-dist.zip to a place of your choosing and run the following, to start graphdb:\n$ cd /to/unziped/location\n$ ./bin/graphdb -Dgraphdb.license.file=/path/to/GRAPHDB_SE.license\nAfter the GraphDB inside the docker container has started, you can find the GraphDB workbench here: http://localhost:7200\nThen in another terminal, load some test data into the triplestore:\n$ cd KNORA_PROJECT_DIRECTORY/webapi/scripts\n$ ./graphdb-se-local-init-knora-test.sh\nThen go back to the webapi root directory and use SBT to start the API server:\n$ cd KNORA_PROJECT_DIRECTORY/webapi\n$ sbt\n> compile\n> re-start\nTo shut down the Knora API server:\n> re-stop","title":"Using GraphDB"},{"location":"/03-webapi/development/build-process.html#running-the-automated-tests","text":"","title":"Running the automated tests"},{"location":"/03-webapi/development/build-process.html#running-tests-with-fuseki","text":"Make sure you’ve started Fuseki as shown above. Then at the SBT prompt:\n> fuseki:test","title":"Running Tests with Fuseki"},{"location":"/03-webapi/development/build-process.html#running-tests-with-graphdb","text":"Make sure GraphDB is running (as described earlier).\nThen in another terminal, initialise the repository used for automated testing:\n$ cd KNORA_PROJECT_DIRECTORY/webapi/scripts\n$ ./graphdb-se-local-init-knora-test-unit.sh\nRun the automated tests from sbt:\n> graphdb:test","title":"Running Tests with GraphDB"},{"location":"/03-webapi/development/build-process.html#load-testing-on-mac-os-x","text":"To test the Knora API server with many concurrent connections on Mac OS X, you will need to adjust some kernel parameters to allow more open connections, to recycle ephemeral ports more quickly, and to use a wider range of ephemeral port numbers. The script webapi/scripts/macOS-kernel-test-config.sh will do this.","title":"Load Testing on Mac OS X"},{"location":"/03-webapi/development/build-process.html#continuous-integration","text":"For continuous integration testing, we use Travis-CI. Every commit pushed to the git repository or every pull request, triggers the build. Additionaly, in Github there is a litle checkmark beside every commit, signaling the status of the build (successful, unsucessful, ongoing).\nThe build that is executed on Travis-CI is defined in .travis.yml situated in the root folder of the project, and looks like this:\ndist: trusty\nsudo: required\n\naddons:\n  chrome: stable\n\ngit:\n  depth: 1\n\nlanguage: scala\n\nscala:\n  - 2.12.1\n\njdk:\n  - oraclejdk8\n\nservices:\n  - docker\n\nenv:\n  global:\n    - WEBAPI_REPO=dhlabbasel/webapi\n    - SALSAH1_REPO=dhlabbasel/salsah1\n    - SALSAH2_REPO=dhlabbasel/salsah2\n    - SIPI_REPO=dhlabbasel/sipi\n    - DOCKERHOST=$(ip route get 8.8.8.8 | awk '{print $NF; exit}')\n    - CHROME_BIN=google-chrome-stable\n    - GDB_HEAP_SIZE=\"2G\"\n    - TAG=${TRAVIS_BRANCH//\\//-}\n    - GRAPHDB_VERSION=\"8.5.0-se\"\n\ncache:\n  directories:\n    - $HOME/.ivy2\n\n\nbefore_install:\n  - openssl aes-256-cbc -K $encrypted_6254b38dc8d5_key -iv $encrypted_6254b38dc8d5_iv -in $TRAVIS_BUILD_DIR/private/graphdb.license.enc -out $TRAVIS_BUILD_DIR/private/graphdb.license -d\n  - sudo apt-get -qq update\n  - sudo apt-get install -y expect\n\nstages:\n  - test\n  - name: publish # generally, only publish if we are on 'develop' or tagged\n    if: branch = develop OR tag IS present\n\njobs:\n  include:\n    # unit and e2e tests\n    - stage: test\n      script:\n        # prepare needed graphdb-se files\n        - mkdir -p $TRAVIS_BUILD_DIR/data/conf\n        - cp $TRAVIS_BUILD_DIR/private/graphdb.license $TRAVIS_BUILD_DIR/data/conf/graphdb.license\n        - mkdir -p $TRAVIS_BUILD_DIR/graphdb\n        - cp $TRAVIS_BUILD_DIR/webapi/scripts/KnoraRules.pie $TRAVIS_BUILD_DIR/graphdb\n        # start and initialize graphdb-se\n        - docker run -d -p 127.0.0.1:7200:7200 -v $TRAVIS_BUILD_DIR/data:/opt/graphdb/home -v $TRAVIS_BUILD_DIR/graphdb:/graphdb -e GDB_HEAP_SIZE=$GDB_HEAP_SIZE ontotext/graphdb:$GRAPHDB_VERSION\n        - sleep 15\n        - cd $TRAVIS_BUILD_DIR/webapi/scripts && ./graphdb-se-docker-init-knora-test-unit.sh\n        # start the built-in webapi server tests\n        - cd $TRAVIS_BUILD_DIR/webapi/ && sbt graphdb:test\n        # test sbt stage\n        - cd $TRAVIS_BUILD_DIR/webapi/ && sbt stage\n        # only uncomment if docker image is needed for this branch. remove before merging into develop\n        # - docker login -u $DOCKER_USER -p $DOCKER_PASS\n        # - docker build $TRAVIS_BUILD_DIR/webapi/ -t $WEBAPI_REPO:$TAG\n        # - docker push $WEBAPI_REPO\n    # integration tests\n    - stage: test\n      script:\n        # prepare needed graphdb-se files\n        - mkdir -p $TRAVIS_BUILD_DIR/data/conf\n        - cp $TRAVIS_BUILD_DIR/private/graphdb.license $TRAVIS_BUILD_DIR/data/conf/graphdb.license\n        - mkdir -p $TRAVIS_BUILD_DIR/graphdb\n        - cp $TRAVIS_BUILD_DIR/webapi/scripts/KnoraRules.pie $TRAVIS_BUILD_DIR/graphdb\n        # start and initialize graphdb-se\n        - docker run -d -p 127.0.0.1:7200:7200 -v $TRAVIS_BUILD_DIR/data:/opt/graphdb/home -v $TRAVIS_BUILD_DIR/graphdb:/graphdb -e GDB_HEAP_SIZE=$GDB_HEAP_SIZE ontotext/graphdb:$GRAPHDB_VERSION\n        - sleep 15\n        - cd $TRAVIS_BUILD_DIR/webapi/scripts && ./graphdb-se-docker-init-knora-test-unit.sh\n        # start the sipi container (with production config)\n        - docker run -d --add-host webapihost:$DOCKERHOST -v /tmp:/tmp -v $HOME:$HOME -p 1024:1024 $SIPI_REPO:develop\n        # start the integration tests\n        - cd $TRAVIS_BUILD_DIR/webapi/ && sbt it:test\n    # testing docs generation\n    - stage: test\n      script:\n        # install the necessary packages\n        - sudo apt-get install -y graphviz software-properties-common\n        - sudo apt-add-repository -y ppa:rael-gc/rvm\n        - sudo apt-get update\n        - sudo apt-get install rvm\n        - rvm install ruby 2.5.1\n        - rvm use 2.5.1 --default\n        - ruby -v\n        # install bundler\n        - gem install bundler\n        # install jekyll\n        - gem install jekyll -v 3.8.1\n        # install typedoc\n        - npm install --global typedoc\n        # install jekyll dependencies\n        - cd $TRAVIS_BUILD_DIR/docs/src/jekyll && bundle install\n        # compile and build all docs (paradox, typescript, jekyll)\n        - cd $TRAVIS_BUILD_DIR/docs && sbt makeSite\n    # Salsah browser tests\n    #- stage: test\n    #  script:\n    #    # prepare needed graphdb-se files\n    #    - mkdir -p $TRAVIS_BUILD_DIR/data/conf\n    #    - cp $TRAVIS_BUILD_DIR/private/graphdb.license $TRAVIS_BUILD_DIR/data/conf/graphdb.license\n    #    - mkdir -p $TRAVIS_BUILD_DIR/graphdb\n    #    - cp $TRAVIS_BUILD_DIR/webapi/scripts/KnoraRules.pie $TRAVIS_BUILD_DIR/graphdb\n    #    # start and initialize graphdb-se\n    #    - docker run -d -p 127.0.0.1:7200:7200 -v $TRAVIS_BUILD_DIR/data:/opt/graphdb/home -v $TRAVIS_BUILD_DIR/graphdb:/graphdb -e GDB_HEAP_SIZE=$GDB_HEAP_SIZE ontotext/graphdb:$GRAPHDB_VERSION\n    #    - sleep 15\n    #    - cd $TRAVIS_BUILD_DIR/webapi/scripts && ./graphdb-se-docker-init-knora-test.sh\n    #    # start the sipi container (with test config)\n    #    - docker run -d --add-host webapihost:$DOCKERHOST -v /tmp:/tmp -v $HOME:$HOME -p 1024:1024 $SIPI_REPO:develop /sipi/local/bin/sipi --config=/sipi/config/sipi.knora-test-docker-config.lua\n    #    # start the webapi and salsah1 server\n    #    - cd $TRAVIS_BUILD_DIR/webapi/ && sbt \"run allowReloadOverHTTP\" &\n    #    - cd $TRAVIS_BUILD_DIR/salsah1/ && sbt run &\n    #    # wait for the webapi server to start before we proceed with running the salsah tests\n    #    - until netstat -an 2>/dev/null | grep '3333.*LISTEN'; do true; done\n    #    # unzip chromedriver\n    #    - cd $TRAVIS_BUILD_DIR/salsah1/lib/chromedriver/ && unzip chromedriver_linux64.zip\n    #    # start built-in salsah1 browser tests\n    #    - cd $TRAVIS_BUILD_DIR/salsah1/ && sbt headless:test\n    - stage: publish\n      script:\n        # login into docker hub, build image, and push but only when on the \"develop\" branch or tagged\n        # when on 'develop' then $TRAVIS_BRANCH = develop\n        # when on 'tag' then $TRAVIS_BRANCH = tag, e.g., v1.2.0\n        - docker login -u $DOCKER_USER -p $DOCKER_PASS\n        # webapi\n        - docker build $TRAVIS_BUILD_DIR/webapi/ -t $WEBAPI_REPO:$TRAVIS_BRANCH\n        - docker tag $WEBAPI_REPO:$TRAVIS_BRANCH $WEBAPI_REPO:latest\n        - docker push $WEBAPI_REPO\n        # salsah1\n        - docker build $TRAVIS_BUILD_DIR/salsah1/ -t $SALSAH1_REPO:$TRAVIS_BRANCH\n        - docker tag $SALSAH1_REPO:$TRAVIS_BRANCH $SALSAH1_REPO:latest\n        - docker push $SALSAH1_REPO\n        # sipi: get the develop sipi and tag it as 'develop-knora' so we know that this version is tested (only on the develop branch)\n        - docker pull $SIPI_REPO:develop\n        - docker tag $SIPI_REPO:develop $SIPI_REPO:knora-$TRAVIS_BRANCH\n        - docker push $SIPI_REPO\n\nnotifications:\n  slack:\n    secure: gaazomUbAB4q7bH2XOiZXqHvU2gd/X/jIRLAJW9vjcRbY6o48eiEdNXF2umraHG0q+5UUEJ5dfvxiPtC4PiUq8uD6J+R0fEWrWznYoIeEWEXjKxRxWplrWJ9Ke+PJb3wCV6cXBGMfxDpvYQbVjsy7n0aQmjNs4Drz+llqL5SilTdswTylwvUdufad0QaovXklL+p0w9vRHRKzQkYKa9phL10VcJa8TPI74tuFcTHnK6TcMNW6p0vzAaF6JVgzoRPzUgXnEPCw4pI8zqOF1ghPpQByNXKiYofPWt1yTFgb60LQarDEiHXunXAA/sf2gx616pWLVjDFGziXVzhiGUDUjM5I1p7hPyA2rTB63AAZustFcGeD+jbHNHIFhcvvCHVHjJfp8M7LrUR+MBqz5mJNi/9KgxyZ8I9Df28TxmKxGFaGW8t4PZdA75/49Hos0TqtIp5m+eo8mTksUJogEJJokRZUKraMBhC0cNCry0kp+EQ06F4usLoDyZTUar4OSuNSiymf+zwz6jZo8dF/cluRYellwewE9NJiNWGN4DiBhk2vGJ7OtWMDPkl1tqkG8npoqbT4s38esjxfa/XcworGfeqE+9mzugVzkIKIX2lB6QxZp0AKQVOiy7JwwdtcjVMLvceiNPEWfe8fhLMX02oqYz2uoibRmHMxKPa5CpmUIg=\nIt basically means:\nuse the virtual machine based environment (line 1) checkout git with a shorter history (lines 2-3) add scala libraries (lines 4-6) add oracle jdk version 8 (lines 7-8) cache some directories between builds to make it faster (line 9-11) start fuseki and afterwards start all tests (lines 12-14) send notification to our slack channel (lines 15-17)","title":"Continuous Integration"},{"location":"/03-webapi/development/build-process.html#sbt-build-configuration","text":"import sbt._\nimport NativePackagerHelper._\nimport sbt.io.IO\nimport sbtassembly.MergeStrategy\nimport sbtassembly.MergeStrategy._\n\nconnectInput in run := true\n\n// Bring the sbt-aspectj settings into this build\n//aspectjSettings\n\nlazy val webapi = (project in file(\".\")).\n        configs(\n            FusekiTest,\n            FusekiIntegrationTest,\n            GraphDBTest,\n            EmbeddedJenaTDBTest,\n            IntegrationTest\n        ).\n        settings(webApiCommonSettings:  _*).\n        settings(inConfig(Test)(\n            Defaults.testTasks ++ baseAssemblySettings\n        ): _*).\n        settings(inConfig(Gatling)( // add our settings to the gatling config\n            Defaults.testTasks ++ Seq(\n                fork := true,\n                javaOptions ++= javaTestOptions\n            )\n        ): _*).\n        settings(inConfig(GatlingIt)( // add our settings to the gatling it config\n            Defaults.testTasks ++ Seq(\n                fork := true,\n                javaOptions ++= javaTestOptions\n            )\n        ): _*).\n        settings(inConfig(FusekiTest)(\n            Defaults.testTasks ++ Seq(\n                fork := true,\n                javaOptions ++= javaFusekiTestOptions,\n                testOptions += Tests.Argument(\"-oDF\") // show full stack traces and test case durations\n            )\n        ): _*).\n        settings(inConfig(FusekiIntegrationTest)(\n            Defaults.testTasks ++ Seq(\n                fork := true,\n                javaOptions ++= javaFusekiIntegrationTestOptions,\n                testOptions += Tests.Argument(\"-oDF\") // show full stack traces and test case durations\n            )\n        ): _*).\n        settings(inConfig(GraphDBTest)(\n            Defaults.testTasks ++ Seq(\n                fork := true,\n                javaOptions ++= javaGraphDBTestOptions,\n                testOptions += Tests.Argument(\"-oDF\") // show full stack traces and test case durations\n            )\n        ): _*).\n        settings(inConfig(EmbeddedJenaTDBTest)(\n            Defaults.testTasks ++ Seq(\n                fork := true,\n                javaOptions ++= javaEmbeddedJenaTDBTestOptions,\n                testOptions += Tests.Argument(\"-oDF\") // show full stack traces and test case durations\n            )\n        ): _*).\n        settings(inConfig(IntegrationTest)(\n            Defaults.itSettings ++ Seq(\n                fork := true,\n                javaOptions ++= javaIntegrationTestOptions,\n                testOptions += Tests.Argument(\"-oDF\") // show full stack traces and test case durations\n            ) ++ baseAssemblySettings\n        ): _*).\n        settings(\n            libraryDependencies ++= webApiLibs,\n            scalacOptions ++= Seq(\"-feature\", \"-unchecked\", \"-deprecation\", \"-Yresolve-term-conflict:package\"),\n            logLevel := Level.Info,\n            fork in run := true,\n            javaOptions in run ++= javaRunOptions,\n            javaOptions in reStart ++= javaRunOptions,\n            javaOptions in Test ++= javaTestOptions,\n            javaOptions in reStart ++= resolvedJavaAgents.value map { resolved =>\n                \"-javaagent:\" + resolved.artifact.absolutePath + resolved.agent.arguments\n            },// allows sbt-javaagent to work with sbt-revolver\n            javaAgents += library.aspectJWeaver,\n            mainClass in (Compile, run) := Some(\"org.knora.webapi.Main\"),\n            fork in Test := true,\n            parallelExecution in Test := false,\n            // enable publishing the jar produced by `sbt test:package` and `sbt it:package`\n            publishArtifact in (Test, packageBin) := true,\n            publishArtifact in (IntegrationTest, packageBin) := true\n        ).\n        settings( // enable deployment staging with `sbt stage`. uses fat jar assembly.\n            // we specify the name for our fat jars (main, test, it)\n            assemblyJarName in assembly := s\"assembly-${name.value}-main-${version.value}.jar\",\n            assemblyJarName in (Test, assembly) := s\"assembly-${name.value}-test-${version.value}.jar\",\n            assemblyJarName in (IntegrationTest, assembly) := s\"assembly-${name.value}-it-${version.value}.jar\",\n            // disable running of tests before fat jar assembly!\n            test in assembly := {},\n            test in (Test, assembly) := {},\n            test in (IntegrationTest, assembly) := {},\n            // need to use our custom merge strategy because of aop.xml (AspectJ)\n            assemblyMergeStrategy in assembly := customMergeStrategy,\n            // Skip packageDoc task on stage\n            mappings in (Compile, packageDoc) := Seq(),\n            mappings in Universal := {\n                // removes all jar mappings in universal and appends the fat jar\n                // universalMappings: Seq[(File,String)]\n                val universalMappings = (mappings in Universal).value\n                val fatJar = (assembly in Compile).value\n                // removing means filtering\n                val filtered = universalMappings filter {\n                    case (file, name) =>  ! name.endsWith(\".jar\")\n                }\n                // add the fat jar\n                filtered :+ (fatJar -> (\"lib/\" + fatJar.getName))\n            },\n            mappings in Universal ++= {\n                // copy the scripts folder\n                directory(\"scripts\") ++\n                // copy the configuration files to config directory\n                contentOf(\"configs\").toMap.mapValues(\"config/\" + _) ++\n                // copy configuration files to config directory\n                contentOf(\"src/main/resources\").toMap.mapValues(\"config/\" + _) ++\n                // copy the aspectj weaver jar\n                contentOf(\"vendor\").toMap.mapValues(\"aspectjweaver/\" + _)\n            },\n            // the bash scripts classpath only needs the fat jar\n            scriptClasspath := Seq( (assemblyJarName in assembly).value ),\n            // add 'config' directory first in the classpath of the start script,\n            scriptClasspath := Seq(\"../config/\") ++ scriptClasspath.value,\n            // add license\n            licenses := Seq((\"GNU AGPL\", url(\"https://www.gnu.org/licenses/agpl-3.0\"))),\n            // need this here, so that the Manifest inside the jars has the correct main class set.\n            mainClass in Compile := Some(\"org.knora.webapi.Main\"),\n            mainClass in Test := Some(\"org.scalatest.tools.Runner\"),\n            mainClass in IntegrationTest := Some(\"org.scalatest.tools.Runner\")\n        ).\n        enablePlugins(SbtTwirl). // Enable the sbt-twirl plugin\n        enablePlugins(JavaAppPackaging). // Enable the sbt-native-packager plugin\n        enablePlugins(GatlingPlugin). // load testing\n        enablePlugins(JavaAgent). // Adds AspectJ Weaver configuration\n        enablePlugins(RevolverPlugin)\n\nlazy val webApiCommonSettings = Seq(\n    organization := \"org.knora\",\n    name := \"webapi\",\n    version := \"1.4.0\",\n    scalaVersion := \"2.12.4\"\n)\n\nlazy val webApiLibs = Seq(\n    library.aspectJWeaver,\n    library.akkaActor,\n    library.akkaAgent,\n    library.akkaHttp,\n    library.akkaHttpCirce,\n    library.akkaHttpCors,\n    library.akkaHttpSprayJson,\n    library.akkaHttpJacksonJava,\n    library.akkaHttpTestkit,\n    library.akkaHttpXml,\n    library.akkaSlf4j,\n    library.akkaStream,\n    library.akkaStreamTestkit,\n    library.akkaTestkit,\n    library.bcprov,\n    library.commonsBeanUtil,\n    library.commonsIo,\n    library.commonsLang3,\n    library.commonsValidator,\n    library.diff,\n    library.ehcache,\n    library.gatlingHighcharts,\n    library.gatlingTestFramework,\n    library.gwtServlet,\n    library.jacksonScala,\n    library.jsonldJava,\n    library.jodd,\n    library.jodaTime,\n    library.jodaConvert,\n    library.jenaLibs,\n    library.jenaText,\n    library.jwt,\n    library.kamonCore,\n    library.kamonAkka,\n    library.kamonPrometheus,\n    library.kamonZipkin,\n    library.kamonJaeger,\n    library.logbackClassic,\n    library.rdf4jRioTurtle,\n    library.rdf4jQueryParserSparql,\n    library.sayonHE,\n    library.scalaArm,\n    library.scalaJava8Compat,\n    library.scalaLogging,\n    library.scalaTest,\n    library.scalaXml,\n    library.scallop,\n    library.springSecurityCore,\n    library.swaggerAkkaHttp,\n    library.xmlunitCore\n)\n\nlazy val library =\n    new {\n        object Version {\n            val akkaBase = \"2.5.11\"\n            val akkaHttp = \"10.1.0\"\n            val jena = \"3.4.0\"\n        }\n\n        // akka\n        val akkaActor              = \"com.typesafe.akka\"            %% \"akka-actor\"               % Version.akkaBase\n        val akkaAgent              = \"com.typesafe.akka\"            %% \"akka-agent\"               % Version.akkaBase\n        val akkaStream             = \"com.typesafe.akka\"            %% \"akka-stream\"              % Version.akkaBase\n        val akkaSlf4j              = \"com.typesafe.akka\"            %% \"akka-slf4j\"               % Version.akkaBase\n        val akkaTestkit            = \"com.typesafe.akka\"            %% \"akka-testkit\"             % Version.akkaBase    % \"test, fuseki, graphdb, tdb, it, fuseki-it\"\n        val akkaStreamTestkit      = \"com.typesafe.akka\"            %% \"akka-stream-testkit\"      % Version.akkaBase    % \"test, fuseki, graphdb, tdb, it, fuseki-it\"\n\n        // akka http\n        val akkaHttp               = \"com.typesafe.akka\"            %% \"akka-http\"                % Version.akkaHttp\n        val akkaHttpXml            = \"com.typesafe.akka\"            %% \"akka-http-xml\"            % Version.akkaHttp\n        val akkaHttpSprayJson      = \"com.typesafe.akka\"            %% \"akka-http-spray-json\"     % Version.akkaHttp\n        val akkaHttpJacksonJava    = \"com.typesafe.akka\"            %% \"akka-http-jackson\"        % Version.akkaHttp\n        val akkaHttpTestkit        = \"com.typesafe.akka\"            %% \"akka-http-testkit\"        % Version.akkaHttp    % \"test, fuseki, graphdb, tdb, it, fuseki-it\"\n\n        // testing\n        val scalaTest              = \"org.scalatest\"                %% \"scalatest\"                % \"3.0.4\"             % \"test, fuseki, graphdb, tdb, it, fuseki-it\"\n        val gatlingHighcharts      = \"io.gatling.highcharts\"         % \"gatling-charts-highcharts\"% \"2.3.1\"             % \"test, fuseki, graphdb, tdb, it, fuseki-it\"\n        val gatlingTestFramework   = \"io.gatling\"                    % \"gatling-test-framework\"   % \"2.3.1\"             % \"test, fuseki, graphdb, tdb, it, fuseki-it\"\n\n        //CORS support\n        val akkaHttpCors           = \"ch.megard\"                    %% \"akka-http-cors\"           % \"0.3.0\"\n\n        // jena\n        val jenaLibs               = \"org.apache.jena\"               % \"apache-jena-libs\"         % Version.jena exclude(\"org.slf4j\", \"slf4j-log4j12\") exclude(\"commons-codec\", \"commons-codec\")\n        val jenaText               = \"org.apache.jena\"               % \"jena-text\"                % Version.jena exclude(\"org.slf4j\", \"slf4j-log4j12\") exclude(\"commons-codec\", \"commons-codec\")\n\n        // logging\n        val commonsLogging         = \"commons-logging\"               % \"commons-logging\"          % \"1.2\"\n        val scalaLogging           = \"com.typesafe.scala-logging\"   %% \"scala-logging\"            % \"3.8.0\"\n        val logbackClassic         = \"ch.qos.logback\"                % \"logback-classic\"          % \"1.2.3\"\n\n        // input validation\n        val commonsValidator       = \"commons-validator\"             % \"commons-validator\"        % \"1.6\" exclude(\"commons-logging\", \"commons-logging\")\n\n        // authentication\n        val bcprov                 = \"org.bouncycastle\"              % \"bcprov-jdk15on\"           % \"1.59\"\n        val springSecurityCore     = \"org.springframework.security\"  % \"spring-security-core\"     % \"4.2.5.RELEASE\" exclude(\"commons-logging\", \"commons-logging\") exclude(\"org.springframework\", \"spring-aop\")\n        val jwt                    = \"io.igl\"                       %% \"jwt\"                      % \"1.2.2\" exclude(\"commons-codec\", \"commons-codec\")\n\n        // caching\n        val ehcache                = \"net.sf.ehcache\"                % \"ehcache\"                  % \"2.10.0\"\n\n        // monitoring\n        val kamonCore              = \"io.kamon\"                     %% \"kamon-core\"               % \"1.1.0\"\n        val kamonAkka              = \"io.kamon\"                     %% \"kamon-akka-2.5\"           % \"1.0.0\"\n        val kamonPrometheus        = \"io.kamon\"                     %% \"kamon-prometheus\"         % \"1.0.0\"\n        val kamonZipkin            = \"io.kamon\"                     %% \"kamon-zipkin\"             % \"1.0.0\"\n        val kamonJaeger            = \"io.kamon\"                     %% \"kamon-jaeger\"             % \"1.0.1\"\n        val aspectJWeaver          = \"org.aspectj\"                   % \"aspectjweaver\"            % \"1.8.13\"\n\n        // other\n        //\"javax.transaction\" % \"transaction-api\" % \"1.1-rev-1\",\n        val commonsLang3           = \"org.apache.commons\"            % \"commons-lang3\"            % \"3.7\"\n        val commonsIo              = \"commons-io\"                    % \"commons-io\"               % \"2.6\"\n        val commonsBeanUtil        = \"commons-beanutils\"             % \"commons-beanutils\"        % \"1.9.3\" exclude(\"commons-logging\", \"commons-logging\") // not used by us, but need newest version to prevent this problem: http://stackoverflow.com/questions/14402745/duplicate-classes-in-commons-collections-and-commons-beanutils\n        val jodd                   = \"org.jodd\"                      % \"jodd\"                     % \"3.2.6\"\n        val jodaTime               = \"joda-time\"                     % \"joda-time\"                % \"2.9.1\"\n        val jodaConvert            = \"org.joda\"                      % \"joda-convert\"             % \"1.8\"\n        val diff                   = \"com.sksamuel.diff\"             % \"diff\"                     % \"1.1.11\"\n        val xmlunitCore            = \"org.xmlunit\"                   % \"xmlunit-core\"             % \"2.1.1\"\n\n        // other\n        val rdf4jRioTurtle         = \"org.eclipse.rdf4j\"             % \"rdf4j-rio-turtle\"         % \"2.3.0\"\n        val rdf4jQueryParserSparql = \"org.eclipse.rdf4j\"             % \"rdf4j-queryparser-sparql\" % \"2.2.4\"\n        val scallop                = \"org.rogach\"                   %% \"scallop\"                  % \"2.0.5\"\n        val gwtServlet             = \"com.google.gwt\"                % \"gwt-servlet\"              % \"2.8.0\"\n        val sayonHE                = \"net.sf.saxon\"                  % \"Saxon-HE\"                 % \"9.7.0-14\"\n\n        val scalaXml               = \"org.scala-lang.modules\"       %% \"scala-xml\"                % \"1.1.0\"\n        val scalaArm               = \"com.jsuereth\"                  % \"scala-arm_2.12\"           % \"2.0\"\n        val scalaJava8Compat       = \"org.scala-lang.modules\"        % \"scala-java8-compat_2.12\"  % \"0.8.0\"\n\n        // provides akka jackson (json) support\n        val akkaHttpCirce          = \"de.heikoseeberger\"            %% \"akka-http-circe\"          % \"1.20.1\"\n        val jacksonScala           = \"com.fasterxml.jackson.module\" %% \"jackson-module-scala\"     % \"2.9.4\"\n\n        val jsonldJava             = \"com.github.jsonld-java\"        % \"jsonld-java\"              % \"0.12.0\"\n\n        // swagger (api documentation)\n        val swaggerAkkaHttp        = \"com.github.swagger-akka-http\" %% \"swagger-akka-http\"        % \"0.14.0\"\n    }\n\nlazy val javaRunOptions = Seq(\n    // \"-showversion\",\n    \"-Xms2G\",\n    \"-Xmx2G\"\n    // \"-verbose:gc\",\n    //\"-XX:+UseG1GC\",\n    //\"-XX:MaxGCPauseMillis=500\"\n)\n\nlazy val javaBaseTestOptions = Seq(\n    // \"-showversion\",\n    \"-Xms2G\",\n    \"-Xmx2G\"\n    // \"-verbose:gc\",\n    //\"-XX:+UseG1GC\",\n    //\"-XX:MaxGCPauseMillis=500\",\n    //\"-XX:MaxMetaspaceSize=4096m\"\n)\n\nlazy val javaTestOptions = Seq(\n    \"-Dconfig.resource=graphdb.conf\"\n) ++ javaBaseTestOptions\n\nlazy val FusekiTest = config(\"fuseki\") extend(Test)\nlazy val javaFusekiTestOptions = Seq(\n    \"-Dconfig.resource=fuseki.conf\"\n) ++ javaBaseTestOptions\n\nlazy val FusekiIntegrationTest = config(\"fuseki-it\") extend(IntegrationTest)\nlazy val javaFusekiIntegrationTestOptions = Seq(\n    \"-Dconfig.resource=fuseki.conf\"\n) ++ javaBaseTestOptions\n\nlazy val GraphDBTest = config(\"graphdb\") extend(Test)\nlazy val javaGraphDBTestOptions = Seq(\n    \"-Dconfig.resource=graphdb.conf\"\n) ++ javaBaseTestOptions\n\nlazy val EmbeddedJenaTDBTest = config(\"tdb\") extend(Test)\nlazy val javaEmbeddedJenaTDBTestOptions = Seq(\n    \"-Dconfig.resource=jenatdb.conf\"\n) ++ javaBaseTestOptions\n\n// The 'IntegrationTest' config does not need to be created here, as it is a built-in config!\n// The standard testing tasks are available, but must be prefixed with 'it:', e.g., 'it:test'\n// The test need to be stored in the 'it' (and not 'test') folder. The standard source hierarchy is used, e.g., 'src/it/scala'\nlazy val javaIntegrationTestOptions = Seq(\n    \"-Dconfig.resource=graphdb.conf\"\n) ++ javaBaseTestOptions\n\n\n// Create a new MergeStrategy for aop.xml files, as the aop.xml file is present in more than one package.\n// When we create a fat JAR (assembly task), then we need to resolve this conflict.\nval aopMerge: MergeStrategy = new MergeStrategy {\n    val name = \"aopMerge\"\n    import scala.xml._\n    import scala.xml.dtd._\n\n    def apply(tempDir: File, path: String, files: Seq[File]): Either[String, Seq[(File, String)]] = {\n        val dt = DocType(\"aspectj\", PublicID(\"-//AspectJ//DTD//EN\", \"http://www.eclipse.org/aspectj/dtd/aspectj.dtd\"), Nil)\n        val file = MergeStrategy.createMergeTarget(tempDir, path)\n        val xmls: Seq[Elem] = files.map(XML.loadFile)\n        val aspectsChildren: Seq[Node] = xmls.flatMap(_ \\\\ \"aspectj\" \\ \"aspects\" \\ \"_\")\n        val weaverChildren: Seq[Node] = xmls.flatMap(_ \\\\ \"aspectj\" \\ \"weaver\" \\ \"_\")\n        val options: String = xmls.map(x => (x \\\\ \"aspectj\" \\ \"weaver\" \\ \"@options\").text).mkString(\" \").trim\n        val weaverAttr = if (options.isEmpty) Null else new UnprefixedAttribute(\"options\", options, Null)\n        val aspects = new Elem(null, \"aspects\", Null, TopScope, false, aspectsChildren: _*)\n        val weaver = new Elem(null, \"weaver\", weaverAttr, TopScope, false, weaverChildren: _*)\n        val aspectj = new Elem(null, \"aspectj\", Null, TopScope, false, aspects, weaver)\n        XML.save(file.toString, aspectj, \"UTF-8\", xmlDecl = false, dt)\n        IO.append(file, IO.Newline.getBytes(IO.defaultCharset))\n        Right(Seq(file -> path))\n    }\n}\n\n// Use defaultMergeStrategy with a case for aop.xml\n// I like this better than the inline version mentioned in assembly's README\nval customMergeStrategy: String => MergeStrategy = {\n    case PathList(\"META-INF\", \"aop.xml\") =>\n        aopMerge\n    case s =>\n        defaultMergeStrategy(s)\n}","title":"SBT Build Configuration"},{"location":"/03-webapi/development/build-process.html#webapi-server-startup-flags","text":"The Webapi-Server can be started with a number of flags. These flags can be supplied either to the reStart or the run command in sbt, e.g.,:\n$ sbt\n> reStart flag\nor\n$ sbt\n> run flag","title":"Webapi Server Startup-Flags"},{"location":"/03-webapi/development/build-process.html#loaddemodata-flag","text":"When the webapi-server is started with the loadDemoData flag, then at startup, the data which is configured in application.conf under the app.triplestore.rdf-data key is loaded into the triplestore, and any data in the triplestore is removed beforehand.\nUsage:\n$ sbt\n> reStart loadDemoData","title":"loadDemoData - Flag"},{"location":"/03-webapi/development/build-process.html#allowreloadoverhttp-flag","text":"When the webapi.server is started with the allowReloadOverHTTP flag, then the v1/store/ResetTriplestoreContent route is activated. This route accepts a POST request, with a JSON payload consisting of the following example content:\n[\n  {\n    \"path\": \"../knora-ontologies/knora-base.ttl\",\n    \"name\": \"http://www.knora.org/ontology/knora-base\"\n  },\n  {\n    \"path\": \"../knora-ontologies/salsah-gui.ttl\",\n    \"name\": \"http://www.knora.org/ontology/salsah-gui\"\n  },\n  {\n    \"path\": \"_test_data/ontologies/incunabula-onto.ttl\",\n    \"name\": \"http://www.knora.org/ontology/0803/incunabula\"\n  },\n  {\n    \"path\": \"_test_data/all_data/incunabula-data.ttl\",\n    \"name\": \"http://www.knora.org/data/incunabula\"\n  }\n]\nThis content corresponds to the payload sent with the ResetTriplestoreContent message, defined inside the org.knora.webapi.messages.v1.store.triplestoremessages package. The path being the relative path to the ttl file which will be loaded into a named graph by the name of name.\nUsage:\n$ sbt\n> reStart allowReloadOverHTTP","title":"allowReloadOverHTTP - Flag"},{"location":"/03-webapi/development/intellij-config.html","text":"","title":"Setup IntelliJ for development of Knora"},{"location":"/03-webapi/development/intellij-config.html#setup-intellij-for-development-of-knora","text":"Create an IntelliJ Project for the Knora API Server Twirl Use IntelliJ IDEA’s Debugger with the Knora API Server Profile Knora Using VisualVM in IntelliJ","title":"Setup IntelliJ for development of Knora"},{"location":"/03-webapi/development/intellij-config.html#create-an-intellij-project-for-the-knora-api-server","text":"Download and install IntelliJ IDEA. Follow the installation procedure and install the Scala plugin\nImport the webapi directory in the Knora source tree: Import Project -> Choose the option module SBT\nmake sure that the tab size is set correctly to 4 spaces (so you can use automatic code reformatting): Preferences -> Code Style -> Scala:","title":"Create an IntelliJ Project for the Knora API Server"},{"location":"/03-webapi/development/intellij-config.html#twirl","text":"By default, Intellij excludes some folders like the twirl template files. To include them, go to Project Structure and remove target/scala-2.1*/twirl from excluded folders. Then Intellij will correctly resolve the references to the template files.","title":"Twirl"},{"location":"/03-webapi/development/intellij-config.html#use-intellij-ideas-debugger-with-the-knora-api-server","text":"Create an application configuration:\nFill in the configuration details:\nClick on the debugging symbol to start the application with a debugger attached\nClick on a line-number to add a breakpoint","title":"Use IntelliJ IDEA’s Debugger with the Knora API Server"},{"location":"/03-webapi/development/intellij-config.html#profile-knora-using-visualvm-in-intellij","text":"First, download and install VisualVM.\nThen, in IntelliJ, under Preferences -> Plugins, search for the VisualVM Launcher, click on “Search in repositories”, install the plugin, and restart IntelliJ. IntelliJ’s toolbar should now contain a button with a green triangle on an orange circle, with the tooltip “Run with VisualVM”:\nYou can use this button to run the class org.knora.webapi.Main and profile it in VisualVM. The first time you do this, IntelliJ will ask you for the path to the VisualVM executable. On macOS this is /Applications/VisualVM.app/Contents/MacOS/visualvm.\nWhen VisualVM starts, it will open a window like this:\nTo use the profiler, click on the “Sampler” tab, then on the “CPU” button:\nNow run some Knora API operations that you’re interested in profiling, preferably several times to allow the sampler to collect enough data. Then click on the “Snapshot” button:\nIn the snapshot, you’ll see a list of threads that were profiled:\nYou can then browse the call tree for each thread, looking for Knora method calls, to see the total time spent in each method:","title":"Profile Knora Using VisualVM in IntelliJ"},{"location":"/03-webapi/development/testing.html","text":"","title":"Testing"},{"location":"/03-webapi/development/testing.html#testing","text":"Prerequisite: Before running any tests, a supported triplestore needs to be started and initialized through a script inside the “scripts” folder. For example, when using “GraphDB Free”, the nedded script is “graphdb-free-init-knora-test-unit.sh”. Please note the occurrence of “test-unit” in the name of the script.","title":"Testing"},{"location":"/03-webapi/development/testing.html#how-to-write-unit-tests","text":"1) Inside a test, at the beginning, add the following (change the paths to the test data as needed):\nval rdfDataObjects = List (\n       RdfDataObject(path = \"_test_data/responders.v1.ValuesResponderV1Spec/incunabula-data.ttl\", name = \"http://www.knora.org/data/incunabula\")\n)\n\n\"Load test data\" in {\n    storeManager ! ResetTriplestoreContent(rdfDataObjects)\n    expectMsg(300.seconds, ResetTriplestoreContentACK())\n\n    responderManager ! LoadOntologiesRequest(SharedTestDataV1.rootUser)\n    expectMsg(10.seconds, LoadOntologiesResponse())\n}\nThese tests should be stored inside the src/test folder hierarchy.\n2) Call the test from SBT:\nsbt:webapi> test // when using a GraphDB-SE or GraphDB-Free","title":"How to Write Unit Tests"},{"location":"/03-webapi/development/testing.html#how-to-write-integration-tests","text":"The only difference between Integration and Unit tests is the location where they are stored and the way how they are called:\n1) Store tests inside the src/it folder hierarchy. 2) Call the tests from SBT: sbt:webapi> it:test","title":"How to Write Integration Tests"},{"location":"/03-webapi/development/testing.html#how-to-write-performance-simulation-tests","text":"1) Store the performance and simulation tests inside the src/test and the src/it folder hierarchy. 2) To call them, execute either gatling:test or gatling-it:test from inside SBT.\nBellow is an example of an simulation calling the /admin/users endpoint. The simulation ramps up 1000 users over 5 seconds, all accessing the /admin/users endpoint.\n/*\n * Copyright © 2015-2018 the contributors (see Contributors.md).\n *\n * This file is part of Knora.\n *\n * Knora is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published\n * by the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Knora is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public\n * License along with Knora.  If not, see <http://www.gnu.org/licenses/>.\n */\n\npackage org.knora.webapi.e2e\n\nimport io.gatling.core.Predef._\nimport io.gatling.http.Predef._\nimport org.knora.webapi.E2ESimSpec\nimport org.knora.webapi.messages.store.triplestoremessages.RdfDataObject\n\nimport scala.concurrent.duration._\n\n/**\n  * Example Simulation Scenario:\n  *\n  * This simulation scenario accesses the users endpoint with\n  * 1000 users concurrently.\n  * */\nclass ExampleE2ESimSpec extends E2ESimSpec {\n\n    override val rdfDataObjects: Seq[RdfDataObject] = Seq.empty[RdfDataObject]\n\n    val protobolBuilder = http\n            .baseURL(\"http://localhost:3333\")\n\n    val users = scenario(\"Users\")\n            .exec(\n                http(\"Get all users\")\n                .get(\"/admin/users\")\n                .check(status.is(200))\n            )\n\n    val injections = Seq(rampUsers(1000) over 5.seconds)\n\n    val assertions = Seq(\n        global.responseTime.mean.lt(800)\n        , forAll.failedRequests.count.lt(1)\n    )\n\n    setUp(\n        users.inject(injections).protocols(protobolBuilder)\n    ).assertions(assertions)\n\n}","title":"How to Write Performance / Simulation Tests"},{"location":"/03-webapi/development/docker-cheat-sheet.html","text":"","title":"Docker Cheat Sheet"},{"location":"/03-webapi/development/docker-cheat-sheet.html#docker-cheat-sheet","text":"Lifecycle Starting and Stopping Info Executing Commands Images\nA complete cheat sheet can be found here","title":"Docker Cheat Sheet"},{"location":"/03-webapi/development/docker-cheat-sheet.html#lifecycle","text":"docker create creates a container but does not start it. docker run creates and starts a container in one operation. docker rename allows the container to be renamed. docker rm deletes a container. docker update updates a container’s resource limits.\nIf you want a transient container, docker run --rm will remove the container after it stops.\nIf you want to map a directory on the host to a docker container, docker run -v $HOSTDIR:$DOCKERDIR.","title":"Lifecycle"},{"location":"/03-webapi/development/docker-cheat-sheet.html#starting-and-stopping","text":"docker start starts a container so it is running. docker stop stops a running container. docker restart stops and starts a container. docker pause pauses a running container, “freezing” it in place. docker attach will connect to a running container.","title":"Starting and Stopping"},{"location":"/03-webapi/development/docker-cheat-sheet.html#info","text":"docker ps shows running containers. docker logs gets logs from container. (You can use a custom log driver, but logs is only available for json-file and journald in 1.10) docker inspect looks at all the info on a container (including IP address). docker events gets events from container. docker port shows public facing port of container. docker top shows running processes in container. docker stats shows containers’ resource usage statistics. docker diff shows changed files in the container’s FS.\ndocker ps -a shows running and stopped containers.\ndocker stats --all shows a running list of containers.","title":"Info"},{"location":"/03-webapi/development/docker-cheat-sheet.html#executing-commands","text":"docker exec to execute a command in container.\nTo enter a running container, attach a new shell process to a running container called foo, use: docker exec -it foo /bin/bash.","title":"Executing Commands"},{"location":"/03-webapi/development/docker-cheat-sheet.html#images","text":"Images are just templates for docker containers.\ndocker images shows all images. docker build creates image from Dockerfile.","title":"Images"},{"location":"/03-webapi/development/monitoring.html","text":"","title":"Monitoring the Webapi Server"},{"location":"/03-webapi/development/monitoring.html#monitoring-the-webapi-server","text":"Monitoring is implemented by using the Prometheus / Grafana stack.","title":"Monitoring the Webapi Server"},{"location":"/03-webapi/development/monitoring.html#usage-","text":"1) Start webapi with the necessary -p option (e.g., from inside sbt: run -p or reStart -p 2) Start the monitoring stack by executing the following line inside the monitoring folder:\n$ WEBAPIHOST=<YourLocalIP> ADMIN_USER=admin ADMIN_PASSWORD=admin docker-compose up -d\n3) Head over to localhost:3000, log in using the admin username and password, and open the “Webapi Akka Actor System” dashboard. 4) To shut down the monitoring stack, run the following line inside the monitoring folder:\n$ docker-compose down","title":"Usage:"},{"location":"/03-webapi/api-v1/index.html","text":"","title":"Knora API v1"},{"location":"/03-webapi/api-v1/index.html#knora-api-v1","text":"Introduction: Using API V1 Reading and Searching Resources XML to Standoff Mapping Adding Resources Reading Values Adding a Value Changing a Value Deleting Resources and Values","title":"Knora API v1"},{"location":"/03-webapi/api-v1/introduction.html","text":"","title":"Introduction: Using API V1"},{"location":"/03-webapi/api-v1/introduction.html#introduction-using-api-v1","text":"","title":"Introduction: Using API V1"},{"location":"/03-webapi/api-v1/introduction.html#restful-api","text":"Knora API V1 is a RESTful API that allows for reading and adding of resources from and to Knora and changing their values using HTTP requests. The actual data is submitted as JSON (request and response format). The diverse HTTP methods are applied according to the widespread practice of RESTful APIs: GET for reading, POST for adding, PUT for changing resources and values, and DELETE to delete resources or values (see Using HTTP Methods for RESTful Services).","title":"RESTful API"},{"location":"/03-webapi/api-v1/introduction.html#knora-iris","text":"Every resource that is created or hosted by Knora is identified by a unique id, a so called Internationalized Resource Identifier (IRI). The IRI is required for every API operation to identify the resource in question. A Knora IRI has itself the format of a URL. For some API operations, the IRI has to be URL-encoded (HTTP GET requests).\nTODO: clarify that API v1 uses internal IRIs.","title":"Knora IRIs"},{"location":"/03-webapi/api-v1/introduction.html#v1-path-segment","text":"Every request to API V1 includes v1 as a path segment, e.g. http://host/v1/resources/http%3A%2F%2Fdata.knora.org%2Fc5058f3a. Accordingly, requests to another version of the API will require another path segment.","title":"V1 Path Segment"},{"location":"/03-webapi/api-v1/introduction.html#knora-api-response-format","text":"In case an API request could be handled successfully, Knora responds with a 200 HTTP status code. The actual answer from Knora (the representation of the requested resource or information about the executed API operation) is sent in the HTTP body, encoded as JSON (using UTF-8). In this JSON, an API specific status code is sent (member status).\nThe JSON formats are formally defined as TypeScript interfaces (located in salsah/src/typescript_interfaces). Build the HTML documentation of these interfaces by executing make jsonformat (see docs/Readme.md for further instructions).","title":"Knora API Response Format"},{"location":"/03-webapi/api-v1/introduction.html#placeholder-host-in-sample-urls","text":"Please note that all the sample URLs used in this documentation contain host as a placeholder. The placeholder host has to be replaced by the actual hostname (and port) of the server the Knora instance is running on.","title":"Placeholder host in sample URLs"},{"location":"/03-webapi/api-v1/introduction.html#authentication","text":"For all API operations that target at changing resources or values, the client has to provide credentials (username and password) so that the API server can authenticate the user making the request. When using the SALSAH web interface, after logging in a session is established (cookie based). When using the API with another client application, credentials can be sent as a part of the HTTP header or as parts of the URL (TODO: add a link to “Authentication in the Knora API Server”).\nAlso when reading resources authentication my be needed as resources and their values may have restricted view permissions.","title":"Authentication"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html","text":"","title":"Reading and Searching Resources"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#reading-and-searching-resources","text":"Get the Representation of a Resource by its IRI Simple Request of a Resource (full Resource Request) Provide Request Parameters Obtain an HTML Representation of a Resource Get only the Properties belonging to a Resource Get Information about a Resource Class Get a Resource Class by its IRI Get all the Property Types of a Resource Class or a Vocabulary Get the Resource Classes of a Vocabulary Get all the Vocabularies Search for Resources Search for Resources by their Label Fulltext Search Extended Search for Resources Get a Graph of Resources Get Hierarchical Lists\nIn order to get an existing resource, the HTTP method GET has to be used. The request has to be sent to the Knora server using the resources path segment (depending on the type of request, this segment has to be exchanged, see below). Reading resources may require authentication since some resources may have restricted viewing permissions.","title":"Reading and Searching Resources"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-the-representation-of-a-resource-by-its-iri","text":"","title":"Get the Representation of a Resource by its IRI"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#simple-request-of-a-resource-full-resource-request-","text":"A resource can be obtained by making a GET request to the API providing its IRI. Because a Knora IRI has the format of a URL, its IRI has to be URL encoded.\nIn order to get the resource with the IRI http://rdfh.ch/c5058f3a (an incunabula book contained in the test data), make a HTTP GET request to the resources route (path segment resources in the API call) and append the URL encoded IRI:\nHTTP GET to http://host/v1/resources/http%3A%2F%2Frdfh.ch%2Fc5058f3a\nMore formalized, the URL looks like this:\nHTTP GET to http://host/v1/resources/resourceIRI\nAs an answer, the client receives a JSON that represents the requested resource. It has the following members:\nstatus: The Knora status code, 0 if everything went well userdata: Data about the user that made the request resinfo: Data describing the requested resource and its class resdata: Short information about the resource and its class (including information about the given user’s permissions on the resource) incoming: Resources pointing to the requested resource props: Properties of the requested resource.\nFor a complete and more formalized description of a full resource request, look at the TypeScript interface resourceFullResponse in the module resourceResponseFormats.","title":"Simple Request of a Resource (full Resource Request)"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#provide-request-parameters","text":"To make a request more specific, the following parameters can be appended to the URL (http://www.knora.org/resources/resourceIRI?param1=value1&param2=value2):\nreqtype=info|context|rights: Specifies the type of request. Setting the parameter’s to value info returns short information about the requested resource (contains only resinfo and no properties, see TypeScript interface resourceInfoResponse in module resourceResponseFormats). Setting the parameter’s value to context returns context information (resource_context) about the requested resource: Either the dependent parts of a compound resource (e.g. pages of a book) or the parent resource of a dependent resource (e.g. the book a pages belongs to). By default, a context query does not return information about the requested resource itself, but only about its context (see TypeScript interface resourceContextResponse in module resourceResponseFormats). See below how to get additional information about the resource. The parameter rights returns only the given user’s permissions on the requested resource (see TypeScript interface resourceRightsResponse in module resourceResponseFormats). resinfo=true: Can be used in combination with reqtype=context: If set, resinfo is added to the response representing information about the requested resource (complementary to its context), see TypeScript interface resourceContextResponse in module resourceResponseFormats.","title":"Provide Request Parameters"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#obtain-an-html-representation-of-a-resource","text":"In order to get an HTML representation of a resource (not a JSON), the path segment resources.html can be used:\nHTTP GET to http://host/v1/resources.html/resourceIRI?reqtype=properties\nThe request returns the properties of the requested resource as an HTML document.","title":"Obtain an HTML Representation of a Resource"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-only-the-properties-belonging-to-a-resource","text":"In order to get only the properties of a resource without any other information, the path segment properties can be used:\nHTTP GET to http://host/v1/properties/resourceIRI\nThe JSON contains just the member properties representing the requested resource’s properties (see TypeScript interface resourcePropertiesResponse in module resourceResponseFormats).","title":"Get only the Properties belonging to a Resource"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-information-about-a-resource-class","text":"","title":"Get Information about a Resource Class"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-a-resource-class-by-its-iri","text":"In order to get information about a resource class, the path segment resourcetypes can be used. Append the IRI of the resource class to the URL (e.g. http://www.knora.org/ontology/0803/incunabula#book).\nHTTP GET to http://host/v1/resourcetypes/resourceClassIRI\nIn the JSON, the information about the resource class and all the property types that it may have are returned. None of these are actual instances of a property, but only types (see TypeScript interface resourceTypeResponse in module resourceResponseFormats).","title":"Get a Resource Class by its IRI"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-all-the-property-types-of-a-resource-class-or-a-vocabulary","text":"To get a list of all the available property types, the path segment propertylists can be used. It can be restricted to a certain vocbulary using the parameter vocabulary or to a certain resource class using the parameter restype.\n# returns all the property types for incunabula:page\nHTTP GET to http://host/v1/propertylists?restype=resourceClassIRI\n\n# returns all the property types for the incunabula vocabulary\nHTTP GET to http://host/v1/propertylists?vocabulary=vocabularyIRI\nBoth of these queries return a list of property types. The default value for the parameter vocabulary is 0 and means that the resource classes from all the available vocabularies are returned. See TypeScript interface propertyTypesInResourceClassResponse in module resourceResponseFormats.","title":"Get all the Property Types of a Resource Class or a Vocabulary"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-the-resource-classes-of-a-vocabulary","text":"Resource classes and property types are organized in (project specific) name spaces, so called vocabularies. In order to get all the resource classes defined for a specific vocabulary (e.g. incunabula), the parameter vocabulary has to be used and assigned the vocabulary’s IRI:\nHTTP GET to http://host/v1/resourcetypes?vocabulary=vocabularyIRI\nThis returns all the resource classes defined for the specified vocabulary and their property types. The default value for the parameter vocabulary is 0 and means that the resource classes from all the available vocabularies are returned. See TypeScript interface resourceTypesInVocabularyResponse in module resourceResponseFormats.","title":"Get the Resource Classes of a Vocabulary"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-all-the-vocabularies","text":"To get a list of all available vocabularies, the path segment vocabularies can be used:\nHTTP GET to http://host/v1/vocabularies\nThe response will list all the available vocabularies. See TypeScript interface vocabularyResponse in module resourceResponseFormats.","title":"Get all the Vocabularies"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#search-for-resources","text":"","title":"Search for Resources"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#search-for-resources-by-their-label","text":"This is a simplified way for searching for resources just by their label. It is a simple string-based method:\nHTTP GET to http://host/v1/resources?searchstr=searchValue\nAdditionally, the following parameters can be appended to the URL (search value is Zeitglöcklein):\nrestype_id=resourceClassIRI: This restricts the search to resources of the specified class (subclasses of that class will also match). -1 is the default value and means no restriction to a specific class. If a resource class IRI is specified, it has to be URL encoded (e.g. http://www.knora.org/v1/resources?searchstr=Zeitgl%C3%B6cklein&restype_id=http%3A%2F%2Fwww.knora.org%2Fontology%2Fincunabula%23book). numprops=Integer: Specifies the number of properties returned for each resource that was found (sorted by GUI order), e.g. http://www.knora.org/v1/resources?searchstr=Zeitgl%C3%B6cklein&numprops=4. limit=Integer: Limits the amount of results returned (e.g. http://www.knora.org/v1/resources?searchstr=Zeitgl%C3%B6cklein&limit=1).\nThe response lists the resources that matched the search criteria (see TypeScript interface resourceLabelSearchResponse in module resourceResponseFormats).","title":"Search for Resources by their Label"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#fulltext-search","text":"Knora offers a fulltext search that searches through all textual representations of values. You can separate search terms by a white space and they will be combined using the Boolean AND operator. The search terms have to be URL encoded.\nHTTP GET to http://host/v1/search/searchValue?searchtype=fulltext[&filter_by_restype=resourceClassIRI]\n[&filter_by_project=projectIRI][&show_nrows=Integer]{[&start_at=Integer]\nThe parameter searchtype is required and has to be set to fulltext. Additionally, these parameters can be set:\nfilter_by_restype=resourceClassIRI: restricts the search to resources of the specified resource class (subclasses of that class will also match). filter_by_project=projectIRI: restricts the search to resources of the specified project. show_nrows=Integer: Indicates how many reults should be presented on one page. If omitted, the default value 25 is used. start_at=Integer: Used to enable paging and go through all the results request by request.\nThe response presents the retrieved resources (according to show_nrows and start_at) and information about paging. If not all resources could be presented on one page (nhits is greater than shown_nrows), the next page can be requested (by increasing start_at by the number of show_nrows). You can simply go through the elements of paging to request the single pages one by one. See TypeScript interface searchResponse in module searchResponseFormats.","title":"Fulltext Search"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#extended-search-for-resources","text":"HTTP GET to http://host/v1/search/?searchtype=extended\n[&filter_by_restype=resourceClassIRI][&filter_by_project=projectIRI][&filter_by_owner=userIRI]\n(&property_id=propertyTypeIRI&compop=comparisonOperator&searchval=searchValue)+\n[&show_nrows=Integer][&start_at=Integer]\nThe parameter searchtype is required and has to be set to extended. An extended search requires at least one set of parameters consisting of:\nproperty_id=propertyTypeIRI: the property the resource has to have (subproperties of that property will also match). compop=comparisonOperator: the comparison operator to be used to match between the resource’s property value and the search term. searchval=searchTerm: the search value to look for.\nYou can also provide several of these sets to make your query more specific.\nThe following table indicates the possible combinations of value types and comparison operators:\nValue Type Comparison Operator Date Value EQ, !EQ, GT, GT_EQ, LT, LT_EQ, EXISTS Integer Value EQ, !EQ, GT, GT_EQ, LT, LT_EQ, EXISTS Float Value EQ, !EQ, GT, GT_EQ, LT, LT_EQ, EXISTS Text Value MATCH_BOOLEAN, MATCH, EQ, !EQ, LIKE, !LIKE, EXISTS Geometry Value EXISTS Resource Pointer EQ, EXISTS Color Value EQ, EXISTS List Value EQ, EXISTS Boolean Value EQ, !EQ, EXISTS\nExplanation of the comparison operators:\nEQ: checks if a resource’s value equals the search value. In case of a text value type, it checks for identity of the strings compared. In case of a date value type, equality is given if the dates overlap in any way. Since dates are internally always treated as periods, equality is given if a date value’s period ends after or equals the start of the defined period and a date value’s period starts before or equals the end of the defined period. !EQ: checks if a resource’s value does not equal the search value. In case of a text value type, it checks if the compared strings are different. In case of a date value type, inequality is given if the dates do not overlap in any way, meaning that a date starts after the end of the defined period or ends before the beginning of the defined period (dates are internally always treated as periods, see above). GT: checks if a resource’s value is greater than the search value. In case of a date value type, it assures that a period begins after the indicated period’s end. GT_EQ: checks if a resource’s value equals or is greater than the search value. In case of a date value type, it assures that the periods overlap in any way (see EQ) or that the period starts after the indicated period’s end (see GT). LT: checks if a resource’s value is lower than the search value. In case of a date value type, it assures that a period ends before the indicated period’s start. LT_EQ: checks if a resource’s value equals or is lower than the search value. In case of a date value type, it assures that the periods overlap in any way (see EQ) or that the period ends before the indicated period’s start (see LT). EXISTS: checks if an instance of the indicated property type exists for a resource. Please always provide an empty search value when using EXISTS: “searchval=”. Otherwise, the query syntax rules would be violated. MATCH: checks if a resource’s text value matches the search value. The behaviour depends on the used triplestore’s full text index. LIKE: checks if the search value is contained in a resource’s text value. !LIKE: checks if the search value is not contained in a resource’s text value. MATCH_BOOLEAN: checks if a resource’s text value matches the provided list of positive (exist) and negative (do not exist) terms. The list takes this form: ([+-]term\\s)+.\nAdditionally, these parameters can be set:\nfilter_by_restype=resourceClassIRI: restricts the search to resources of the specified resource class (subclasses of that class will also match). filter_by_project=projectIRI: restricts the search to resources of the specified project. filter_by_owner: restricts the search to resources owned by the specified user. show_nrows=Integer: Indicates how many reults should be presented on one page. If omitted, the default value 25 is used. start_at=Integer: Used to enable paging and go through all the results request by request.\nSome sample searches:\nhttp://localhost:3333/v1/search/?searchtype=extended&filter_by_restype=http%3A%2F%2Fwww.knora.org%2Fontology%2Fincunabula%23book&property_id=http%3A%2F%2Fwww.knora.org%2Fontology%2Fincunabula%23title&compop=!EQ&searchval=Zeitgl%C3%B6cklein%20des%20Lebens%20und%20Leidens%20Christi: searches for books that have a title that does not equal “Zeitglöcklein des Lebens und Leidens Christi”. http://www.knora.org/v1/search/?searchtype=extended&filter_by_restype=http%3A%2F%2Fwww.knora.org%2Fontology%2Fincunabula%23book&property_id=http%3A%2F%2Fwww.knora.org%2Fontology%2Fincunabula%23title&compop=MATCH&searchval=Zeitgl%C3%B6cklein&property_id=http%3A%2F%2Fwww.knora.org%2Fontology%2Fincunabula%23pubdate&compop=EQ&searchval=JULIAN:1490: searches for resources of type incunabula:book whose titles match “Zeitglöcklein” and were published in the year 1490 (according to the Julian calendar).\nThe response presents the retrieved resources (according to show_nrows and start_at) and information about paging. If not all resources could be presented on one page (nhits is greater than shown_nrows), the next page can be requested (by increasing start_at by the number of show_nrows). You can simply go through the elements of paging to request the single pages one by one. See the TypeScript interface searchResponse in module searchResponseFormats.","title":"Extended Search for Resources"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-a-graph-of-resources","text":"The path segment graphdata returns a graph of resources that are reachable via links to or from an initial resource.\nHTTP GET to http://host/v1/graphdata/resourceIRI?depth=Integer\nThe parameter depth specifies the maximum depth of the graph, and defaults to 4. If depth is 1, the operation will return only the initial resource and any resources that are directly linked to or from it.\nThe graph includes any link that is a subproperty of knora-base:hasLinkTo, except for links that are subproperties of knora-base:isPartOf. Specifically, if resource R1 has a link that is a subproperty of knora-base:isPartOf pointing to resource R2, no link from R1 to R2 is included in the graph.\nThe response represents the graph as a list of nodes (resources) and a list of edges (links). For details, see the TypeScript interface graphDataResponse in module graphDataResponseFormats.","title":"Get a Graph of Resources"},{"location":"/03-webapi/api-v1/reading-and-searching-resources.html#get-hierarchical-lists","text":"The knora-base ontology allows for the definition of hierarchical lists. These can be queried by providing the IRI of the root node. Selections are hierarchical list that are just one level deep. Internally, they are represented as hierarchical lists.\nYou can get a hierarchical by using the path segment hlists and appending the hierarchical list’s IRI (URL encoded):\nHTTP GET to http://host/v1/hlists/rootNodeIRI\nThe response shows all of the list nodes that are element of the requested hierarchical list as a tree structure. See TypeScript interface hierarchicalListResponse in module hierarchicalListResponseFormats.\nFor each node, the full path leading to it from the top level can be requested by making a query providing the node’s IRI and setting the param reqtype=node:\nHTTP GET to http://host/v1/hlists/nodeIri?reqtype=node\nThe response presents the full path to the current node. See the TypeScript interface nodePathResponse in module hierarchicalListResponseFormats.","title":"Get Hierarchical Lists"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html","text":"","title":"XML to Standoff Mapping"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#xml-to-standoff-mapping","text":"The Knora Standard Mapping Description Maintenance Creating a custom Mapping Basic Structure of a Mapping id and class Attributes Respecting Cardinalities Standoff Data Types Internal References in an XML Document Predefined Standoff Classes and Properties Respecting Property Types Validating a Mapping and sending it to Knora","title":"XML to Standoff Mapping"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#the-knora-standard-mapping","text":"","title":"The Knora Standard Mapping"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#description","text":"A mapping allows for the conversion of XML to standoff representation in RDF and back. In order to create a TextValue with markup, the text has to be provided in XML format, along with the IRI of the mapping that will be used to convert the markup to standoff. However, a mapping is only needed if a TextValue with markup should be created. If a text has no markup, it is submitted as a mere sequence of characters.\nThe two cases are described in the TypeScript interfaces simpletext and richtext in module basicMessageComponents.\nKnora offers a standard mapping with the IRI http://data.knora.org/projects/standoff/mappings/StandardMapping. The standard mapping covers the HTML elements and attributes supported by the GUI’s text editor, CKEditor. (Please note that the HTML has to be encoded in strict XML syntax. CKeditor offers the possibility to define filter rules. They should reflect the elements supported by the mapping; see jquery.htmleditor.js.) The standard mapping contains the following elements and attributes that are mapped to standoff classes and properties defined in the ontology:\n<text> → standoff:StandoffRootTag <p> → standoff:StandoffParagraphTag <em> → standoff:StandoffItalicTag <strong> → standoff:StandoffBoldTag <u> → standoff:StandoffUnderlineTag <sub> → standoff:StandoffSubscriptTag <sup> → standoff:StandoffSuperscriptTag <strike> → standoff:StandoffStrikeTag <a href=\"URL\"> → knora-base:StandoffUriTag <a class=\"salsah-link\" href=\"Knora IRI\"> → knora-base:StandoffLinkTag <h1> to <h6> → standoff:StandoffHeader1Tag to standoff:StandoffHeader6Tag <ol> → standoff:StandoffOrderedListTag <ul> → standoff:StandoffUnrderedListTag <li> → standoff:StandoffListElementTag <tbody> → standoff:StandoffTableBodyTag <table> → standoff:StandoffTableTag <tr> → standoff:StandoffTableRowTag <td> → standoff:StandoffTableCellTag <br> → standoff:StandoffBrTag <hr> → standoff:StandoffLineTag <pre> → standoff:StandoffPreTag <cite> → standoff:StandoffCiteTag <blockquote> → standoff:StandoffBlockquoteTag <code> → standoff:StandoffCodeTag\nThe HTML produced by CKEditor is wrapped in an XML doctype and a pair of root tags <text>...</text> and then sent to Knora. The XML sent to the GUI by Knora is unwrapped accordingly (see jquery.htmleditor.js). Although the GUI supports HTML5, it is treated as if it was XHTML in strict XML notation.","title":"Description"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#maintenance","text":"The standard mapping definition can be found at webapi/_test_data/test_route/texts/mappingForStandardHTML.xml. It was used to generate the default mapping, distributed as knora-ontologies/standoff-data.ttl and that is loaded at a Knora installation. It should be used to re-generate it, whenever we want to amend or extend it.\nNote: once the mapping has been generated, one has to rework the resources’ UUID in order to maintain backward compatibility.","title":"Maintenance"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#creating-a-custom-mapping","text":"The Knora standard mapping only supports a few HTML tags. In order to submit more complex XML markup to Knora, a custom mapping has to be created first. Basically, a mapping expresses the relations between XML elements and attributes and their corresponding standoff classes and properties. The relations expressed in a mapping are one-to-one relations, so the XML can be recreated from the data in RDF. However, since HTML offers a very limited set of elements, Knora mappings support the combination of element names and classes. In this way, the same element can be used several times in combination with another classname (please note that <a> without a class is a mere hyperlink whereas <a class=\"salsah-link\"> is an internal link/standoff link).\nWith a mapping, a default XSL transformation may be provided to transform the XML to HTML before sending it back to the client. This is useful when the client is a web-browser expecting HTML (instead of XML).","title":"Creating a custom Mapping"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#basic-structure-of-a-mapping","text":"The mapping is written in XML itself (for a formal description, see webapi/src/resources/mappingXMLToStandoff.xsd). It has the following structure (the indentation corresponds to the nesting in XML):\n<mapping>: the root element <defaultXSLTransformation> (optional): the Iri of the default XSL transformation to be applied to the XML when reading it back from Knora. The XSL transformation is expected to produce HTML. If given, the Iri has to refer to a resource of type knora-base:XSLTransformation. <mappingElement>: an element of the mapping (at least one) <tag>: information about the XML element that is mapped to a standoff class <name>: name of the XML element <class>: value of the class attribute of the XML element, if any. If the element has no class attribute, the keyword noClass has to be used. <namespace>: the namespace the XML element belongs to, if any. If the element does not belong to a namespace, the keyword noNamespace has to be used. <separatesWords>: a Boolean value indicating whether this tag separates words in the text. Once an XML document is converted to RDF-standoff the markup is stripped from the text, possibly leading to continuous text that has been separated by tags before. For structural tags like paragraphs etc., <separatesWords> can be set to true in which case a special separator is inserted in the the text in the RDF representation. In this way, words stay separated and are represented in the fulltext index as such. <standoffClass>: information about the standoff class the XML element is mapped to <classIri>: Iri of the standoff class the XML element is mapped to <attributes>: XML attributes to be mapped to standoff properties (other than id or class), if any <attribute>: an XML attribute to be mapped to a standoff property, may be repeated <attributeName>: the name of the XML attribute <namespace>: the namespace the attribute belongs to, if any. If the attribute does not belong to a namespace, the keyword noNamespace has to be used. <propertyIri>: the Iri of the standoff property the XML attribute is mapped to. <datatype>: the data type of the standoff class, if any. <type>: the Iri of the data type standoff class <attributeName>: the name of the attribute holding the typed value in the expected Knora standard format\nXML structure of a mapping:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<mapping>\n    <defaultXSLTransformation>Iri of a knora-base:XSLTransformation</defaultXSLTransformation>\n    <mappingElement>\n        <tag>\n            <name>XML element name</name>\n            <class>XML class name or \"noClass\"</class>\n            <namespace>XML namespace or \"noNamespace\"</namespace>\n            <separatesWords>true or false</separatesWords>\n        </tag>\n        <standoffClass>\n            <classIri>standoff class Iri</classIri>\n            <attributes>\n                <attribute>\n                    <attributeName>XML attribute name</attributeName>\n                    <namespace>XML namespace or \"noNamespace\"</namespace>\n                    <propertyIri>standoff property Iri</propertyIri>\n                </attribute>\n            </attributes>\n            <datatype>\n                <type>standoff data type class</type>\n                <attributeName>XML attribute with the typed value</attributeName>\n            </datatype>\n        </standoffClass>\n    </mappingElement>\n    <mappingElement>\n       ...\n    </mappingElement>\n</mapping>\nPlease note that the absence of an XML namespace and/or a class have to be explicitly stated using the keywords noNamespace and noClass. (This is because we use XML Schema validation to ensure the one-to-one relations between XML elements and standoff classes. XML Schema validation’s unique checks do not support optional values.)","title":"Basic Structure of a Mapping"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#id-and-class-attributes","text":"The id and class attributes are supported by default and do not have to be included in the mapping like other attributes. The id attribute identifies an element and must be unique in the document. id is an optional attribute. The class attribute allows for the reuse of an element in the mapping, i.e. the same element can be combined with different class names and mapped to different standoff classes (mapping element <class> in <tag>).","title":"id and class Attributes"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#respecting-cardinalities","text":"A mapping from XML elements and attributes to standoff classes and standoff properties must respect the cardinalities defined in the ontology for those very standoff classes. If an XML element is mapped to a certain standoff class and this class requires a standoff property, an attribute must be defined for the XML element mapping to that very standoff property. Equally, all mappings for attributes of an XML element must have corresponding cardinalities for standoff properties defined for the standoff class the XML element maps to.\nHowever, since an XML attribute may occur once at maximum, it makes sense to make the corresponding standoff property required (owl:cardinality of one) in the ontology or optional (owl:maxCardinality of one), but not allowing it more than once.","title":"Respecting Cardinalities"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#standoff-data-types","text":"Knora allows the use of all its value types as standoff data types (defined in knora-base.ttl):\nknora-base:StandoffLinkTag: Represents a reference to a Knora resource (the IRI of the target resource must be submitted in the data type attribute). knora-base:StandoffInternalReferenceTag: Represents an internal reference inside a document (the id of the target element inside the same document must be indicated in the data type attribute); see Internal References in an XML Document. knora-base:StandoffUriTag: Represents a reference to a URI (the URI of the target resource must be submitted in the data type attribute). knora-base:StandoffDateTag: Represents a date (a Knora date string must be submitted in the data type attribute, e.g. GREGORIAN:2017-01-27). knora-base:StandoffColorTag: Represents a color (a hexadecimal RGB color string must be submitted in the data type attribute, e.g. #0000FF). knora-base:StandoffIntegerTag: Represents an integer (the integer must be submitted in the data type attribute). knora-base:StandoffDecimalTag: Represents a number with fractions (the decimal number must be submitted in the data type attribute, e.g. 1.1). knora-base:StandoffIntervalTag: Represents an interval (two decimal numbers separated with a comma must be submitted in the data type attribute, e.g. 1.1,2.2). knora-base:StandoffBooleanTag: Represents a Boolean value (true or false must be submitted in the data type attribute).\nThe basic idea is that parts of a text can be marked up in a way that allows using Knora’s built-in data types. In order to do so, the typed values have to be provided in a standardized way in an attribute that has to be defined in the mapping.\nData type standoff classes are standoff classes with predefined properties (e.g., a knora-base:StandoffLinkTag has a knora-base:standoffTagHasLink and a knora-base:StandoffIntegerTag has a knora-base:valueHasInteger). Please note the data type standoff classes can not be combined, i.e. a standoff class can only be the subclass of one data type standoff class. However, standoff data type classes can be subclassed and extended further by assigning properties to them (see below).\nThe following simple mapping illustrates this principle:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<mapping>\n     <mappingElement>\n        <tag>\n            <name>text</name>\n            <class>noClass</class>\n            <namespace>noNamespace</namespace>\n            <separatesWords>false</separatesWords>\n        </tag>\n        <standoffClass>\n            <classIri>http://www.knora.org/ontology/standoff#StandoffRootTag</classIri>\n        </standoffClass>\n    </mappingElement>\n\n    <mappingElement>\n        <tag>\n            <name>mydate</name>\n            <class>noClass</class>\n            <namespace>noNamespace</namespace>\n            <separatesWords>false</separatesWords>\n        </tag>\n        <standoffClass>\n            <classIri>http://www.knora.org/ontology/0001/anything#StandoffEventTag</classIri>\n            <attributes>\n                <attribute>\n                    <attributeName>description</attributeName>\n                    <namespace>noNamespace</namespace>\n                    <propertyIri>http://www.knora.org/ontology/0001/anything#standoffEventTagHasDescription</propertyIri>\n                </attribute>\n            </attributes>\n            <datatype>\n                <type>http://www.knora.org/ontology/knora-base#StandoffDateTag</type>\n                <attributeName>knoraDate</attributeName>\n            </datatype>\n        </standoffClass>\n    </mappingElement>\n</mapping>\n<datatype> must hold the Iri of a standoff data type class (see list above). The <classIri> must be a subclass of this type or this type itself (the latter is probably not recommendable since semantics are missing: what is the meaning of the date?). In the example above, the standoff class is anything:StandoffEventTag which has the following definition in the ontology anything-onto.ttl:\nanything:StandoffEventTag rdf:type owl:Class ;\n\n    rdfs:subClassOf knora-base:StandoffDateTag,\n                   [\n                      rdf:type owl:Restriction ;\n                      owl:onProperty :standoffEventTagHasDescription ;\n                      owl:cardinality \"1\"^^xsd:nonNegativeInteger\n                   ] ;\n\n    rdfs:label \"Represents an event in a TextValue\"@en ;\n\n    rdfs:comment \"\"\"Represents an event in a TextValue\"\"\"@en .\nanything:StandoffEventTag is a subclass of knora-base:StandoffDateTag and therefore has the data type date. It also requires the standoff property anything:standoffEventTagHasDescription which is defined as an attribute in the mapping.\nOnce the mapping has been created, an XML like the following could be sent to Knora and converted to standoff:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<text>\n    We had a party on <mydate description=\"new year\" knoraDate=\"GREGORIAN:2016-12-31\">New Year's Eve</mydate>. It was a lot of fun.\n</text>\nThe attribute holds the date in the format of a Knora date string (the format is also documented in the typescript type alias dateString in module basicMessageComponents. There you will also find documentation about the other types like color etc.). Knora date strings have this format: GREGORIAN|JULIAN):YYYY[-MM[-DD]][:YYYY[-MM[-DD]]]. This allows for different formats as well as for imprecision and periods. Intervals are submitted as one attribute in the following format: interval-attribute=\"1.0,2.0\" (two decimal numbers separated with a comma).\nYou will find a sample mapping with all the data types and a sample XML file in the the test data: webapi/_test_data/test_route/texts/mappingForHTML.xml and webapi/_test_data/test_route/texts/HTML.xml.","title":"Standoff Data Types"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#internal-references-in-an-xml-document","text":"Internal references inside an XML document can be represented using the data type standoff class knora-base:StandoffInternalReferenceTag or a subclass of it. This class has a standoff property that points to a standoff node representing the target XML element when converted to RDF.\nThe following example shows the definition of a mapping element for an internal reference (for reasons of simplicity, only the mapping element for the element is question is depicted):\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<mappingElement>\n    <tag>\n        <name>ref</name>\n        <class>noClass</class>\n        <namespace>noNamespace</namespace>\n        <separatesWords>false</separatesWords>\n    </tag>\n    <standoffClass>\n        <classIri>http://www.knora.org/ontology/knora-base#StandoffInternalReferenceTag</classIri>\n        <datatype>\n            <type>http://www.knora.org/ontology/knora-base#StandoffInternalReferenceTag</type>\n            <attributeName>internalRef</attributeName>\n        </datatype>\n    </standoffClass>\n</mappingElement>\nNow, an internal reference to an element in the same document can be made that will be converted to a pointer in RDF:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<text>\n    This is an <sample id=\"1\">element</sample> and here is a reference to <ref internalRef=\"#1\">it</ref>.\n</text>\nAn internal reference in XML has to start with a # followed by the value of the id attribute of the element referred to.","title":"Internal References in an XML Document"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#predefined-standoff-classes-and-properties","text":"The standoff ontology standoff-onto.ttl offers a set of predefined standoff classes that can be used in a custom mapping like the following:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<mapping>\n    <mappingElement>\n        <tag>\n            <name>myDoc</name>\n            <class>noClass</class>\n            <namespace>noNamespace</namespace>\n            <separatesWords>false</separatesWords>\n        </tag>\n        <standoffClass>\n            <classIri>http://www.knora.org/ontology/standoff#StandoffRootTag</classIri>\n            <attributes>\n                <attribute>\n                    <attributeName>documentType</attributeName>\n                    <namespace>noNamespace</namespace>\n                    <propertyIri>http://www.knora.org/ontology/standoff#standoffRootTagHasDocumentType</propertyIri>\n                </attribute>\n            </attributes>\n        </standoffClass>\n    </mappingElement>\n\n    <mappingElement>\n        <tag>\n            <name>p</name>\n            <class>noClass</class>\n            <namespace>noNamespace</namespace>\n            <separatesWords>true</separatesWords>\n        </tag>\n        <standoffClass>\n            <classIri>http://www.knora.org/ontology/standoff#StandoffParagraphTag</classIri>\n        </standoffClass>\n    </mappingElement>\n\n    <mappingElement>\n        <tag>\n            <name>i</name>\n            <class>noClass</class>\n            <namespace>noNamespace</namespace>\n            <separatesWords>false</separatesWords>\n        </tag>\n        <standoffClass>\n            <classIri>http://www.knora.org/ontology/standoff#StandoffItalicTag</classIri>\n        </standoffClass>\n    </mappingElement>\n</mapping>\nPredefined standoff classes may be used by various projects, each providing a custom mapping to be able to recreate the original XML from RDF. Predefined standoff classes may also be inherited and extended in project specific ontologies.\nThe mapping above allows for an XML like this:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<myDoc documentType=\"letter\">\n    <p>\n        This my text that is <i>very</i> interesting.\n    </p>\n    <p>\n        And here it goes on.\n    </p>\n</myDoc>","title":"Predefined Standoff Classes and Properties"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#respecting-property-types","text":"When mapping XML attributes to standoff properties, attention has to be paid to the properties’ object constraints.\nIn the ontology, standoff property literals may have one of the following knora-base:objectDatatypeConstraint:\nxsd:string xsd:integer xsd:boolean xsd:decimal xsd:anyURI\nIn XML, all attribute values are submitted as strings. However, these string representations need to be convertible to the types defined in the ontology. If they are not, the request will be rejected. It is recommended to enforce types on attributes by applying XML Schema validations (restrictions).\nLinks (object property) to a knora-base:Resource can be represented using the data type standoff class knora-base:StandoffLinkTag, internal links using the data type standoff class knora-base:StandoffInternalReferenceTag.","title":"Respecting Property Types"},{"location":"/03-webapi/api-v1/xml-to-standoff-mapping.html#validating-a-mapping-and-sending-it-to-knora","text":"A mapping can be validated before sending it to Knora with the following XML Schema file: webapi/src/resources/mappingXMLToStandoff.xsd. Any mapping that does not conform to this XML Schema file will be rejected by Knora.\nThe mapping has to be sent as a multipart request to the standoff route using the path segment mapping:\nHTTP POST http://host/v1/mapping\nThe multipart request consists of two named parts:\n\"json\":\n\n  {\n    \"project_id\": \"projectIRI\",\n    \"label\": \"my mapping\",\n    \"mappingName\": \"MappingNameSegment\"\n  }\n\n\"xml\":\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <mapping>\n      ...\n  </mapping>\nA successful response returns the Iri of the mapping. However, the Iri of a mapping is predictable: it consists of the project Iri followed by /mappings/ and the mappingName submitted in the JSON (if the name already exists, the request will be rejected). Once created, a mapping can be used to create TextValues in Knora. The formats are documented in the typescript interfaces addMappingRequest and addMappingResponse in module mappingFormats","title":"Validating a Mapping and sending it to Knora"},{"location":"/03-webapi/api-v1/adding-resources.html","text":"","title":"Adding Resources"},{"location":"/03-webapi/api-v1/adding-resources.html#adding-resources","text":"Adding Resources Without a Digital Representation Adding Resources with a Digital Representation Including the binaries (non-GUI case) Indicating the location of a file (GUI case) Response to a Resource Creation Changing a resource’s label Bulk Import Bulk Import Example Get XML Schemas Generate XML Bulk Import with Links to Existing Resources Bulk Import of Resources with Digital Representations\nTo create a resource, the HTTP method POST has to be used. The request has to be sent to the Knora server using the resources path segment:\nHTTP POST to http://host/v1/resources\nUnlike in the case of GET requests, the request body consists of JSON describing the resource to be created.\nCreating resources requires authentication since only known users may add resources.","title":"Adding Resources"},{"location":"/03-webapi/api-v1/adding-resources.html#adding-resources-without-a-digital-representation","text":"The format of the JSON used to create a resource without a digital representation is described in the TypeScript interface createResourceWithoutRepresentationRequest in module createResourceFormats. It requires the IRI of the resource class the new resource belongs to, a label describing the new resource, the IRI of the project the new resource belongs to, and the properties to be assigned to the new resource.\nThe request header’s content type has to be set to application/json.","title":"Adding Resources Without a Digital Representation"},{"location":"/03-webapi/api-v1/adding-resources.html#adding-resources-with-a-digital-representation","text":"Certain resource classes allow for digital representations (e.g. an image). There are two ways to attach a file to a resource: Either by submitting directly the binaries of the file in a HTTP Multipart request or by indicating the location of the file. The two cases are referred to as non-GUI case and GUI case (TODO: add a link to “Sipi and Knora”).","title":"Adding Resources with a Digital Representation"},{"location":"/03-webapi/api-v1/adding-resources.html#including-the-binaries-non-gui-case-","text":"In order to include the binaries, a HTTP Multipart request has to be sent. One part contains the JSON (same format as described for Adding Resources Without a Digital Representation) and has to be named json. The other part contains the file’s name, its binaries, and its mime type and has to be named file. The following example illustrates how to make this type of request using Python 3:\n#!/usr/bin/env python3\n\nimport requests, json\n\n# a Python dictionary that will be turned into a JSON object\nresourceParams = {\n   'restype_id': 'http://www.knora.org/ontology/test#testType',\n   'properties': {\n       'http://www.knora.org/ontology/test#testtext': [\n           {'richtext_value': {'utf8str': \"test\"}}\n       ],\n       'http://www.knora.org/ontology/test#testnumber': [\n           {'int_value': 1}\n       ]\n   },\n   'label': \"test resource\",\n   'project_id': 'http://data.knora.org/projects/testproject'\n}\n\n# the name of the file to be submitted\nfilename = \"myimage.jpg\"\n\n# a tuple containing the file's name, its binaries and its mimetype\nfile = {'file': (filename, open(filename, 'rb'), \"image/jpeg\")} # use name \"file\"\n\n# do a POST request providing both the JSON and the binaries\nr = requests.post(\"http://host/v1/resources\",\n                  data={'json': json.dumps(resourceParams)}, # use name \"json\"\n                  files=file,\n                  auth=('user', 'password'))\nPlease note that the file has to be read in binary mode (by default it would be read in text mode).","title":"Including the binaries (non-GUI case)"},{"location":"/03-webapi/api-v1/adding-resources.html#indicating-the-location-of-a-file-gui-case-","text":"This request works similarly to Adding Resources Without a Digital Representation. The JSON format is described in the TypeScript interface createResourceWithRepresentationRequest in module createResourceFormats. The request header’s content type has to set to application/json.\nIn addition to Adding Resources Without a Digital Representation, the (temporary) name of the file, its original name, and mime type have to be provided (TODO: add a link to “GUI case” in “Sipi and Knora”).","title":"Indicating the location of a file (GUI case)"},{"location":"/03-webapi/api-v1/adding-resources.html#response-to-a-resource-creation","text":"When a resource has been successfully created, Knora sends back a JSON containing the new resource’s IRI (res_id) and its properties. The resource IRI identifies the resource and can be used to perform future Knora API V1 operations.\nThe JSON format of the response is described in the TypeScript interface createResourceResponse in module createResourceFormats.","title":"Response to a Resource Creation"},{"location":"/03-webapi/api-v1/adding-resources.html#changing-a-resources-label","text":"A resource’s label can be changed by making a PUT request to the path segments resources/label. The resource’s Iri has to be provided in the URL (as its last segment). The new label has to submitted as JSON in the HTTP request’s body.\nHTTP PUT to http://host/v1/resources/label/resourceIRI\nThe JSON format of the request is described in the TypeScript interface changeResourceLabelRequest in module createResourceFormats. The response is described in the TypeScript interface changeResourceLabelResponse in module createResourceFormats.","title":"Changing a resource’s label"},{"location":"/03-webapi/api-v1/adding-resources.html#bulk-import","text":"If you have a large amount of data to import into Knora, it can be more convenient to use the bulk import feature than to create resources one by one. In a bulk import operation, you submit an XML document to Knora, describing multiple resources to be created. This is especially useful if the resources to be created have links to one another. Knora checks the entire request for consistency as as a whole, and performs the update in a single database transaction.\nOnly system or project administrators may use the bulk import.\nThe procedure for using this feature is as follows:\nMake a request to the Knora API server to get XML schemas describing the XML to be provided for the import. Convert your data into XML, including the filesystem paths of any files that should be attached to the resources to be created. Use an XML schema validator such as Apache Xerces or Saxon, or an XML development environment such as Oxygen, to check that your XML is valid according to the schemas you got from the Knora API server. Submit your XML to the Knora API server.\nIn this procedure, the person responsible for generating the XML import data need not be familiar with RDF or with the ontologies involved.\nWhen Knora receives an XML import, it validates it first using the relevant XML schemas, and then using the same internal checks that it performs when creating any resource.\nThe details of the XML import format are illustrated in the following examples.","title":"Bulk Import"},{"location":"/03-webapi/api-v1/adding-resources.html#bulk-import-example","text":"Suppose we have a project with existing data (but no digital representations), which we want to import into Knora. We have created an ontology called http://www.knora.org/ontology/0802/biblio for the project, and this ontology also uses definitions from another ontology, called http://www.knora.org/ontology/0801/beol.","title":"Bulk Import Example"},{"location":"/03-webapi/api-v1/adding-resources.html#get-xml-schemas","text":"To get XML schemas for an import, we use the following route, specifying the IRI of our project’s main ontology (in this case http://www.knora.org/ontology/0802/biblio):\nHTTP GET to http://host/v1/resources/xmlimportschemas/ontologyIRI\nThis returns a Zip archive called p0802-biblio-xml-schemas.zip, containing three files:\np0802-biblio.xsd: The schema for our main ontology. p0801-beol.xsd: A schema for another ontology that our main ontology depends on. knoraXmlImport.xsd: The standard Knora XML import schema, used by all XML imports.","title":"Get XML Schemas"},{"location":"/03-webapi/api-v1/adding-resources.html#generate-xml","text":"We now convert our existing data to XML, probably by writing a custom script. The XML looks like this:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<knoraXmlImport:resources xmlns=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1#\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1# p0802-biblio.xsd\"\n    xmlns:p0802-biblio=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1#\"\n    xmlns:p0801-beol=\"http://api.knora.org/ontology/0801/beol/xml-import/v1#\"\n    xmlns:knoraXmlImport=\"http://api.knora.org/ontology/knoraXmlImport/v1#\">\n    <p0801-beol:person id=\"abel\">\n        <knoraXmlImport:label>Niels Henrik Abel</knoraXmlImport:label>\n        <p0801-beol:hasFamilyName knoraType=\"richtext_value\">Abel</p0801-beol:hasFamilyName>\n        <p0801-beol:hasGivenName knoraType=\"richtext_value\">Niels Henrik</p0801-beol:hasGivenName>\n    </p0801-beol:person>\n    <p0801-beol:person id=\"holmes\">\n        <knoraXmlImport:label>Sherlock Holmes</knoraXmlImport:label>\n        <p0801-beol:hasFamilyName knoraType=\"richtext_value\">Holmes</p0801-beol:hasFamilyName>\n        <p0801-beol:hasGivenName knoraType=\"richtext_value\">Sherlock</p0801-beol:hasGivenName>\n    </p0801-beol:person>\n    <p0802-biblio:Journal id=\"math_intelligencer\">\n        <knoraXmlImport:label>Math Intelligencer</knoraXmlImport:label>\n        <p0802-biblio:hasName knoraType=\"richtext_value\">Math Intelligencer</p0802-biblio:hasName>\n    </p0802-biblio:Journal>\n    <p0802-biblio:JournalArticle id=\"strings_in_the_16th_and_17th_centuries\">\n        <knoraXmlImport:label>Strings in the 16th and 17th Centuries</knoraXmlImport:label>\n        <p0802-biblio:p0801-beol__comment knoraType=\"richtext_value\" mapping_id=\"http://rdfh.ch/standoff/mappings/StandardMapping\">\n            <text xmlns=\"\">The most <strong>interesting</strong> article in <a class=\"salsah-link\" href=\"ref:math_intelligencer\">Math Intelligencer</a>.</text>\n        </p0802-biblio:p0801-beol__comment>\n        <p0802-biblio:endPage knoraType=\"richtext_value\">73</p0802-biblio:endPage>\n        <p0802-biblio:isPartOfJournal>\n            <p0802-biblio:Journal knoraType=\"link_value\" target=\"math_intelligencer\" linkType=\"ref\"/>\n        </p0802-biblio:isPartOfJournal>\n        <p0802-biblio:journalVolume knoraType=\"richtext_value\">27</p0802-biblio:journalVolume>\n        <p0802-biblio:publicationHasAuthor>\n            <p0801-beol:person knoraType=\"link_value\" linkType=\"ref\" target=\"abel\"/>\n        </p0802-biblio:publicationHasAuthor>\n        <p0802-biblio:publicationHasAuthor>\n            <p0801-beol:person knoraType=\"link_value\" linkType=\"ref\" target=\"holmes\"/>\n        </p0802-biblio:publicationHasAuthor>\n        <p0802-biblio:publicationHasDate knoraType=\"date_value\">GREGORIAN:1976</p0802-biblio:publicationHasDate>\n        <p0802-biblio:publicationHasTitle knoraType=\"richtext_value\">Strings in the 16th and 17th Centuries</p0802-biblio:publicationHasTitle>\n        <p0802-biblio:publicationHasTitle knoraType=\"richtext_value\">An alternate title</p0802-biblio:publicationHasTitle>\n        <p0802-biblio:startPage knoraType=\"richtext_value\">48</p0802-biblio:startPage>\n    </p0802-biblio:JournalArticle>\n</knoraXmlImport:resources>\nThis illustrates several aspects of XML imports:\nThe root XML element must be knoraXmlImport:resources. There is an XML namespace corresponding each ontology used in the import. These namespaces can be found in the XML schema files returned by the Knora API server. We have copied and pasted xmlns=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1#\" from the main XML schema, p0802-biblio.xsd. This enables the Knora API server to identify the main ontology we are using. We have used xsi:schemaLocation to indicate the main schema’s namespace and filename. If we put our XML document in the same directory as the schemas, and we run an XML validator to check the XML, it should load the schemas. The child elements of knoraXmlImport:resources represent resources to be created. The order of these elements is unimportant. Each resource must have an ID, which must be an XML NCName, and must be unique within the file. These IDs are used only during the import, and will not be stored in the triplestore. The first child element of each resource must be a knoraXmlImport:label, which will be stored as the resource’s rdfs:label. Optionally, the second child element of a resource can provide metadata about a file to be attached to the resource (see bulk-import-with-digital-representations). The remaining child elements of each resource represent its property values. These must be sorted in alphabetical order by property name. If a property has mutliple values, these are represented as multiple adjacent property elements. The type of each value must be specified using the attribute knoraType. A link to another resource described in the XML import is represented as a child element of a property element, with attributes knoraType=\"link_value\" and linkType=\"ref\", and a target attribute containing the ID of the target resource. There is a specfic syntax for referring to properties from other ontologies. In the example, p0801-beol:comment is defined in the ontology http://www.knora.org/ontology/0001/beol. In the XML, we refer to it as p0802-biblio:p0801-beol__comment. A text value can contain XML markup. If it does: The text value element must have the attribute mapping_id, specifying a mapping from XML to standoff markup (see XML-to-standoff-mapping). It is necessary to specify the appropriate XML namespace (in this case the null namespace, xmlns=\"\") for the XML markup in the text value. The XML markup in the text value will not be validated by the schema. In an XML tag that is mapped to a standoff link tag, the link target can refer either to the IRI of a resoruce that already exists in the triplestore, or to the ID of a resource described in the import. If a link points to a resource described in the import, the ID of the target resource must be prefixed with ref:. In the example above, using the standard mapping, the standoff link to math_intelligencer has the target ref:math_intelligencer.\nTo create these resources, we use the following route, specifying the IRI of the project in which the resources should be created:\nHTTP POST to http://host/v1/resources/xmlimport/projectIRI","title":"Generate XML"},{"location":"/03-webapi/api-v1/adding-resources.html#bulk-import-with-links-to-existing-resources","text":"Having run the import in the previous example, we can import more data with links to the data that is now in the triplestore:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<knoraXmlImport:resources xmlns=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1#\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1# p0802-biblio.xsd\"\n    xmlns:p0802-biblio=\"http://api.knora.org/ontology/0802/biblio/xml-import/v1#\"\n    xmlns:p0801-beol=\"http://api.knora.org/ontology/0801/beol/xml-import/v1#\"\n    xmlns:knoraXmlImport=\"http://api.knora.org/ontology/knoraXmlImport/v1#\">\n    <p0802-biblio:JournalArticle id=\"strings_in_the_18th_century\">\n        <knoraXmlImport:label>Strings in the 18th Century</knoraXmlImport:label>\n        <p0802-biblio:p0801-beol__comment knoraType=\"richtext_value\" mapping_id=\"http://rdfh.ch/standoff/mappings/StandardMapping\">\n            <text xmlns=\"\">The most <strong>boring</strong> article in <a class=\"salsah-link\" href=\"http://rdfh.ch/biblio/QMDEHvBNQeOdw85Z2NSi9A\">Math Intelligencer</a>.</text>\n        </p0802-biblio:p0801-beol__comment>\n        <p0802-biblio:endPage knoraType=\"richtext_value\">76</p0802-biblio:endPage>\n        <p0802-biblio:isPartOfJournal>\n            <p0802-biblio:Journal knoraType=\"link_value\" linkType=\"iri\" target=\"http://rdfh.ch/biblio/QMDEHvBNQeOdw85Z2NSi9A\"/>\n        </p0802-biblio:isPartOfJournal>\n        <p0802-biblio:journalVolume knoraType=\"richtext_value\">27</p0802-biblio:journalVolume>\n        <p0802-biblio:publicationHasAuthor>\n            <p0801-beol:person knoraType=\"link_value\" linkType=\"iri\" target=\"http://rdfh.ch/biblio/c-xMB3qkRs232pWyjdUUvA\"/>\n        </p0802-biblio:publicationHasAuthor>\n        <p0802-biblio:publicationHasDate knoraType=\"date_value\">GREGORIAN:1977</p0802-biblio:publicationHasDate>\n        <p0802-biblio:publicationHasTitle knoraType=\"richtext_value\">Strings in the 18th Century</p0802-biblio:publicationHasTitle>\n        <p0802-biblio:startPage knoraType=\"richtext_value\">52</p0802-biblio:startPage>\n    </p0802-biblio:JournalArticle>\n</knoraXmlImport:resources>\nNote that in the link elements referring to existing resources, the linkType attribute has the value iri, and the target attribute contains the IRI of the target resource.","title":"Bulk Import with Links to Existing Resources"},{"location":"/03-webapi/api-v1/adding-resources.html#bulk-import-of-resources-with-digital-representations","text":"To attach a digital representation to a resource, we must provide the element knoraXmlImport:file before the property elements. In this element, we must give the absolute filesystem path to the file that should be attached to the resource, along with its MIME type:\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<knoraXmlImport:resources xmlns=\"http://api.knora.org/ontology/incunabula/xml-import/v1#\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://api.knora.org/ontology/incunabula/xml-import/v1# incunabula.xsd\"\n    xmlns:incunabula=\"http://api.knora.org/ontology/incunabula/xml-import/v1#\"\n    xmlns:knoraXmlImport=\"http://api.knora.org/ontology/knoraXmlImport/v1#\">\n    <incunabula:book id=\"test_book\">\n        <knoraXmlImport:label>a book with one page</knoraXmlImport:label>\n        <incunabula:title knoraType=\"richtext_value\">the title of a book with one page</incunabula:title>\n    </incunabula:book>\n    <incunabula:page id=\"test_page\">\n        <knoraXmlImport:label>a page with an image</knoraXmlImport:label>\n        <knoraXmlImport:file path=\"/usr/local/share/import-images/incunabula/12345.tiff\" mimetype=\"image/tiff\"/>\n        <incunabula:origname knoraType=\"richtext_value\">Chlaus</incunabula:origname>\n        <incunabula:pagenum knoraType=\"richtext_value\">1a</incunabula:pagenum>\n        <incunabula:partOf>\n            <incunabula:book knoraType=\"link_value\" linkType=\"ref\" ref=\"test_book\"/>\n        </incunabula:partOf>\n        <incunabula:seqnum knoraType=\"int_value\">1</incunabula:seqnum>\n    </incunabula:page>\n</knoraXmlImport:resources>\nDuring the processing of the bulk import, the Knora API server will communicate the location of file to Sipi, which will convert it to JPEG 2000 for storage.","title":"Bulk Import of Resources with Digital Representations"},{"location":"/03-webapi/api-v1/reading-values.html","text":"","title":"Reading Values"},{"location":"/03-webapi/api-v1/reading-values.html#reading-values","text":"In order to get an existing value, the HTTP method GET has to be used. The request has to be sent to the Knora server using the values path segment. Reading values may require authentication since some resources may have restricted viewing permissions.","title":"Reading Values"},{"location":"/03-webapi/api-v1/reading-values.html#reading-a-value","text":"The representation of a value can be obtained by making a GET request providing the value’s IRI:\nHTTP GET to http://host/v1/values/valueIRI\nIn the response, the value’s type and value are returned (see TypeScript interface valueResponse in module valueResponseFormats).","title":"Reading a Value"},{"location":"/03-webapi/api-v1/reading-values.html#getting-a-values-version-history","text":"In order to get the history of a value (its current and previous versions), the IRI of the resource it belongs to, the IRI of the property type that connects the resource to the value, and its current value IRI have to be submitted. Each of these elements is appended to the URL and separated by a slash. Please note that all of these have to be URL encoded.\nAdditionally to values, the path segment history has to be used:\nHTTP GET to http://host/v1/values/history/resourceIRI/propertyTypeIRI/valueIRI\nIn the response, the value’s versions returned (see TypeScript interface valueVersionsResponse in module valueResponseFormats).","title":"Getting a Value’s Version History"},{"location":"/03-webapi/api-v1/reading-values.html#getting-a-linking-value","text":"In order to get information about a link between two resources, the path segment links has to be used. The IRI of the source object, the IRI of the property type linking the the two objects, and the IRI of the target object have to be provided in the URL separated by slashes. Each of these has to be URL encoded.\nHTTP GET to http://host/links/sourceObjectIRI/linkingPropertyIRI/targetObjectIRI\nIn the response, information about the link is returned such as a reference count indicating how many links of the specified direction (source to target) and type (property) between the two objects exist (see TypeScript interface linkResponse in module valueResponseFormats).","title":"Getting a Linking Value"},{"location":"/03-webapi/api-v1/adding-values.html","text":"","title":"Adding a Value"},{"location":"/03-webapi/api-v1/adding-values.html#adding-a-value","text":"In order to add values to an existing resource, the HTTP method POST has to be used. The request has to be sent to the Knora server using the values path segment. Creating values requires authentication since only known users may add values.","title":"Adding a Value"},{"location":"/03-webapi/api-v1/adding-values.html#adding-a-property-value","text":"In order to add a value to a resource, its property type, value, and project has to be indicated in the JSON. Also the IRI of the resource the new value belongs has to be provided in the JSON.\nHTTP POST to http://host/v1/values\nDepending on the type of the new value, one of the following formats (all TypeScript interfaces defined in module addValueFormats) has to be used in order to create a new value: addRichtextValueRequest addLinkValueRequest addIntegerValueRequest addDecimalValueRequest addBooleanValueRequest addUriValueRequest addDateValueRequest (see dateString in basicMessageComponents for the date format) addColorValueRequest addGeometryValueRequest addHierarchicalListValueRequest addintervalValueRequest addGeonameValueRequest","title":"Adding a Property Value"},{"location":"/03-webapi/api-v1/adding-values.html#response-on-value-creation","text":"When a value has been successfully created, Knora sends back a JSON with the new value’s IRI. The value IRI identifies the value and can be used to perform future Knora API V1 operations.\nThe JSON format of the response is described in the TypeScript interface addValueResponse in module addValueFormats.","title":"Response on Value Creation"},{"location":"/03-webapi/api-v1/changing-values.html","text":"","title":"Changing a Value"},{"location":"/03-webapi/api-v1/changing-values.html#changing-a-value","text":"To add values to an existing resource, the HTTP method PUT has to be used. Changing values requires authentication since only known users may change values.","title":"Changing a Value"},{"location":"/03-webapi/api-v1/changing-values.html#modifying-a-property-value","text":"The request has to be sent to the Knora server using the values path segment followed by the value’s IRI:\nHTTP PUT to http://host/values/valueIRI\nThe value IRI has to be URL-encoded.\nTo change an existing value (creating a new version of it), the value’s current IRI and its new value have to be submitted as JSON in the HTTP body.\nDepending on the type of the new value, one of the following formats has to be used in order to create a new value (all these TypeScript interfaces are defined in module changeValueFormats):\nchangeRichtextValueRequest changeLinkValueRequest changeIntegerValueRequest changeDecimalValueRequest changeBooleanValueRequest changeUriValueRequest changeDateValueRequest changeColorValueRequest changeGeometryValueRequest changeHierarchicalListValueRequest changeIntervalValueRequest changeGeonameValueRequest","title":"Modifying a Property Value"},{"location":"/03-webapi/api-v1/changing-values.html#modifying-a-file-value","text":"In order to exchange a file value (digital representation of a resource), the path segment filevalue has to be used. The IRI of the resource whose file value is to be exchanged has to be appended:\nHTTP PUT to http://host/filevalue/resourceIRI\nPlease note that the resource IRI has to be URL encoded.\nThere are two ways to change a file of a resource: Either by submitting directly the binaries of the file in a HTTP Multipart request or by indicating the location of the file. The two cases are referred to as non-GUI case and GUI case (TODO: add a link to “Sipi and Knora”).","title":"Modifying a File Value"},{"location":"/03-webapi/api-v1/changing-values.html#including-the-binaries-non-gui-case-","text":"Here, a HTTP MULTIPART request has to be made simply providing the binaries (without JSON):\n#!/usr/bin/env python3\n\nimport requests, json, urllib\n\n# the name of the file to be submitted\nfilename = 'myimage.tif'\n\n# a tuple containing the file's name, its binaries and its mimetype\nfiles = {'file': (filename, open(filename, 'rb'), \"image/tiff\")}\n\nresIri = urllib.parse.quote_plus('http://data.knora.org/xy')\n\nr = requests.put(\"http://host/filevalue/\" + resIri,\n                 files=files)\nPlease note that the file has to be read in binary mode (by default it would be read in text mode).","title":"Including the binaries (non-GUI case)"},{"location":"/03-webapi/api-v1/changing-values.html#indicating-the-location-of-a-file-gui-case-","text":"Here, simply the location of the new file has to be submitted as JSON. The JSON format is described in the TypeScript interface changeFileValueRequest in module changeValueFormats. The request header’s content type has to set to application/json.","title":"Indicating the location of a file (GUI case)"},{"location":"/03-webapi/api-v1/changing-values.html#response-on-value-change","text":"When a value has been successfully changed, Knora sends back a JSON with the new value’s IRI. The value IRI identifies the value and can be used to perform future Knora API V1 operations.\nThe JSON format of the response is described in the TypeScript interface changeValueResponse in module changeValueFormats.","title":"Response on Value Change"},{"location":"/03-webapi/api-v1/delete-resources-and-values.html","text":"","title":"Deleting Resources and Values"},{"location":"/03-webapi/api-v1/delete-resources-and-values.html#deleting-resources-and-values","text":"Knora does not actually delete resources or values; it just marks them as deleted. To mark a resource or value as deleted, you must use the HTTP method DELETE has to be used. This requires authentication.","title":"Deleting Resources and Values"},{"location":"/03-webapi/api-v1/delete-resources-and-values.html#mark-a-resource-as-deleted","text":"The delete request has to be sent to the Knora server using the resources path segment.\nHTTP DELETE to http://host/resources/resourceIRI?deleteComment=String\nThe resource IRI must be URL-encoded. The deleteComment is an optional comment explaining why the resource is being marked as deleted.","title":"Mark a Resource as Deleted"},{"location":"/03-webapi/api-v1/delete-resources-and-values.html#mark-a-value-as-deleted","text":"The delete request has to be sent to the Knora server using the values path segment, providing the valueIRI:\nHTTP DELETE to http://host/values/valueIRI?deleteComment=String\nThe value IRI must be URL-encoded. The deleteComment is an optional comment explaining why the value is being marked as deleted.\nOnce a value has been marked as deleted, no new versions of it can be made.","title":"Mark a Value as Deleted"},{"location":"/03-webapi/api-v2/index.html","text":"","title":"Knora API v2"},{"location":"/03-webapi/api-v2/index.html#knora-api-v2","text":"Introduction: Using API V2 Knora IRIs Reading and Searching Resources XML to Standoff Mapping KnarQL: Knora Query Language Querying, Creating, and Updating Ontologies Response Formats","title":"Knora API v2"},{"location":"/03-webapi/api-v2/introduction.html","text":"","title":"Introduction: Using API V2"},{"location":"/03-webapi/api-v2/introduction.html#introduction-using-api-v2","text":"JSON-LD Support of schema.org Entities API Schema Knora IRIs V2 Path Segment\nVersion 2 of the Knora API aims to make both the response and request formats more generic and consistent. Version 1 was basically the result of the reimplementation of the existing API of the SALSAH prototype. Since the development of this prototype has a long history and the specification of API V1 was an evolving process, V1 has various inconsistencies and peculiarities. With V2, we would like to offer a format that is consistent and hence easier to use for a client.\nPlease note that V2 is still in development. We do not yet recommend using it on productive systems.","title":"Introduction: Using API V2"},{"location":"/03-webapi/api-v2/introduction.html#json-ld","text":"Our preferred format for data exchange is JSON-LD. JSON-LD allows the Knora API server to provide responses that are relatively easy for automated processes to interpret, since their structure and semantics is explicitly defined. For example, each project-specific Knora resource property is identified by an IRI, which can be dereferenced to get more information about it (e.g. its label in different languages). Moreover, each value has a type represented by an IRI. These are either standard RDF types (e.g. XSD datatypes) or more complex types whose IRIs can be dereferenced to get more information about their structure.\nAt the same time, JSON-LD responses are relatively easy for software developers to work with. Items in a response can have human-readable names, which can nevertheless be expanded to full IRIs. Also, while a format such as Turtle just provides a set of RDF triples, an equivalent JSON-LD response can explicitly provide data in a hierarchical structure, with objects nested inside other objects.\nWe designed the V2 routes in a way that would also allow for the usage of other formats such as XML. We plan to implement support for XML once the implementation of JSON-LD is completed. The client will be able to use content negotiation to specify the preferred exchange format.","title":"JSON-LD"},{"location":"/03-webapi/api-v2/introduction.html#support-of-schema-org-entities","text":"In our API responses (e.g., ResourcesSequence, see Response Formats), we use entities defined in schema.org.\nOur intent is that any client familiar with schema.org should be able to understand our response format.\nA resource’s rdfs:label is represented as a http://schema.org/name although they might not be equivalent in a strict sense (see schemaorg#1762).\nLikewise, knora-api:Resource is declared to be a subclass of http://schema.org/Thing, so we can use a knora-api:Resource or any of its subclasses where http://schema.org requires a http://schema.org/Thing.","title":"Support of schema.org Entities"},{"location":"/03-webapi/api-v2/introduction.html#api-schema","text":"Knora API V2 offers the query and response format in a complex schema and a simple one. The main difference is that the complex schema exposes the complexity of value objects, while the simple version does not. A client that needs to edit values must use the complex schema in order to obtain the IRI of each value. A client that reads but does not update data can use the simplified schema.\nIn either case, the client deals only with data whose structure and semantics are defined by Knora API ontologies, which are distinct from the ontologies that are used to store date in the triplestore. The Knora API server automatically converts back and forth between these internal and external representations. This approach encapsulates the internals and adds a layer of abstraction to them. The client will be able to use content negotiation to specify its preferred exchange format. For more information, see Querying, Creating, and Updating Ontologies.","title":"API Schema"},{"location":"/03-webapi/api-v2/introduction.html#knora-iris","text":"Resources and entities are identified by IRIs. The format of these IRIs is explained in Knora IRIs.","title":"Knora IRIs"},{"location":"/03-webapi/api-v2/introduction.html#v2-path-segment","text":"Every request to API V1 includes v2 as a path segment, e.g. http://host/v2/resources/http%3A%2F%2Frdfh.ch%2Fc5058f3a. Accordingly, requests using any other version of the API will require another path segment.","title":"V2 Path Segment"},{"location":"/03-webapi/api-v2/knora-iris.html","text":"","title":"Knora IRIs"},{"location":"/03-webapi/api-v2/knora-iris.html#knora-iris","text":"Project Short-Codes IRIs for Ontologies and Ontology Entities Internal Ontology IRIs External Ontology IRIs Ontology Entity IRIs IRIs for Data Knora Resource Permalinks\nThe IRIs used in Knora repositories and in the Knora API v2 follow certain conventions.","title":"Knora IRIs"},{"location":"/03-webapi/api-v2/knora-iris.html#project-short-codes","text":"A project short-code is a hexadecimal number of at least four digits, assigned by the DaSCH to uniquely identify a Knora project regardless of where it is hosted. Project short-codes are currently optional. It is recommended that new projects request a project code and use it in their ontology IRIs, to avoid possible future naming conflicts.\nThe range of project IDs from 0001 to 00FF inclusive is reserved for local testing, and also the ID 0000 is reserved for future use by the system. Thus, the first useful project will be 0100.\nIn the beginning, Unil will use the IDs 0100 to 07FF, and Unibas 0800 to 08FF.","title":"Project Short-Codes"},{"location":"/03-webapi/api-v2/knora-iris.html#iris-for-ontologies-and-ontology-entities","text":"","title":"IRIs for Ontologies and Ontology Entities"},{"location":"/03-webapi/api-v2/knora-iris.html#internal-ontology-iris","text":"Starting with Knora API v2, Knora makes a distinction between internal and external ontologies. Internal ontologies are used in the triplestore, while external ontologies are used in the API. For each internal ontology, there is a corresponding external ontology. Some internal ontologies are built into Knora, while others are project-specific. The Knora API server automatically generates external ontologies based on project-specific internal ontologies.\nEach internal ontology has an IRI, which is also the IRI of the named graph that contains the ontology in the triplestore. An internal project-specific ontology IRI has the form:\nhttp://www.knora.org/ontology/PROJECT_SHORTCODE/ONTOLOGY_NAME\nFor example, the ontology IRI based on project code 0001 and ontology name example would be:\nhttp://www.knora.org/ontology/0001/example\nAn ontology name must be a valid XML NCName. The following names are reserved for built-in internal Knora ontologies:\nknora-base standoff salsah-gui\nNames starting with knora are reserved for future built-in Knora ontologies. A project-specific ontology name may not start with the letter v followed by a digit, and may not contain these reserved words:\nknora ontology simple","title":"Internal Ontology IRIs"},{"location":"/03-webapi/api-v2/knora-iris.html#external-ontology-iris","text":"Unlike internal ontology IRIs, external ontology IRIs are meant to be dereferenced as URLs. When an ontology IRI is dereferenced, the ontology itself can be served either in a machine-readable format or as human-readable documentation.\nThe IRI of an external Knora ontology has the form:\nhttp://HOST[:PORT]/ontology/PROJECT_SHORTCODE/ONTOLOGY_NAME/API_VERSION\nFor built-in ontologies, the host is always api.knora.org. Otherwise, the hostname and port configured in application.conf under app.http.knora-api.host and app.http.knora-api.http-port are used (the port is omitted if it is 80).\nThis means that when a built-in external ontology IRI is dereferenced, the ontology can be served by a Knora API server running at api.knora.org. When a project-specific external ontology IRI is dereferenced, the ontology can be served by the Knora API server that hosts the project. During development and testing, this could be localhost.\nThe name of an external ontology is the same as the name of the corresponding internal ontology, with one exception: the external form of knora-base is called knora-api.\nThe API version identifier indicates not only the version of the API, but also an API ‘schema’. The Knora API v2 is available in two schemas:\nA default schema, which is suitable both for reading and for editing data. The default schema represents values primarily as complex objects. Its version identifier is v2. A simple schema, which is suitable for reading data but not for editing it. The simple schema facilitates interoperability between Knora ontologies and non-Knora ontologies, since it represents values primarily as literals. Its version identifier is simple/v2.\nOther schemas could be added in the future for more specific use cases.\nWhen requesting an ontology, the client requests a particular schema. (This will also be true of most Knora API v2 requests: the client will be able to specify which schema the response should be provided in.)\nFor example, suppose a Knora API server is running at knora.example.org and hosts an ontology whose internal IRI is http://www.knora.org/ontology/0001/example. That ontology can then be requested using either of these IRIs:\nhttp://knora.example.org/ontology/0001/example/v2 (for the default schema) http://knora.example.org/ontology/0001/example/simple/v2 (for the simple schema)\nWhile the internal example ontology refers to definitions in knora-base, the external example ontology that is served by the API refers instead to a knora-api ontology, whose IRI depends on the schema being used:\nhttp://api.knora.org/ontology/knora-api/v2 (for the default schema) http://api.knora.org/ontology/knora-api/simple/v2 (for the simple schema)","title":"External Ontology IRIs"},{"location":"/03-webapi/api-v2/knora-iris.html#ontology-entity-iris","text":"Knora ontologies use ‘hash namespaces’ (see URI Namespaces). This means that the IRI of an ontology entity (a class or property definition) is constructed by adding a hash character (#) to the ontology IRI, followed by the name of the entity. In Knora, an entity name must be a valid XML NCName. Thus, if there is a class called ExampleThing in an ontology whose internal IRI is http://www.knora.org/ontology/0001/example, that class has the following IRIs:\nhttp://www.knora.org/ontology/0001/example#ExampleThing (in the internal ontology) http://HOST[:PORT]/ontology/0001/example/v2#ExampleThing (in the API v2 default schema) http://HOST[:PORT]/ontology/0001/example/simple/v2#ExampleThing (in the API v2 simple schema)","title":"Ontology Entity IRIs"},{"location":"/03-webapi/api-v2/knora-iris.html#iris-for-data","text":"Knora generates IRIs for data that it creates in the triplestore. Each generated data IRI contains one or more UUID identifiers to make it unique. To keep data IRIs relatively short, each UUID is Base64 encoded, using the ‘URL and Filename safe Base64 Alphabet’ specified in Table 2 of RFC 4648, without padding; thus each UUID is a 22-character string.\nData IRIs are not currently intended to be dereferenced as URLs. Instead, each Knora resource will have a corresponding ARK URL, which will be handled by a server that redirects requests to the relevant Knora API server (see Knora Resource Permalinks). However, every generated data IRI begins with http://rdfh.ch. This domain is not currently used, but it is owned by the DaSCH, so it would be possible to make resource IRIs directly dereferenceable in the future.\nThe formats of generated data IRIs for different types of objects are as follows:\nResource: http://rdfh.ch/PROJECT_SHORTCODE/RESOURCE_UUID. The current implementation actually uses the project shortname, but it will be changed to use the project code (#654). Value: http://rdfh.ch/PROJECT_SHORTCODE/RESOURCE_UUID/values/VALUE_UUID Standoff tag: http://rdfh.ch/PROJECT_SHORTCODE/RESOURCE_UUID/values/VALUE_UUID/STANDOFF_UUID XML-to-standoff mapping: http://rdfh.ch/PROJECT_SHORTCODE/mappings/MAPPING_NAME XML-to-standoff mapping element: http://rdfh.ch/PROJECT_SHORTCODE/mappings/MAPPING_NAME/elements/MAPPING_ELEMENT_UUID Project: http://rdfh.ch/projects/PROJECT_SHORTCODE Group: http://rdfh.ch/groups/PROJECT_SHORTCODE/GROUP_UUID Permission: http://rdfh.ch/permissions/PROJECT_SHORTCODE/PERMISSION_UUID Lists: http://rdfh.ch/lists/PROJECT_SHORTCODE/LIST_UUID User: http://rdfh.ch/users/USER_UUID","title":"IRIs for Data"},{"location":"/03-webapi/api-v2/knora-iris.html#knora-resource-permalinks","text":"TODO: document the use of ARK permalinks for Knora resources.","title":"Knora Resource Permalinks"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html","text":"","title":"Reading and Searching Resources"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#reading-and-searching-resources","text":"Get the Representation of a Resource by its IRI Get a Full Representation of a Resource by its IRI Get the preview of a resource by its IRI Search for Resources Search for a Resource by its rdfs:label Full-text Search Extended Search Count Queries\nTo retrieve an existing resource, the HTTP method GET has to be used. Reading resources may require authentication, since some resources may have restricted viewing permissions.","title":"Reading and Searching Resources"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#get-the-representation-of-a-resource-by-its-iri","text":"","title":"Get the Representation of a Resource by its IRI"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#get-a-full-representation-of-a-resource-by-its-iri","text":"A full representation of resource can be obtained by making a GET request to the API providing its IRI. Because a Knora IRI has the format of a URL, its IRI has to be URL-encoded.\nTo get the resource with the IRI http://data.knora.org/c5058f3a (a book from the sample Incunabula project, which is included in the Knora API server’s test data), make a HTTP GET request to the resources route (path segment resources in the API call) and append the URL-encoded IRI:\nHTTP GET to http://host/v2/resources/http%3A%2F%2Fdata.knora.org%2Fc5058f3a\nIf necessary, several resources can be queried at the same time, their IRIs separated by slashes. Please note that the amount of resources that can be queried in one requested is limited. See the settings for app/v2 in application.conf.\nMore formally, the URL looks like this:\nHTTP GET to http://host/v2/resources/resourceIRI(/anotherResourceIri)*\nThe response to a resource request is a ResourcesSequence (see Response Formats).","title":"Get a Full Representation of a Resource by its IRI"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#get-the-preview-of-a-resource-by-its-iri","text":"In some cases, the client may only want to request the preview of a resource, which just provides its rdfs:label and type.\nThis works exactly like making a conventional resource request, using the path segment resourcespreview:\nHTTP GET to http://host/v2/resourcespreview/resourceIRI(/anotherResourceIri)*\nThe response to a resource preview request is a ResourcesSequence (see Response Formats).","title":"Get the preview of a resource by its IRI"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#search-for-resources","text":"","title":"Search for Resources"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#search-for-a-resource-by-its-rdfs-label","text":"Knora offers the possibility to search for resources by their rdfs:label. The use case for this search is to find a specific resource as you type. E.g., the user wants to get a list of resources whose rdfs:label contain some search terms separated by a whitespace character:\nZeit Zeitg … Zeitglöcklein d … Zeitglöcklein des Lebens\nWith each character added to the last term, the selection gets more specific. The first term should at least contain four characters. To make this kind of “search as you type” possible, a wildcard character is automatically added to the last search term.\nHTTP GET to http://host/v2/searchbylabel/searchValue[limitToResourceClass=resourceClassIRI]\n[limitToProject=projectIRI][offset=Integer]\nThe first parameter must be preceded by a question mark ?, any following parameter by an ampersand &.\nThe default value for the parameter offset is 0, which returns the first page of search results. Subsequent pages of results can be fetched by increasing offset by one. The amount of results per page is defined in app/v2 in application.conf.\nThe response to a label search request is a ResourcesSequence (see Response Formats).\nFor performance reasons, standoff markup is not queried for this route.","title":"Search for a Resource by its rdfs:label"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#full-text-search","text":"Knora offers a full-text search that searches through all textual representations of values and rdfs:label of resources. You can separate search terms by a white space character and they will be combined using the Boolean AND operator. Please note that the search terms have to be URL-encoded.\nHTTP GET to http://host/v2/search/searchValue[limitToResourceClass=resourceClassIRI][limitToProject=projectIRI][offset=Integer]\nPlease note that the first parameter has to be preceded by a question mark ?, any following parameter by an ampersand &.\nThe default value for the parameter offset is 0 which returns the first page of search results. Subsequent pages of results can be fetched by increasing offset by one. The amount of results per page is defined in app/v2 in application.conf.\nThe response to a full-text search request is a ResourcesSequence (see Response Formats).","title":"Full-text Search"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#extended-search","text":"For more complex queries than a full-text search, Knora offers extended search possibilities, enabling clients to search for resources with arbitrary characteristics, as well as for a graph of resources that are interconnected in some particular way. To do this, the client submits a query in KnarQL (Knora Query Language), which is based on SPARQL (see KnarQL: Knora Query Language). The Knora API server pages the results, filters them to ensure that permissions are respected, and returns them in a Knora API format (currently only JSON-LD).\nA KnarQL query can be URL-encoded and sent in a GET request to the extended search route.\nHTTP GET to http://host/v2/searchextended/KnarQLQuery\nIn the future, POST requests will also be supported, to allow longer queries. See KnarQL: Knora Query Language for detailed information about the query syntax and examples.\nThe response to an extended search request is a ResourcesSequence (see Response Formats).","title":"Extended Search"},{"location":"/03-webapi/api-v2/reading-and-searching-resources.html#count-queries","text":"For both full full-text and KnarQL searches, a count query can be performed. The answer of a count query is the number of resources (a number) that matched the indicated search criteria without taking into consideration permissions. This means that the client may not be able to access any of the resources matching the search criteria because of insufficient permissions. Insufficient permissions are intended to prevent a user from accessing a resource or any of its values, or even knowing about its IRI, but not to suppress information about the existence of such a resource.\nIn order to perform a count query, just append the segment count:\nHTTP GET to http://host/v2/searchbylabel/count/searchValue[limitToResourceClass=resourceClassIRI][limitToProject=projectIRI][offset=Integer]\n\nHTTP GET to http://host/v2/search/count/searchValue[limitToResourceClass=resourceClassIRI][limitToProject=projectIRI][offset=Integer]\n\nHTTP GET to http://host/v2/searchextended/count/KnarQLQuery\nThe first parameter has to be preceded by a question mark ?, and any following parameter by an ampersand &.\nThe response to a count query request is a ResourcesSequence (see Response Formats).","title":"Count Queries"},{"location":"/03-webapi/api-v2/xml-to-standoff-mapping.html","text":"","title":"XML to Standoff Mapping"},{"location":"/03-webapi/api-v2/xml-to-standoff-mapping.html#xml-to-standoff-mapping","text":"General Information Validating a Mapping and sending it to Knora","title":"XML to Standoff Mapping"},{"location":"/03-webapi/api-v2/xml-to-standoff-mapping.html#general-information","text":"Please see v1 documentation for general information about the XML to standoff mapping: XML To Standoff Mapping v1.","title":"General Information"},{"location":"/03-webapi/api-v2/xml-to-standoff-mapping.html#validating-a-mapping-and-sending-it-to-knora","text":"A mapping can be validated before sending it to Knora with the following XML Schema file: webapi/src/resources/mappingXMLToStandoff.xsd. Any mapping that does not conform to this XML Schema file will be rejected by Knora.\nThe mapping has to be sent as a multipart request to the standoff route using the path segment mapping:\nHTTP POST http://host/v2/mapping\nThe multipart request consists of two named parts:\n\"json\":\n\n  {\n      \"knora-api:mappingHasName\": \"My Mapping\",\n      \"knora-api:attachedToProject\": \"projectIRI\",\n      \"rdfs:label\": \"MappingNameSegment\",\n      \"@context\": {\n          \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n          \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n      }\n  }\n\n\"xml\":\n\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <mapping>\n      ...\n  </mapping>\nA successful response returns the Iri of the mapping. However, the Iri of a mapping is predictable: it consists of the project Iri followed by /mappings/ and the knora-api:mappingHasName submitted in the JSON-LD (if the name already exists, the request will be rejected). Once created, a mapping can be used to create TextValues in Knora. The formats are documented in the v2 typescript interfaces AddMappingRequest and AddMappingResponse in module MappingFormats","title":"Validating a Mapping and sending it to Knora"},{"location":"/03-webapi/api-v2/query-language.html","text":"","title":"KnarQL: Knora Query Language"},{"location":"/03-webapi/api-v2/query-language.html#knarql-knora-query-language","text":"Basic Concept Main and Dependent Resources Graph Patterns and Result Graphs Permission Checking Inference API Schema KnarQL Syntax WHERE Clause Supported SPARQL Syntax Resources Properties Values Required Type Annotations Property Types Value Property Types Linking Property Types Value Types CONSTRUCT Clause Marking the Main Resource KnarQL by Example Getting all the Components of a Compound resource","title":"KnarQL: Knora Query Language"},{"location":"/03-webapi/api-v2/query-language.html#basic-concept","text":"KnarQL is intended to offer the advantages of SPARQL endpoints (particularly the ability to perform queries using complex search criteria) while avoiding their drawbacks in terms of performance and security (see The Enduring Myth of the SPARQL Endpoint). It also has the benefit of enabling clients to work with a simpler RDF data model than the one Knora actually uses to store data in the triplestore, and makes it possible to provide better error-checking.\nRather than being processed directly by the triplestore, a KnarQL query is interpreted by the Knora API server, which enforces certain restrictions on the query, and implements paging and permission checking. The API server generates SPARQL based on the KnarQL query submitted, queries the triplestore, filters the results according to the user’s permissions, and returns each page of query results as a Knora API response. Thus, KnarQL is a hybrid between a RESTful API and a SPARQL endpoint.\nA KnarQL query conforms to a subset of the syntax of a SPARQL CONSTRUCT query, with some additional restrictions and functionality. In particular, the variable representing the top-level (or ‘main’) resource that will appear in each search result must be identified, statements must be included to specify the types of the entities being queried, OFFSET is used to control paging, and ORDER BY is used to sort the results.\nIt is certainly possible to write KnarQL queries by hand, but we expect that in general, they will be automatically generated by client software, e.g. by a client user interface.","title":"Basic Concept"},{"location":"/03-webapi/api-v2/query-language.html#main-and-dependent-resources","text":"The main resource is the top-level resource in a search result. Other resources that are in some way connected to the main resource are referred to as dependent resources. If the client asks for a resource A relating to a resource B, then all matches for A will be presented as main resources and those for B as dependent resources.","title":"Main and Dependent Resources"},{"location":"/03-webapi/api-v2/query-language.html#graph-patterns-and-result-graphs","text":"The WHERE clause of a KnarQL query specifies a graph pattern. Each query result will match this graph pattern, and will have the form of a graph whose starting point is a main resource. The query’s graph pattern, and hence each query result graph, can span zero more levels of relations between resources. For example, a query could request articles by authors who were students of a particular professor. Or authors of texts that refer to events that took place within a certain date range.","title":"Graph Patterns and Result Graphs"},{"location":"/03-webapi/api-v2/query-language.html#permission-checking","text":"Each matching resource is returned only if the client has permission to see all the values of that resource that matched the criteria given in the WHERE clause. If a matching resource contains a value that was mentioned in the WHERE clause, but the client does not have permission to see that value, the resource is not returned in the results, and is instead replaced by a proxy resource called knora-api:ForbiddenResource.","title":"Permission Checking"},{"location":"/03-webapi/api-v2/query-language.html#inference","text":"KnarQL queries are understood to imply RDFS reasoning. Depending on the triplestore being used, this may be implemented using the triplestore’s own reasoner or by query expansion in the Knora API server (using SPARQL property path syntax). This means that if a statement pattern specifies a property, the pattern will also match subproperties of that property.","title":"Inference"},{"location":"/03-webapi/api-v2/query-language.html#api-schema","text":"A KnarQL query must be written using the Knora API simple schema (see Querying, Creating, and Updating Ontologies). However, results can be returned in the simple or complex schema. (The ability to choose the response schema is not yet implemented, so for now, results are always returned in the complex schema.)","title":"API Schema"},{"location":"/03-webapi/api-v2/query-language.html#knarql-syntax","text":"Every KnarQL query is a valid SPARQL 1.1 CONSTRUCT query. However, KnarQL only supports a subset of the elements that can be used in a SPARQL Construct query. Additionally, KnarQL requires the client to use explicit type annotations, explained below; these are valid SPARQL, but specific to the Knora API. Also, the main resource has to be marked.","title":"KnarQL Syntax"},{"location":"/03-webapi/api-v2/query-language.html#where-clause","text":"The WHERE clause specifies a graph pattern to be matched, i.e. the search criteria. Resources that match the given criteria, and that the client has permission to see, will be returned.","title":"WHERE Clause"},{"location":"/03-webapi/api-v2/query-language.html#supported-sparql-syntax","text":"The current version of KnarQL accepts CONSTRUCT queries whose WHERE clauses use the following patterns, with the specified restrictions:\nOPTIONAL: cannot be nested in an OPTIONAL or UNION. UNION: cannot be nested in an OPTIONAL or UNION. FILTER: may contain a complex expression using the Boolean operators AND and OR, as well as comparison operators. The left argument of a comparison operator must be a query variable. FILTER NOT EXISTS OFFSET: the OFFSET is needed for paging. It does not actually refer to the number of triples to be returned, but to the requested page of results. The default value is 0, which refers to the first page of results. The number of results per page is defined in app/v2 in application.conf. ORDER BY: In SPARQL, the result of a Construct query is an unordered set of triples. However, a KnarQL query returns an ordered list of resources, which can be ordered by the values of specified properties.","title":"Supported SPARQL Syntax"},{"location":"/03-webapi/api-v2/query-language.html#resources","text":"Resources can be represented by an IRI or a query variable.","title":"Resources"},{"location":"/03-webapi/api-v2/query-language.html#properties","text":"Properties can be represented by an IRI or a query variable. If a property is represented by a query variable, it can be restricted to certain property IRIs using a FILTER.","title":"Properties"},{"location":"/03-webapi/api-v2/query-language.html#values","text":"Values can only be represented by a query variable. Value literals are currently not supported as the objects of statement patterns in the query. To restrict a value, a FILTER must be used. Without a FILTER, all the instances of a value are returned.","title":"Values"},{"location":"/03-webapi/api-v2/query-language.html#required-type-annotations","text":"Resources, properties, and values must be accompanied by explicit type annotation statements. (In a future version, this type information could be inferred rather than explicitly given in the query.)\nThere are two type annotation properties:\nknora-api:objectType: indicates the type of value or resource that a property points to. rdf:type: indicates the type of a resource or value.","title":"Required Type Annotations"},{"location":"/03-webapi/api-v2/query-language.html#property-types","text":"A property may point either to a value or to a resource. In the first case, it is called a value property, in the second case a linking property. The type annotation property knora-api:objectType indicates the type of value or resource the property points to.","title":"Property Types"},{"location":"/03-webapi/api-v2/query-language.html#value-property-types","text":"Supported value property types:\nxsd:string xsd:integer xsd:decimal xsd:boolean knora-api:Date knora-api:StillImageFile knora-api:Geom","title":"Value Property Types"},{"location":"/03-webapi/api-v2/query-language.html#linking-property-types","text":"A linking property has to be annotated with the type knora-api:Resource. Since inference is assumed, this matches any resource. To restrict the types of resources, additional statements can be made using rdfs:type. The linking property can also be restricted using a FILTER in case a query variable is used.","title":"Linking Property Types"},{"location":"/03-webapi/api-v2/query-language.html#value-types","text":"Value types are used to indicate the type of a value (rdf:type). KnarQL supports the following types of value instances:\nxsd:string xsd:integer xsd:decimal xsd:boolean knora-api:Date knora-api:StillImageFile knora-api:Geom\nHowever, not all of these types are supported in FILTERs to restrict values. Supported value types in FILTERs:\nxsd:string xsd:integer xsd:decimal xsd:boolean knora-api:Date","title":"Value Types"},{"location":"/03-webapi/api-v2/query-language.html#construct-clause","text":"The CONSTRUCT clause specifies which information the response should return. The CONSTRUCT clause must contain at least one statement, specifying knora-api:isMainResource. Any other statements in the CONSTRUCT clause must also be present in the WHERE clause.","title":"CONSTRUCT Clause"},{"location":"/03-webapi/api-v2/query-language.html#marking-the-main-resource","text":"In the CONSTRUCT clause of a KnarQL query, the variable representing the main resource that the user is interested in must be indicated with knora-api:isMainResource true. Exactly one variable representing a resource must be marked in this way.","title":"Marking the Main Resource"},{"location":"/03-webapi/api-v2/query-language.html#knarql-by-example","text":"In this section, we provide some sample queries of different complexity to illustrate the usage of KnarQL.","title":"KnarQL by Example"},{"location":"/03-webapi/api-v2/query-language.html#getting-all-the-components-of-a-compound-resource","text":"In order to get all the components of a compound resource, the following KnarQL query can be sent to the API.\nIn this case, the compound resource is an incunabula:book identified by the IRI http://data.knora.org/c5058f3a and the components are of type incunabula:page (test data for the Incunabula project). Since inference is assumed, we can use knora-api:StillImageRepresentation (incunabula:page is one of its subclasses). This makes the query more generic and allows for reuse (for instance, a client would like to query different types of compound resources defined in different ontologies).\nORDER BY is used to sort the components by their sequence number.\nOFFSET is set to 0 to get the first page of results.\nNote that in a KnarQL query, the prefix knora-api refers to the Knora-Api simple schema.\nPREFIX knora-api: <http://api.knora.org/ontology/knora-api/simple/v2#>\n\nCONSTRUCT {\n   ?component knora-api:isMainResource true . # marking of the component searched for as the main resource, required\n   ?component knora-api:seqnum ?seqnum . # return the sequence number in the response\n   ?component knora-api:hasStillImageFileValue ?file . # return the StillImageFile in the response\n} WHERE {\n   ?component a knora-api:Resource . # explicit type annotation for the component searched for, required\n   ?component a knora-api:StillImageRepresentation . # additional restriction of the type of component, optional\n\n   ?component knora-api:isPartOf <http://data.knora.org/c5058f3a> . # component relates to compound resource via this property\n   knora-api:isPartOf knora-api:objectType knora-api:Resource . # type annotation for linking property, required\n   <http://data.knora.org/c5058f3a> a knora-api:Resource . # type annotation for compound resource, required\n\n   ?component knora-api:seqnum ?seqnum . # component must have a sequence number, no further restrictions given\n   knora-api:seqnum knora-api:objectType xsd:integer . # type annotation for the value property, required\n   ?seqnum a xsd:integer . # type annotation for the sequence number, required\n\n   ?component knora-api:hasStillImageFileValue ?file . # component must have a StillImageFile, no further restrictions given\n   knora-api:hasStillImageFileValue knora-api:objectType knora-api:StillImageFile . # type annotation for the value property, required\n   ?file a knora-api:StillImageFile . # type annotation for the StillImageFile, required\n}\nORDER BY ASC(?seqnum) # order by sequence number, ascending\nOFFSET 0 #get first page of results\nThe incunabula:book with the IRI http://data.knora.org/c5058f3a has 402 pages (this result can be obtained by doing a count query, see Reading and Searching Resources). However, with OFFSET 0, only the first page of results is returned. The same query can be sent again with OFFSET 1 to get the next page of results, and so forth. When a page of results is not full (see settings in app/v2 in application.conf) or is empty, no more results are available.\nBy design, it is not possible for the client to get more than one page of results at a time; this is intended to prevent performance problems that would be caused by huge responses. A client that wants to download all the results of a query must request each page sequentially.\nLet’s assume the client is not interested in all of the book’s pages, but just in first ten of them. In that case, the sequence number can be restricted using a FILTER that is added to the query’s WHERE clause:\nFILTER (?seqnum <= 10)\nThe first page starts with sequence number 1, so with this FILTER only the first ten pages are returned.","title":"Getting all the Components of a Compound resource"},{"location":"/03-webapi/api-v2/ontology-information.html","text":"","title":"Querying, Creating, and Updating Ontologies"},{"location":"/03-webapi/api-v2/ontology-information.html#querying-creating-and-updating-ontologies","text":"Querying Ontology Information Querying Ontology Metadata Querying an Ontology JSON-LD Representation of an Ontology in the Simple Schema JSON-LD Representation of an Ontology in the Default Schema Ontology Updates Creating a New Ontology Changing an Ontology’s Metadata Deleting an Ontology Creating a Class Without Cardinalities Creating a Class With Cardinalities Changing the Labels of a Class Changing the Comments of a Class Creating a Property Changing the Labels of a Property Changing the Comments of a Property Adding Cardinalities to a Class Replacing the Cardinalities of a Class Deleting a Property Deleting a Class","title":"Querying, Creating, and Updating Ontologies"},{"location":"/03-webapi/api-v2/ontology-information.html#querying-ontology-information","text":"Before reading this document, you should have a basic understanding of Knora API v2 external ontology schemas (see Knora IRIs).\nKnora uses a single JSON-LD response format to represent ontology information, regardless of the request. Clients that update ontology information also submit their updates in this same format. The basic structure of this format is a JSON-LD document containing, at the top level, the property knora-api:hasOntologies, whose object can be a single ontology or an array of ontologies.\nThis response format uses prefixes to shorten IRIs, making them more human-readable. A client may wish to convert these to full IRIs for processing. This can be done using a library that implements the JSON-LD API, by compacting the document with an empty context.","title":"Querying Ontology Information"},{"location":"/03-webapi/api-v2/ontology-information.html#querying-ontology-metadata","text":"To get metadata about all ontologies:\nHTTP GET to http://host/v2/ontologies/metadata\nThe response is in the default API v2 schema. Sample response:\n{\n  \"knora-api:hasOntologies\" : [ {\n    \"@id\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2\",\n    \"@type\" : \"http://www.w3.org/2002/07/owl#Ontology\",\n    \"rdfs:label\" : \"The images demo ontology\"\n  }, {\n    \"@id\" : \"http://0.0.0.0:3333/ontology/0803/incunabula/v2\",\n    \"@type\" : \"http://www.w3.org/2002/07/owl#Ontology\",\n    \"rdfs:label\" : \"The incunabula ontology\"\n  }, {\n    \"@id\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\",\n    \"@type\" : \"http://www.w3.org/2002/07/owl#Ontology\",\n    \"rdfs:label\" : \"The anything ontology\",\n    \"knora-api:lastModificationDate\" : \"2017-12-19T15:23:42.166Z\"\n  }, {\n    \"@id\" : \"http://api.knora.org/ontology/knora-api/v2\",\n    \"@type\" : \"http://www.w3.org/2002/07/owl#Ontology\",\n    \"rdfs:label\" : \"The default knora-api ontology\"\n  } ],\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\"\n  }\n}\nTo get metadata about the ontologies that belong to a particular project:\nHTTP GET to http://host/v2/ontologies/metadata/PROJECT_IRI\nThe project IRI must be URL-encoded. Example response for the anything test project (project IRI http://rdfh.ch/projects/0001):\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"http://0.0.0.0:3333/ontology/0001/anything/v2#\",\n    \"@type\" : \"http://www.w3.org/2002/07/owl#Ontology\",\n    \"rdfs:label\" : \"The anything ontology\",\n    \"knora-api:lastModificationDate\" : \"2017-12-19T15:23:42.166Z\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\"\n  }\n}","title":"Querying Ontology Metadata"},{"location":"/03-webapi/api-v2/ontology-information.html#querying-an-ontology","text":"An ontology can be queried either by using an API route directly or by simply dereferencing the ontology IRI. The API route is as follows:\nHTTP GET to http://host/v2/ontologies/allentities/ONTOLOGY_IRI\nThe ontology IRI must be URL-encoded, and may be in either the default or the simple schema. The response will be in the same schema.\nIf the client dereferences a project-specific ontology IRI as a URL, the Knora API server running on the hostname in the IRI will serve the ontology. For example, if the server is running on 0.0.0.0:3333, the IRI http://0.0.0.0:3333/ontology/00FF/images/simple/v2 can be dereferenced to request the images sample ontology in the simple schema.\nIf the client dereferences a built-in Knora ontology, such as http://api.knora.org/ontology/knora-api/simple/v2, there must be a Knora API server running at api.knora.org that can serve the ontology. The DaSCH intends to run such as server. For testing, you can configure your local /etc/hosts file to resolve api.knora.org as localhost.","title":"Querying an Ontology"},{"location":"/03-webapi/api-v2/ontology-information.html#json-ld-representation-of-an-ontology-in-the-simple-schema","text":"The simple schema is suitable for client applications that need to read but not update data in Knora. For example, here is the response for the images sample ontology in the simple schema, http://0.0.0.0:3333/ontology/00FF/images/simple/v2 (simplified for clarity):\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"p00FF-images:bild\" : {\n        \"@id\" : \"p00FF-images:bild\",\n        \"@type\" : \"owl:Class\",\n        \"knora-api:resourceIcon\" : \"bild.png\",\n        \"rdfs:comment\" : \"An image of the demo image collection\",\n        \"rdfs:label\" : \"Image\",\n        \"rdfs:subClassOf\" : [ \"http://api.knora.org/ontology/knora-api/simple/v2#StillImageRepresentation\", {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#creationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:minCardinality\" : 0,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasStandoffLinkTo\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:minCardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasStillImageFile\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#lastModificationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://www.w3.org/2000/01/rdf-schema#label\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#description\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#erfassungsdatum\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#urheber\"\n        } ]\n      },\n      \"p00FF-images:person\" : {\n        \"@id\" : \"p00FF-images:person\",\n        \"@type\" : \"owl:Class\",\n        \"knora-api:resourceIcon\" : \"person.png\",\n        \"rdfs:comment\" : \"Person\",\n        \"rdfs:label\" : \"Person\",\n        \"rdfs:subClassOf\" : [ \"http://api.knora.org/ontology/knora-api/simple/v2#Resource\", {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#creationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:minCardinality\" : 0,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasStandoffLinkTo\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/simple/v2#lastModificationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://www.w3.org/2000/01/rdf-schema#label\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#lastname\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#firstname\"\n        } ]\n      }\n    },\n    \"knora-api:hasProperties\" : {\n      \"p00FF-images:description\" : {\n        \"@id\" : \"p00FF-images:description\",\n        \"@type\" : \"owl:DatatypeProperty\",\n        \"knora-api:objectType\" : \"http://www.w3.org/2001/XMLSchema#string\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#bild\",\n        \"rdfs:label\" : \"Description\",\n        \"rdfs:subPropertyOf\" : [ \"http://api.knora.org/ontology/knora-api/simple/v2#hasValue\", \"http://purl.org/dc/terms/description\" ]\n      },\n      \"p00FF-images:erfassungsdatum\" : {\n        \"@id\" : \"p00FF-images:erfassungsdatum\",\n        \"@type\" : \"owl:DatatypeProperty\",\n        \"knora-api:objectType\" : \"http://api.knora.org/ontology/knora-api/simple/v2#Date\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#bild\",\n        \"rdfs:label\" : \"Date of acquisition\",\n        \"rdfs:subPropertyOf\" : [ \"http://api.knora.org/ontology/knora-api/simple/v2#hasValue\", \"http://purl.org/dc/terms/date\" ]\n      },\n      \"p00FF-images:firstname\" : {\n        \"@id\" : \"p00FF-images:firstname\",\n        \"@type\" : \"owl:DatatypeProperty\",\n        \"knora-api:objectType\" : \"http://www.w3.org/2001/XMLSchema#string\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#person\",\n        \"rdfs:comment\" : \"First name of a person\",\n        \"rdfs:label\" : \"First name\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasValue\"\n      },\n      \"p00FF-images:lastname\" : {\n        \"@id\" : \"p00FF-images:lastname\",\n        \"@type\" : \"owl:DatatypeProperty\",\n        \"knora-api:objectType\" : \"http://www.w3.org/2001/XMLSchema#string\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#person\",\n        \"rdfs:comment\" : \"Last name of a person\",\n        \"rdfs:label\" : \"Name\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasValue\"\n      },\n      \"p00FF-images:urheber\" : {\n        \"@id\" : \"p00FF-images:urheber\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:objectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#person\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#bild\",\n        \"rdfs:comment\" : \"An entity primarily responsible for making the resource. Examples of a Creator include a person, an organization, or a service. Typically, the name of a Creator should be used to indicate the entity.\",\n        \"rdfs:label\" : \"Creator\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasLinkTo\"\n      }\n    },\n    \"rdfs:label\" : \"The images demo ontology\"\n  },\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"p00FF-images\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/simple/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nThis response format has several sections: knora-api:hasClasses, knora-api:hasProperties, knora-api:hasStandoffClasses, and knora-api:hasStandoffProperties.\nIn a class definition, cardinalities for properties of the class are represented as in OWL, using objects of type owl:Restriction. The supported cardinalities are the ones indicated in OWL Cardinalities.\nThe class definitions include cardinalities that are directly defined on each class, as well as cardinalities inherited from base classes. For example, we can see cardinalities inherited from knora-api:Resource, such as knora-api:hasStandoffLinkTo and http://schema.org/name (which represents rdfs:label).\nIn the simple schema, Knora value properties can be datatype properties. The knora-base:objectType of a Knora value property such as p00FF-images:description is a literal datatype, in this case xsd:string. Moreover, p00FF-images:description is a subproperty of the standard property dcterms:description, whose object can be a literal value. A client that understands rdfs:subPropertyOf, and is familiar with dcterms:description, can then work with p00FF-images:description on the basis of its knowledge about dcterms:description.\nBy default, values for rdfs:label and rdfs:comment are returned only in the user’s preferred language, or in the system default language. To obtain these values in all available languages, add the URL parameter ?allLanguages=true. For example, with this parameter, the definition of p00FF-images:titel becomes:\n{\n   \"@id\" : \"p00FF-images:titel\",\n   \"@type\" : \"owl:DatatypeProperty\",\n   \"knora-api:objectType\" : \"http://www.w3.org/2001/XMLSchema#string\",\n   \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/simple/v2#bild\",\n   \"rdfs:label\" : [ {\n    \"@language\" : \"en\",\n    \"@value\" : \"Title\"\n   }, {\n    \"@language\" : \"de\",\n    \"@value\" : \"Titel\"\n   }, {\n    \"@language\" : \"fr\",\n    \"@value\" : \"Titre\"\n   }, {\n    \"@language\" : \"it\",\n    \"@value\" : \"Titolo\"\n   } ],\n   \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/simple/v2#hasValue\"\n}\nTo find out more about the knora-api entities used in the response, the client can request the knora-api ontology in the simple schema: http://api.knora.org/ontology/knora-api/simple/v2. For example, p00FF-images:erfassungsdatum has a knora-api:objectType of knora-api:Date, which is a subtype of xsd:string with a Knora-specific, human-readable format. In the knora-api simple ontology, there is a definition of this type:\n{\n  \"@id\" : \"knora-api:Date\",\n  \"@type\" : \"rdfs:Datatype\",\n  \"rdfs:comment\" : \"Represents a date as a period with different possible precisions.\",\n  \"rdfs:label\" : \"Date literal\",\n  \"rdfs:subClassOf\" : {\n    \"@type\" : \"rdfs:Datatype\",\n    \"owl:onDatatype\" : \"http://www.w3.org/2001/XMLSchema#string\",\n    \"owl:withRestrictions\" : {\n      \"xsd:pattern\" : \"(GREGORIAN|JULIAN):\\\\d{1,4}(-\\\\d{1,2}(-\\\\d{1,2})?)?( BC| AD| BCE| CE)?(:\\\\d{1,4}(-\\\\d{1,2}(-\\\\d{1,2})?)?( BC| AD| BCE| CE)?)?\"\n    }\n  }\n}","title":"JSON-LD Representation of an Ontology in the Simple Schema"},{"location":"/03-webapi/api-v2/ontology-information.html#json-ld-representation-of-an-ontology-in-the-default-schema","text":"The default schema is suitable for client applications that need to update data in Knora. For example, here is the response for the images sample ontology in the default schema, http://0.0.0.0:3333/ontology/00FF/images/v2 (simplified for clarity):\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"p00FF-images:bild\" : {\n        \"@id\" : \"p00FF-images:bild\",\n        \"@type\" : \"owl:Class\",\n        \"knora-api:canBeInstantiated\" : true,\n        \"knora-api:isResourceClass\" : true,\n        \"knora-api:resourceIcon\" : \"bild.png\",\n        \"rdfs:comment\" : \"An image of the demo image collection\",\n        \"rdfs:label\" : \"Image\",\n        \"rdfs:subClassOf\" : [ \"http://api.knora.org/ontology/knora-api/v2#StillImageRepresentation\", {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#creationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasPermissions\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:minCardinality\" : 0,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasStandoffLinkTo\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:minCardinality\" : 0,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasStandoffLinkToValue\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:minCardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasStillImageFileValue\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#lastModificationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://www.w3.org/2000/01/rdf-schema#label\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"salsah-gui:guiOrder\" : 3,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#description\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"salsah-gui:guiOrder\" : 8,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#erfassungsdatum\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"salsah-gui:guiOrder\" : 12,\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#urheber\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"salsah-gui:guiOrder\" : 12,\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#urheberValue\"\n        } ]\n      },\n      \"p00FF-images:person\" : {\n        \"@id\" : \"p00FF-images:person\",\n        \"@type\" : \"owl:Class\",\n        \"knora-api:canBeInstantiated\" : true,\n        \"knora-api:isResourceClass\" : true,\n        \"knora-api:resourceIcon\" : \"person.png\",\n        \"rdfs:comment\" : \"Person\",\n        \"rdfs:label\" : \"Person\",\n        \"rdfs:subClassOf\" : [ \"http://api.knora.org/ontology/knora-api/v2#Resource\", {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#creationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasPermissions\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:minCardinality\" : 0,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasStandoffLinkTo\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:minCardinality\" : 0,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#hasStandoffLinkToValue\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:maxCardinality\" : 1,\n          \"owl:onProperty\" : \"http://api.knora.org/ontology/knora-api/v2#lastModificationDate\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"knora-api:isInherited\" : true,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://www.w3.org/2000/01/rdf-schema#label\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"salsah-gui:guiOrder\" : 0,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#lastname\"\n        }, {\n          \"@type\" : \"owl:Restriction\",\n          \"salsah-gui:guiOrder\" : 1,\n          \"owl:cardinality\" : 1,\n          \"owl:onProperty\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#firstname\"\n        } ]\n      }\n    },\n    \"knora-api:hasProperties\" : {\n      \"p00FF-images:description\" : {\n        \"@id\" : \"p00FF-images:description\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:isEditable\" : true,\n        \"knora-api:isResourceProperty\" : true,\n        \"knora-api:objectType\" : \"http://api.knora.org/ontology/knora-api/v2#TextValue\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#bild\",\n        \"salsah-gui:guiAttribute\" : [ \"rows=10\", \"width=95%\", \"wrap=soft\" ],\n        \"salsah-gui:guiElement\" : \"http://api.knora.org/ontology/salsah-gui/v2#Textarea\",\n        \"rdfs:label\" : \"Description\",\n        \"rdfs:subPropertyOf\" : [ \"http://api.knora.org/ontology/knora-api/v2#hasValue\", \"http://purl.org/dc/terms/description\" ]\n      },\n      \"p00FF-images:erfassungsdatum\" : {\n        \"@id\" : \"p00FF-images:erfassungsdatum\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:isEditable\" : true,\n        \"knora-api:isResourceProperty\" : true,\n        \"knora-api:objectType\" : \"http://api.knora.org/ontology/knora-api/v2#DateValue\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#bild\",\n        \"salsah-gui:guiElement\" : \"http://api.knora.org/ontology/salsah-gui/v2#Date\",\n        \"rdfs:label\" : \"Date of acquisition\",\n        \"rdfs:subPropertyOf\" : [ \"http://api.knora.org/ontology/knora-api/v2#hasValue\", \"http://purl.org/dc/terms/date\" ]\n      },\n      \"p00FF-images:firstname\" : {\n        \"@id\" : \"p00FF-images:firstname\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:isEditable\" : true,\n        \"knora-api:isResourceProperty\" : true,\n        \"knora-api:objectType\" : \"http://api.knora.org/ontology/knora-api/v2#TextValue\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#person\",\n        \"salsah-gui:guiAttribute\" : [ \"maxlength=32\", \"size=32\" ],\n        \"salsah-gui:guiElement\" : \"http://api.knora.org/ontology/salsah-gui/v2#SimpleText\",\n        \"rdfs:comment\" : \"First name of a person\",\n        \"rdfs:label\" : \"First name\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/v2#hasValue\"\n      },\n      \"p00FF-images:lastname\" : {\n        \"@id\" : \"p00FF-images:lastname\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:isEditable\" : true,\n        \"knora-api:isResourceProperty\" : true,\n        \"knora-api:objectType\" : \"http://api.knora.org/ontology/knora-api/v2#TextValue\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#person\",\n        \"salsah-gui:guiAttribute\" : [ \"maxlength=32\", \"size=32\" ],\n        \"salsah-gui:guiElement\" : \"http://api.knora.org/ontology/salsah-gui/v2#SimpleText\",\n        \"rdfs:comment\" : \"Last name of a person\",\n        \"rdfs:label\" : \"Name\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/v2#hasValue\"\n      },\n      \"p00FF-images:urheber\" : {\n        \"@id\" : \"p00FF-images:urheber\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:isEditable\" : true,\n        \"knora-api:isLinkProperty\" : true,\n        \"knora-api:isResourceProperty\" : true,\n        \"knora-api:objectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#person\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#bild\",\n        \"salsah-gui:guiAttribute\" : \"numprops=2\",\n        \"salsah-gui:guiElement\" : \"http://api.knora.org/ontology/salsah-gui/v2#Searchbox\",\n        \"rdfs:comment\" : \"An entity primarily responsible for making the resource. Examples of a Creator include a person, an organization, or a service. Typically, the name of a Creator should be used to indicate the entity.\",\n        \"rdfs:label\" : \"Creator\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/v2#hasLinkTo\"\n      },\n      \"p00FF-images:urheberValue\" : {\n        \"@id\" : \"p00FF-images:urheberValue\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:isEditable\" : true,\n        \"knora-api:isLinkValueProperty\" : true,\n        \"knora-api:isResourceProperty\" : true,\n        \"knora-api:objectType\" : \"http://api.knora.org/ontology/knora-api/v2#LinkValue\",\n        \"knora-api:subjectType\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#bild\",\n        \"salsah-gui:guiAttribute\" : \"numprops=2\",\n        \"salsah-gui:guiElement\" : \"http://api.knora.org/ontology/salsah-gui/v2#Searchbox\",\n        \"rdfs:comment\" : \"An entity primarily responsible for making the resource. Examples of a Creator include a person, an organization, or a service. Typically, the name of a Creator should be used to indicate the entity.\",\n        \"rdfs:label\" : \"Creator\",\n        \"rdfs:subPropertyOf\" : \"http://api.knora.org/ontology/knora-api/v2#hasLinkToValue\"\n      }\n    },\n    \"rdfs:label\" : \"The images demo ontology\"\n  },\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"p00FF-images\" : \"http://0.0.0.0:3333/ontology/00FF/images/v2#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"salsah-gui\" : \"http://api.knora.org/ontology/salsah-gui/v2#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nIn the default schema, all Knora value properties are object properties, whose objects are IRIs, each of which uniquely identifies a value that contains metadata and can potentially be edited. The knora-base:objectType of a Knora value property such as p00FF-images:description is a Knora value class, in this case knora-api:TextValue. Similarly, p00FF-images:erfassungsdatum has a knora-api:objectType of knora-api:DateValue, which has a more complex structure than the knora-api:Date datatype shown in the previous section. A client can find out more about these value classes by requesting the knora-api ontology in the default schema, http://api.knora.org/ontology/knora-api/v2.\nMoreover, additional information is provided in the default schema, to help clients that wish to create or update resources and values. A Knora resource class that can be instantiated is identified with the boolean properties knora-api:isResourceClass and knora-api:canBeInstantiated, to distinguish it from built-in abstract classes. Knora resource properties whose values can be edited by clients are identified with knora-api:isResourceProperty and knora-api:isEditable, to distinguish them from properties whose values are maintained automatically by the Knora API server. Link value properties are shown along with link properties, because a client that updates links will need the IRIs of their link values. The predicate salsah-gui:guiOrder tells a GUI client in what order to display the properties of a class, and the predicates salsah-gui:guiElement and salsah-gui:guiAttribute specify how to configure a GUI element for editing the value of a property. For more information on the salsah-gui ontology, see The SALSAH GUI Ontology.","title":"JSON-LD Representation of an Ontology in the Default Schema"},{"location":"/03-webapi/api-v2/ontology-information.html#ontology-updates","text":"The ontology update API must ensure that the ontologies it creates are valid and consistent, and that existing data is not invalidated by a change to an ontology. To make this easier to enforce, the ontology update API allows only one entity to be created or modified at a time. It is not possible to submit an entire ontology all at once. In most cases, an update request is a JSON-LD document containing knora-api:hasOntologies, providing only the information that is relevant to the update.\nMoreover, the API enforces the following rules:\nAn entity (i.e. a class or property) cannot be referred to until it has been created. An entity cannot be modified or deleted if it is used in data, except for changes to its rdfs:label or rdfs:comment. An entity cannot be modified if another entity refers to it, with one exception: a knora-api:subjectType or knora-api:objectType that refers to a class will not prevent the class’s cardinalities from being modified.\nBecause of these rules, some operations have to be done in a specific order:\nProperties have to be defined before they can be used in the cardinalities of a class, but a property’s knora-api:subjectType cannot refer to a class that does not yet exist. The recommended approach is to first create a class with no cardinalities, then create the properties that it needs, then add cardinalities for those properties to the class. To delete a class along with its properties, the client must first remove the cardinalities from the class, then delete the property definitions, then delete the class definition.\nWhen changing an existing ontology, the client must always supply the ontology’s knora-api:lastModificationDate, which is returned in the response to each update. If user A attempts to update an ontology, but user B has already updated it since the last time user A received the ontology’s knora-api:lastModificationDate, user A’s update will be rejected with an HTTP 409 Conflict error. This means that it is possible for two different users to work concurrently on the same ontology, but this is discouraged since it is likely to lead to confusion.\nAn ontology can be created or updated only by a system administrator, or by a project administrator in the ontology’s project.\nOntology updates always use the default schema.","title":"Ontology Updates"},{"location":"/03-webapi/api-v2/ontology-information.html#creating-a-new-ontology","text":"An ontology is always created within a particular project. This is the only ontology update request in which the client submits a JSON-LD document that does not contain knora-api:hasOntologies.\nHTTP POST to http://host/v2/ontologies\n{\n    \"knora-api:ontologyName\": \"ONTOLOGY_NAME\",\n    \"knora-api:attachedToProject\": \"PROJECT_IRI\",\n    \"rdfs:label\": \"ONTOLOGY_NAME\",\n    \"@context\": {\n        \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n        \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n    }\n}\nThe ontology name must follow the rules given in Knora IRIs.\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing only the ontology’s metadata, which includes the ontology’s IRI. When the client makes further requests to create entities (classes and properties) in the ontology, it must construct entity IRIs by concatenating the ontology IRI, a # character, and the entity name. An entity name must be a valid XML NCName.","title":"Creating a New Ontology"},{"location":"/03-webapi/api-v2/ontology-information.html#changing-an-ontologys-metadata","text":"Currently, the only modifiable ontology metadata is the ontology’s rdfs:label.\nHTTP PUT to http://host/v2/ontologies/metadata\n{\n  \"knora-api:hasOntologies\": {\n    \"@id\": \"ONTOLOGY_IRI\",\n    \"rdfs:label\": \"NEW_ONTOLOGY_LABEL\",\n    \"knora-api:lastModificationDate\": \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\": {\n    \"rdfs\": \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"knora-api\": \"http://api.knora.org/ontology/knora-api/v2#\"\n  }\n}\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing only the ontology’s metadata.","title":"Changing an Ontology’s Metadata"},{"location":"/03-webapi/api-v2/ontology-information.html#deleting-an-ontology","text":"An ontology can be deleted only if it is not used in data.\nHTTP DELETE to http://host/v2/ontologies/ONTOLOGY_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\nThe ontology IRI and the ontology’s last modification date must be URL-encoded.\nA successful response will be a JSON-LD document containing a confirmation message.","title":"Deleting an Ontology"},{"location":"/03-webapi/api-v2/ontology-information.html#creating-a-class-without-cardinalities","text":"HTTP POST to http://host/v2/ontologies/classes\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"CLASS_IRI\" : {\n        \"@id\" : \"CLASS_IRI\",\n        \"@type\" : \"owl:Class\",\n        \"rdfs:label\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"LABEL\"\n        },\n        \"rdfs:comment\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"COMMENT\"\n        },\n        \"rdfs:subClassOf\" : \"BASE_CLASS_IRI\"\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nValues for rdfs:label and rdfs:comment must be submitted in at least one language, either as an object or as an array of objects.\nAt least one base class must be provided, which can be knora-api:Resource or any of its subclasses.\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing the new class definition (but not any of the other entities in the ontology).","title":"Creating a Class Without Cardinalities"},{"location":"/03-webapi/api-v2/ontology-information.html#creating-a-class-with-cardinalities","text":"This can work if the new class will have cardinalities for properties that have no knora-api:subjectType, or if the new class will be a subclass of their knora-api:subjectType.\nHTTP POST to http://host/v2/ontologies/classes\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"CLASS_IRI\" : {\n        \"@id\" : \"CLASS_IRI\",\n        \"@type\" : \"owl:Class\",\n        \"rdfs:label\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"LABEL\"\n        },\n        \"rdfs:comment\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"COMMENT\"\n        },\n        \"rdfs:subClassOf\" : [\n            \"BASE_CLASS_IRI\",\n            {\n                \"@type\": \"http://www.w3.org/2002/07/owl#Restriction\",\n                \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n                \"owl:onProperty\": \"PROPERTY_IRI\"\n            }\n        ]\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nOWL_CARDINALITY_PREDICATE and OWL_CARDINALITY_VALUE must correspond to the supported combinations given in OWL Cardinalities. (The placeholder OWL_CARDINALITY_VALUE is shown here in quotes, but it should be an unquoted integer.)\nValues for rdfs:label and rdfs:comment must be submitted in at least one language, either as an object or as an array of objects.\nAt least one base class must be provided.\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing the new class definition (but not any of the other entities in the ontology).","title":"Creating a Class With Cardinalities"},{"location":"/03-webapi/api-v2/ontology-information.html#changing-the-labels-of-a-class","text":"This operation is permitted even if the class is used in data.\nHTTP PUT to http://host/v2/ontologies/classes\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"CLASS_IRI\" : {\n        \"@id\" : \"CLASS_IRI\",\n        \"@type\" : \"owl:Class\",\n        \"rdfs:label\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"LABEL\"\n        }\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nValues for rdfs:label must be submitted in at least one language, either as an object or as an array of objects. The submitted labels will replace the existing ones.","title":"Changing the Labels of a Class"},{"location":"/03-webapi/api-v2/ontology-information.html#changing-the-comments-of-a-class","text":"This operation is permitted even if the class is used in data.\nHTTP PUT to http://host/v2/ontologies/classes\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"CLASS_IRI\" : {\n        \"@id\" : \"CLASS_IRI\",\n        \"@type\" : \"owl:Class\",\n        \"rdfs:comment\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"COMMENT\"\n        }\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nValues for rdfs:comment must be submitted in at least one language, either as an object or as an array of objects. The submitted comments will replace the existing ones.","title":"Changing the Comments of a Class"},{"location":"/03-webapi/api-v2/ontology-information.html#creating-a-property","text":"HTTP POST to http://host/v2/ontologies/properties\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasProperties\" : {\n      \"PROPERTY_IRI\" : {\n        \"@id\" : \"PROPERTY_IRI\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"knora-api:subjectType\" : \"SUBJECT_TYPE\",\n        \"knora-api:objectType\" : \"OBJECT_TYPE\",\n        \"rdfs:label\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"LABEL\"\n        },\n        \"rdfs:comment\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"COMMENT\"\n        },\n        \"rdfs:subPropertyOf\" : \"BASE_PROPERTY_IRI\",\n        \"salsah-gui:guiElement\" : \"GUI_ELEMENT_IRI\",\n        \"salsah-gui:guiAttribute\" : [ \"GUI_ATTRIBUTE\" ]\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"salsah-gui\" : \"http://api.knora.org/ontology/salsah-gui/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nValues for rdfs:label and rdfs:comment must be submitted in at least one language, either as an object or as an array of objects.\nAt least one base property must be provided, which can be knora-api:hasValue, knora-api:hasLinkTo, or any of their subproperties, with the exception of file properties (subproperties of knora-api:hasFileValue) and link value properties (subproperties of knora-api:hasLinkToValue).\nThe property definition must specify its knora-api:objectType. If the new property is a subproperty of knora-api:hasValue, its knora-api:objectType must be one of the built-in subclasses of knora-api:Value, which are defined in the knora-api ontology in the default schema. If the new property is a subproperty of knora-base:hasLinkTo, its knora-api:objectType must be a subclass of knora-api:Resource.\nTo improve consistency checking, it is recommended, but not required, to provide knora-api:subjectType, which must be a subclass of knora-api:Resource.\nThe predicates salsah-gui:guiElement and salsah-gui:guiAttribute are optional. If provided, the object of guiElement must be one of the OWL named individuals defined in The SALSAH GUI Ontology. Some GUI elements take required or optional attributes, which are provided as objects of salsah-gui:guiAttribute; see The SALSAH GUI Ontology for details.\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing the new property definition (but not any of the other entities in the ontology).","title":"Creating a Property"},{"location":"/03-webapi/api-v2/ontology-information.html#changing-the-labels-of-a-property","text":"This operation is permitted even if the property is used in data.\nHTTP PUT to http://host/v2/ontologies/properties\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasProperties\" : {\n      \"PROPERTY_IRI\" : {\n        \"@id\" : \"PROPERTY_IRI\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"rdfs:label\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"LABEL\"\n        }\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nValues for rdfs:label must be submitted in at least one language, either as an object or as an array of objects.","title":"Changing the Labels of a Property"},{"location":"/03-webapi/api-v2/ontology-information.html#changing-the-comments-of-a-property","text":"This operation is permitted even if the property is used in data.\nHTTP PUT to http://host/v2/ontologies/properties\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasProperties\" : {\n      \"PROPERTY_IRI\" : {\n        \"@id\" : \"PROPERTY_IRI\",\n        \"@type\" : \"owl:ObjectProperty\",\n        \"rdfs:comment\" : {\n          \"@language\" : \"LANGUAGE_CODE\",\n          \"@value\" : \"COMMENT\"\n        }\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nValues for rdfs:comment must be submitted in at least one language, either as an object or as an array of objects.","title":"Changing the Comments of a Property"},{"location":"/03-webapi/api-v2/ontology-information.html#adding-cardinalities-to-a-class","text":"This operation is not permitted if the class is used in data, or if it has a subclass.\nHTTP POST to http://host/v2/ontologies/cardinalities\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"CLASS_IRI\" : {\n        \"@id\" : \"CLASS_IRI\",\n        \"@type\" : \"owl:Class\",\n        \"rdfs:subClassOf\" : [\n            {\n                \"@type\": \"http://www.w3.org/2002/07/owl#Restriction\",\n                \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n                \"owl:onProperty\": \"PROPERTY_IRI\"\n            }\n        ]\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nAt least one cardinality must be submitted.\nOWL_CARDINALITY_PREDICATE and OWL_CARDINALITY_VALUE must correspond to the supported combinations given in OWL Cardinalities. (The placeholder OWL_CARDINALITY_VALUE is shown here in quotes, but it should be an unquoted integer.)\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing the new class definition (but not any of the other entities in the ontology).","title":"Adding Cardinalities to a Class"},{"location":"/03-webapi/api-v2/ontology-information.html#replacing-the-cardinalities-of-a-class","text":"This removes all the cardinalities from the class and replaces them with the submitted cardinalities. If no cardinalities are submitted (i.e. the request contains no rdfs:subClassOf), the class is left with no cardinalities.\nThis operation is not permitted if the class is used in data, or if it has a subclass.\nHTTP PUT to http://host/v2/ontologies/cardinalities\n{\n  \"knora-api:hasOntologies\" : {\n    \"@id\" : \"ONTOLOGY_IRI\",\n    \"@type\" : \"owl:Ontology\",\n    \"knora-api:hasClasses\" : {\n      \"CLASS_IRI\" : {\n        \"@id\" : \"CLASS_IRI\",\n        \"@type\" : \"owl:Class\",\n        \"rdfs:subClassOf\" : [\n            {\n                \"@type\": \"http://www.w3.org/2002/07/owl#Restriction\",\n                \"OWL_CARDINALITY_PREDICATE\": \"OWL_CARDINALITY_VALUE\",\n                \"owl:onProperty\": \"PROPERTY_IRI\"\n            }\n        ]\n      }\n    },\n    \"knora-api:lastModificationDate\" : \"ONTOLOGY_LAST_MODIFICATION_DATE\"\n  },\n  \"@context\" : {\n    \"knora-api\" : \"http://api.knora.org/ontology/knora-api/v2#\",\n    \"owl\" : \"http://www.w3.org/2002/07/owl#\",\n    \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\",\n    \"xsd\" : \"http://www.w3.org/2001/XMLSchema#\"\n  }\n}\nOWL_CARDINALITY_PREDICATE and OWL_CARDINALITY_VALUE must correspond to the supported combinations given in OWL Cardinalities. (The placeholder OWL_CARDINALITY_VALUE is shown here in quotes, but it should be an unquoted integer.)\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing the new class definition (but not any of the other entities in the ontology).","title":"Replacing the Cardinalities of a Class"},{"location":"/03-webapi/api-v2/ontology-information.html#deleting-a-property","text":"A property can be deleted only if no other ontology entity refers to it, and if it is not used in data.\nHTTP DELETE to http://host/v2/ontologies/properties/PROPERTY_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\nThe property IRI and the ontology’s last modification date must be URL-encoded.\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing only the ontology’s metadata.","title":"Deleting a Property"},{"location":"/03-webapi/api-v2/ontology-information.html#deleting-a-class","text":"A class can be deleted only if no other ontology entity refers to it, and if it is not used in data.\nHTTP DELETE to http://host/v2/ontologies/classes/CLASS_IRI?lastModificationDate=ONTOLOGY_LAST_MODIFICATION_DATE\nThe class IRI and the ontology’s last modification date must be URL-encoded.\nA successful response will be a JSON-LD document containing knora-api:hasOntologies, providing only the ontology’s metadata.","title":"Deleting a Class"},{"location":"/03-webapi/api-v2/response-formats.html","text":"","title":"Response Formats"},{"location":"/03-webapi/api-v2/response-formats.html#response-formats","text":"","title":"Response Formats"},{"location":"/03-webapi/api-v2/response-formats.html#resources-sequence","text":"For the sake of consistency, the same response format, ResourcesSequence, is used whenever one or more resources are returned in an API response. This means that different API operations give responses with the same structure, which represent different views on the data depending on which API route was used (context).\nFor example, a resource request returns a resource and all its properties. In a full-text search, the resource is returned with the properties that matched the search criteria.\nA response to an extended search may represent a whole graph of interconnected resources.\nBasically, resources are returned in form of an ordered sequence, including information about how many elements the list has. Dependent resources, i.e. resources that are referred to by other resources on the top level, are nested in link values.\nSee interface ResourcesSequence in module ResourcesResponse (exists for both API schemas: ApiV2Simple and ApiV2WithValueObjects).","title":"Resources Sequence"},{"location":"/03-webapi/api-admin/index.html","text":"","title":"Knora Admin API"},{"location":"/03-webapi/api-admin/index.html#knora-admin-api","text":"The Knora admin API makes it possible to administer Knora projects, users, user groups, permissions, and hierarchical lists.\nIntroduction: Using the Admin API","title":"Knora Admin API"},{"location":"/03-webapi/api-admin/introduction.html","text":"","title":"Introduction: Using the Admin API"},{"location":"/03-webapi/api-admin/introduction.html#introduction-using-the-admin-api","text":"RESTful API Knora IRIs in the Admin API Admin Path Segment Admin API Response Format Placeholder host in sample URLs Authentication OpenAPI/Swagger Admin API Endpoints","title":"Introduction: Using the Admin API"},{"location":"/03-webapi/api-admin/introduction.html#restful-api","text":"The Knora Admin API is a RESTful API that allows for reading and adding of administrative resources from and to Knora and changing their values using HTTP requests. The actual data is submitted as JSON (request and response format). The various HTTP methods are applied according to the widespread practice of RESTful APIs: GET for reading, POST for adding, PUT for changing resources and values, and DELETE to delete resources or values (see Using HTTP Methods for RESTful Services).","title":"RESTful API"},{"location":"/03-webapi/api-admin/introduction.html#knora-iris-in-the-admin-api","text":"Every resource that is created or hosted by Knora is identified by a unique ID called an Internationalized Resource Identifier (IRI). The IRI is required for every API operation to identify the resource in question. A Knora IRI has itself the format of a URL. For some API operations, the IRI has to be URL-encoded (HTTP GET requests).\nTODO: Clarify that the admin API uses internal IRIs (depends on #841).","title":"Knora IRIs in the Admin API"},{"location":"/03-webapi/api-admin/introduction.html#admin-path-segment","text":"Every request to Admin API includes admin as a path segment, e.g. http://host/admin/users/http%3A%2F%2Frdfh.ch%2Fusers%2Froot.","title":"Admin Path Segment"},{"location":"/03-webapi/api-admin/introduction.html#admin-api-response-format","text":"If an API request is handled successfully, Knora responds with a 200 HTTP status code. The actual answer from Knora (the representation of the requested resource or information about the executed API operation) is sent in the HTTP body, encoded as JSON.","title":"Admin API Response Format"},{"location":"/03-webapi/api-admin/introduction.html#placeholder-host-in-sample-urls","text":"Please note that all the sample URLs used in this documentation contain host as a placeholder. The placeholder host has to be replaced by the actual hostname (and port) of the server the Knora instance is running on.","title":"Placeholder host in sample URLs"},{"location":"/03-webapi/api-admin/introduction.html#authentication","text":"For all API operations that target at changing resources or values, the client has to provide credentials (username and password) so that the API server can authenticate the user making the request. Credentials can be sent as a part of the HTTP header or as parts of the URL (TODO: add a link to “Authentication in the Knora API Server”).","title":"Authentication"},{"location":"/03-webapi/api-admin/introduction.html#openapi-swagger","text":"The Admin API uses OpenAPI for documentation purposes. To try it out, run webapi and open http://host/api-docs/swagger.json in http://petstore.swagger.io . Alternatively, the documentation can be looked at by using ReDoc, which is provided in knora/docs/redoc/index.html.","title":"OpenAPI/Swagger"},{"location":"/03-webapi/api-admin/introduction.html#admin-api-endpoints","text":"TODO","title":"Admin API Endpoints"},{"location":"/04-salsah/index.html","text":"","title":"The SALSAH 1 GUI"},{"location":"/04-salsah/index.html#the-salsah-1-gui","text":"","title":"The SALSAH 1 GUI"},{"location":"/04-salsah/index.html#running-the-automated-tests","text":"In order to run the tests, the Selenium driver for Chrome has to be installed.\nIt is architecture-dependant, so go to the salsah1/lib/chromedriver directory and unzip the distribution that matches your architecture, or download it from here and install it in this directory.\nThen, launch the services as described above; the triple store with the test data, the api server with the -r option, Sipi with the test configuration and SALSAH 1 where you can run the tests in the same SBT session:\n$ cd KNORA_PROJECT_DIRECTORY/salsah\n$ sbt\n> compile\n> reStart\n> test\nNote: please be patient as SALSAH 1 can take up to one mimute (end of a time-out) before reporting some errors.","title":"Running the automated tests"},{"location":"/05-sipi/index.html","text":"","title":"The Sipi Media Server"},{"location":"/05-sipi/index.html#the-sipi-media-server","text":"Sipi is a high-performance media server written in C++, for serving and converting binary media files such as images and video. Sipi can efficiently convert between many different formats on demand, preserving embedded metadata, and implements the International Image Interoperability Framework (IIIF). Knora is designed to use Sipi for converting and serving media files.\nSetting Up Sipi for Knora Interaction Between Sipi and Knora","title":"The Sipi Media Server"},{"location":"/05-sipi/setup-sipi-for-knora.html","text":"","title":"Setting Up Sipi for Knora"},{"location":"/05-sipi/setup-sipi-for-knora.html#setting-up-sipi-for-knora","text":"","title":"Setting Up Sipi for Knora"},{"location":"/05-sipi/setup-sipi-for-knora.html#setup-and-execution","text":"In order to serve files to the client application like the Salsah GUI, Sipi must be set up and running. Sipi can be downloaded from its own GitHub repository: https://github.com/dhlab-basel/Sipi. Please follow the instructions given in the README to compile it on your system.\nOnce it is compiled, you can run Sipi with the following option: ./local/bin/sipi --config=config/sipi.knora-config.lua (or ./local/bin/sipi --config=sipi.knora-test-config.lua for using sipi for testing). Please see sipi.knora-config.lua for the settings like URL, port number etc. These settings need to be set accordingly in Knora’s application.conf. If you use the default settings both in Sipi and Knora, there is no need to change these settings.\nWhenever a file is requested from Sipi (e.g. a browser trying to dereference an image link served by Knora), a preflight function is called. This function is defined in sipi.init-knora.lua present in the Sipi root directory. It takes three parameters: prefix, identifier (the name of the requested file), and cookie. File links created by Knora use the prefix knora, e.g. http://localhost:1024/knora/incunabula_0000000002.jp2/full/2613,3505/0/default.jpg.\nGiven these information, Sipi asks Knora about the current’s users permissions on the given file. The cookie contains the current user’s Knora session id, so Knora can match Sipi’s request with a given user profile and determine the permissions this user has on the file. If the Knora response grants sufficient permissions, the file is served in the requested quality. If the suer has preview rights, Sipi serves a reduced quality or integrates a watermark. If the user has no permissions, Sipi refuses to serve the file. However, all of this behaviour is defined in the preflight function in Sipi and not controlled by Knora. Knora only provides the permission code.\nSee Sharing the Session ID with Sipi for more information about sharing the session id.","title":"Setup and Execution"},{"location":"/05-sipi/setup-sipi-for-knora.html#using-sipi-in-test-mode","text":"If you just want to test Sipi with Knora without serving the actual files (e.g. when executing browser tests), you can simply start Sipi like this: ./local/bin/sipi --config=config/sipi.knora-test-config.lua. Then always the same test file will be served which is included in Sipi. In test mode, Sipi will not aks Knora about the user’s permission on the requested file.","title":"Using Sipi in Test Mode"},{"location":"/05-sipi/sipi-and-knora.html","text":"","title":"Interaction Between Sipi and Knora"},{"location":"/05-sipi/sipi-and-knora.html#interaction-between-sipi-and-knora","text":"","title":"Interaction Between Sipi and Knora"},{"location":"/05-sipi/sipi-and-knora.html#general-remarks","text":"Knora and Sipi (Simple Image Presentation Interface) are two complementary software projects. Whereas Knora deals with data that is written to and read from a triplestore (metadata and annotations), Sipi takes care of storing, converting and serving image files as well as other types of files such as audio, video, or documents (binary files it just stores and serves).\nKnora and Sipi stick to a clear division of responsibility regarding files: Knora knows about the names of files that are attached to resources as well as some metadata and is capable of creating the URLs for the client to request them from Sipi, but the whole handling of files (storing, naming, organization of the internal directory structure, format conversions, and serving) is taken care of by Sipi.","title":"General Remarks"},{"location":"/05-sipi/sipi-and-knora.html#adding-files-to-knora-using-the-gui-or-directly-the-api","text":"To create a resource with a digital representation attached to, either the browser-based GUI (SALSAH) can be used or this can be done by directly addressing the API. (Of course, also the GUI uses the API. But the user does not need to know about it.) The same applies for changing an existing digital representation for a resource. Subsequently, the first case will be called the GUI case and the second the non-GUI case.","title":"Adding Files to Knora: Using the GUI or directly the API"},{"location":"/05-sipi/sipi-and-knora.html#gui-case","text":"In this case, the user may choose a file to upload using his web-browser. The file is directly sent to Sipi (route: create_thumbnail) to calculate a thumbnail hosted by Sipi which then gets displayed to the user in the browser. Sipi copies the original file into a temporary directory and keeps it there (for later processing in another request). In its answer (JSON), Sipi returns:\npreview_path: the path to the thumbnail (accessible to a web-browser) filename: the name of the temporarily stored original file (managed by Sipi) original_mimetype: mime type of the original file original_filename: the original name of the file submitted by the client\nOnce the user finally wants to attach the file to a resource, the request is sent to Knora’s API providing all the required parameters to create the resource along with additional information about the file to be attached. However, the file itself is not submitted to the Knora Api, but its filename returned by Sipi (from the create_thumbnail response).","title":"GUI Case"},{"location":"/05-sipi/sipi-and-knora.html#create-a-new-resource-with-a-digital-representation","text":"The POST request is handled in ResourcesRouteV1.scala and parsed to a CreateResourceApiRequestV1. Information about the file is sent separately from the other resource parameters (properties) under the name file:\noriginalFilename: original name of the file (returned by Sipi when creating the thumbnail) originalMimeType: original mime type of the file (returned by Sipi when creating the thumbnail) filename: name of the temporarily stored original file (returned by Sipi when creating the thumbnail)\nIn the route, a SipiResponderConversionFileRequestV1 is created representing the information about the file to be attached to the new resource. Along with the other parameters, it is sent to the resources responder.\nSee Further Handling of the GUI and the non GUI-case in the Resources Responder for details of how the resources responder then handles the request.","title":"Create a new Resource with a Digital Representation"},{"location":"/05-sipi/sipi-and-knora.html#change-the-digital-representation-of-a-resource","text":"The request is taken care of in ValuesRouteV1.scala. The PUT request is handled in path v1/filevalue/{resIri} which receives the resource Iri as a part of the URL: The submitted file will update the existing file values of the given resource.\nThe file parameters are submitted as json and are parsed into a ChangeFileValueApiRequestV1. To represent the conversion request for the Sipi responder, a SipiResponderConversionFileRequestV1 is created. A ChangeFileValueRequestV1 containing the resource Iri and the message for Sipi is then created and sent to the values responder.\nSee Further Handling of the GUI and the non GUI-case in the Values Responder for details of how the values responder then handles the request.","title":"Change the Digital Representation of a Resource"},{"location":"/05-sipi/sipi-and-knora.html#non-gui-case","text":"In this case, the API receives an HTTP multipart request containing the binary data.","title":"Non-GUI case"},{"location":"/05-sipi/sipi-and-knora.html#create-a-new-resource-with-a-digital-representation","text":"The request is handled in ResourcesRouteV1.scala. The multipart POST request consists of two named body parts: json containing the resource parameters (properties) and file containing the binary data as well as the file name and its mime type. Using Python’s request module, a request could look like this:\nimport requests, json\n\nparams = {...} // resource parameters\nfiles = {'file': (filename, open(path + filename, 'rb'), mimetype)} // filename, binary data, and mime type\n\nr = requests.post(knora_url + '/resources',\n                  data={'json': json.dumps(params)},\n                  files=files,\n                  headers=None)\nThe binary data is saved to a temporary location by Knora. The route then creates a SipiResponderConversionPathRequestV1 representing the information about the file (i.e. the temporary path to the file) to be attached to the new resource. Along with the other parameters, it is sent to the resources responder.\nSee Further Handling of the GUI and the non GUI-case in the Resources Responder for details of how the resources responder then handles the request.","title":"Create a new Resource with a Digital Representation"},{"location":"/05-sipi/sipi-and-knora.html#change-the-digital-representation-of-a-resource","text":"The request is taken care of in ValuesRouteV1.scala. The multipart PUT request is handled in path v1/filevalue/{resIri} which receives the resource Iri as a part of the URL: The submitted file will update the existing file values of the given resource.\nFor the request, no json parameters are required. So its body just consists of the binary data (see Create a new Resource with a Digital Representation). The values route stores the submitted binaries as a temporary file and creates a SipiResponderConversionPathRequestV1. A ChangeFileValueRequestV1 containing the resource Iri and the message for Sipi is then created and sent to the values responder.\nSee Further Handling of the GUI and the non GUI-case in the Values Responder for details of how the values responder then handles the request.","title":"Change the Digital Representation of a Resource"},{"location":"/05-sipi/sipi-and-knora.html#further-handling-of-the-gui-and-the-non-gui-case-in-the-resources-responder","text":"Once a SipiResponderConversionFileRequestV1 (GUI case) or a SipiResponderConversionPathRequestV1 (non-GUI case) has been created and passed to the resources responder, the GUI and the non-GUI case can be handled in a very similar way. This is why they are both implementations of the trait SipiResponderConversionRequestV1.\nThe resource responder calls the ontology responder to check if all required properties were submitted for the given resource type. Also it is checked if the given resource type may have a digital representation. The resources responder then sends a message to Sipi responder that does a request to the Sipi server. Depending on the type of the message (SipiResponderConversionFileRequestV1 or SipiResponderConversionPathRequestV1), a different Sipi route is called. In the first case (GUI case), the file is already managed by Sipi and only the filename has to be indicated. In the latter case, Sipi is told about the location where Knora has saved the binary data to.\nTo make this handling easy for Knora, both messages have their own implementation for creating the parameters for Sipi (declared in the trait as toFormData). If Knora deals with a SipiResponderConversionPathRequestV1, it has to delete the temporary file after it has been processed by SIPI. Here, we assume that we deal with an image.\nFor both cases, Sipi returns the same answer containing the following information:\nfile_type: the type of the file that has been handled by Sipi (image | video | audio | text | binary) mimetype_full and mimetype_thumb: mime types of the full image representation and the thumbnail original_mimetype: the mime type of the original file original_filename: the name of the original file nx_full, ny_full, nx_thumb, and ny_thumb: the x and y dimensions of both the full image and the thumbnail filename_full and filename_full: the names of the full image and the thumbnail (needed to request the images from Sipi)\nThe file_type is important because representations for resources are restricted to media types: image, audio, video or a generic binary file. If a resource type requires an image representations (subclass of StillImageRepresentation), the file_type has to be an image. Otherwise, the ontology’s restrictions would be violated. Because of this requirement, there is a construct fileType2FileValueProperty mapping file types to file value properties. Also all the possible file types are defined in enumeration.\nDepending on the given file type, Sipi responder can create the apt message (here: StillImageFileValueV1) to save the data to the triplestore.","title":"Further Handling of the GUI and the Non-GUI case in the Resources Responder"},{"location":"/05-sipi/sipi-and-knora.html#further-handling-of-the-gui-and-the-non-gui-case-in-the-values-responder","text":"In the values responder, ChangeFileValueRequestV1 is passed to the method changeFileValueV1. Unlike ordinary value change requests, the Iris of the value objects to be updated are not known yet. Because of this, all the existing file values of the given resource Iri have to be queried first. Also their quality levels are queried because in case of a StillImageFileValue, we have to deal with a file value for the thumbnail and another one for the full quality representation. When these two file values are being updated, the quality levels have to be considered for the sake of consistency (otherwise a full quality value’s knora-base:previous-value may point to a thumbnail file value).\nWith the file values being returned, we actually know about the current Iris of the value objects. Now the Sipi responder is called to handle the file conversion request (see Further Handling of the GUI and the non GUI-case in the Resources Responder). After that, it is checked that the file_type returned by Sipi responder corresponds to the property type of the existing file values. For example, if the file_type is an image, the property pointing to the current file values must be a hasStillImageFileValue. Otherwise, the user submitted a non image file that has to be rejected.\nDepending on the file_type, messages of type ChangeValueRequestV1 can be created. For each existing file value, such a message is instantiated containing the current value Iri and the new value to be created (returned by the sipi responder). These messages are passed to changeValueV1 because with the described handling done in changeFileValueV1, the file values can be changed like any other value type.\nIn case of success, a ChangeFileValueResponseV1 is sent back to the client, containing a list of the single ChangeValueResponseV1.","title":"Further Handling of the GUI and the non-GUI case in the Values Responder"},{"location":"/05-sipi/sipi-and-knora.html#retrieving-files-from-sipi","text":"","title":"Retrieving Files from Sipi"},{"location":"/05-sipi/sipi-and-knora.html#url-creation","text":"Binary representions of Knora locations are served by Sipi. For each file value, Knora creates several locations representing different quality levels:\n\"resinfo\": {\n   \"locations\": [\n      {\n         \"duration\": ​0,\n         \"nx\": ​95,\n         \"path\": \"http://sipiserver:port/knora/incunabula_0000000002.jpg/full/full/0/default.jpg\",\n         \"ny\": ​128,\n         \"fps\": ​0,\n         \"format_name\": \"JPEG\",\n         \"origname\": \"ad+s167_druck1=0001.tif\",\n         \"protocol\": \"file\"\n      },\n      {\n         \"duration\": ​0,\n          \"nx\": ​82,\n          \"path\": \"http://sipiserver:port/knora/incunabula_0000000002.jp2/full/82,110/0/default.jpg\",\n          \"ny\": ​110,\n          \"fps\": ​0,\n          \"format_name\": \"JPEG2000\",\n          \"origname\": \"ad+s167_druck1=0001.tif\",\n          \"protocol\": \"file\"\n      },\n      {\n          \"duration\": ​0,\n          \"nx\": ​163,\n          \"path\": \"http://sipiserver:port/knora/incunabula_0000000002.jp2/full/163,219/0/default.jpg\",\n          \"ny\": ​219,\n          \"fps\": ​0,\n          \"format_name\": \"JPEG2000\",\n          \"origname\": \"ad+s167_druck1=0001.tif\",\n          \"protocol\": \"file\"\n      }\n      ...\n   ],\n\"restype_label\": \"Seite\",\n\"resclass_has_location\": true,\nEach of these paths has to be handled by the browser by making a call to Sipi, obtaining the binary representation in the desired quality. To deal with different image quality levels, Sipi implements the IIIF standard. The different quality level paths are created by Knora in ValueUtilV1.\nWhenever Sipi serves a binary representation of a Knora file value (indicated by using the prefix knora in the path), it has to make a request to Knora’s Sipi responder to get the user’s permissions on the requested file. Sipi’s request to Knora contains a cookie with the Knora session id the user has obtained when logging in to Knora: As a response to a successful login, Knora returns the user’s session id and this id is automatically sent to Sipi by the browser, setting a second cookie for the communication with Sipi. The reason the Knora session id is set in two cookies, is the fact that cookies can not be shared among different domains. Since Knora and Sipi are likely to be running under different domains, this solution offers the necessary flexibility.","title":"URL creation"},{"location":"/05-sipi/sipi-and-knora.html#sharing-the-session-id-with-sipi","text":"Whenever a file is requested, Sipi asks Knora about the currents user’s permissions on the given file. This is achieved by sharing the Knora session id with Sipi. When the user logs in to Knora using his browser, a request is sent to Sipi submitting the session id the user got back from Knora, setting a second session cookie. Now the user has two session cookies containing the same session id: one for the communication with Knora and one for the communication with Sipi. However, Sipi does not handle sessions. It just sends the given Knora session id to Knora.","title":"Sharing the Session ID with Sipi"}]}