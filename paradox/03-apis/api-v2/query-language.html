<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="docs">
<meta name="generator" content="Paradox, paradox-material-theme=0.4.0, mkdocs-material=2.2.2">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.language" content="">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="docs">
<link rel="shortcut icon" href="../../cloud">
<title>Gravsearch: Virtual Graph Search Â· Knora Documentation</title>
<link rel="stylesheet" href="../../assets/stylesheets/application.7a4cdee3.css">
<link rel="stylesheet" href="../../assets/stylesheets/application-palette.792431c1.css">
<link rel="stylesheet" href="../../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../../lib/prettify/prettify.css">
<script src="../../lib/modernizr/modernizr.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../../assets/stylesheets/paradox-material-theme.css">
</head>
<body
data-md-color-primary="blue"
data-md-color-accent="yellow"
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
<label class="md-overlay" data-md-component="overlay" for="drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../../index.html" title="Knora Documentation" class="md-header-nav__button md-logo">
<i class="md-icon">cloud</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
Knora Documentation
</span>
<span class="md-header-nav__topic">
Gravsearch: Virtual Graph Search
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="search"></label>
<div class="md-search__inner">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
<label class="md-icon md-search__icon" for="search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/dhlab-basel/Knora/docs"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
dhlab-basel/Knora/docs
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<span class="md-nav__button md-logo">
<i class="md-icon">cloud</i>
</span>
<a href="../../index.html" title="Knora Documentation">
Knora Documentation
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/dhlab-basel/Knora/docs"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
dhlab-basel/Knora/docs
</div>
</a>

</div>
<ul>
  <li><a href="../../01-introduction/index.html" class="page">Introduction</a>
  <ul>
    <li><a href="../../01-introduction/what-is-knora.html" class="page">What Is Knora?</a></li>
    <li><a href="../../01-introduction/data-formats.html" class="page">Data Formats in Knora</a></li>
    <li><a href="../../01-introduction/standoff-rdf.html" class="page">Standoff/RDF Text Markup</a></li>
    <li><a href="../../01-introduction/example-project.html" class="page">An Example Project</a></li>
  </ul></li>
  <li><a href="../../02-knora-ontologies/index.html" class="page">Knora Ontologies</a>
  <ul>
    <li><a href="../../02-knora-ontologies/introduction.html" class="page">Introduction</a></li>
    <li><a href="../../02-knora-ontologies/knora-base.html" class="page">The Knora Base Ontology</a></li>
    <li><a href="../../02-knora-ontologies/salsah-gui.html" class="page">The SALSAH GUI Ontology</a></li>
  </ul></li>
  <li><a href="../../03-apis/index.html" class="page">The Knora APIs</a>
  <ul>
    <li><a href="../../03-apis/api-v1/index.html" class="page">Knora API v1</a></li>
    <li><a href="../../03-apis/api-v2/index.html" class="page">Knora API v2</a></li>
    <li><a href="../../03-apis/api-admin/index.html" class="page">Knora Admin API</a></li>
  </ul></li>
  <li><a href="../../04-deployment/index.html" class="page">Deploying Knora</a>
  <ul>
    <li><a href="../../04-deployment/getting-started.html" class="page">Getting Started with Knora</a></li>
    <li><a href="../../04-deployment/configuration.html" class="page">Configuration</a></li>
  </ul></li>
  <li><a href="../../05-internals/index.html" class="page">Knora Internals</a>
  <ul>
    <li><a href="../../05-internals/design/index.html" class="page">Design</a></li>
    <li><a href="../../05-internals/development/index.html" class="page">Development</a></li>
  </ul></li>
  <li><a href="../../06-salsah/index.html" class="page">The SALSAH 1 GUI</a></li>
  <li><a href="../../07-sipi/index.html" class="page">The Sipi Media Server</a>
  <ul>
    <li><a href="../../07-sipi/setup-sipi-for-knora.html" class="page">Setting Up Sipi for Knora</a></li>
    <li><a href="../../07-sipi/sipi-and-knora.html" class="page">Interaction Between Sipi and Knora</a></li>
  </ul></li>
  <li><a href="../../faq.html" class="page">Frequently Asked Questions</a></li>
  <li><a href="../../00-release-notes/index.html" class="page">Release Notes</a>
  <ul>
    <li><a href="../../00-release-notes/v1.1.0.html" class="page">v1.1.0 Release Notes</a></li>
    <li><a href="../../00-release-notes/v1.2.0.html" class="page">v1.2.0 Release Notes</a></li>
    <li><a href="../../00-release-notes/v1.3.0.html" class="page">v1.3.0 Release Notes</a></li>
    <li><a href="../../00-release-notes/v1.4.0.html" class="page">v1.4.0 Release Notes</a></li>
    <li><a href="../../00-release-notes/v1.5.0.html" class="page">v1.5.0 Release Notes</a></li>
    <li><a href="../../00-release-notes/v1.6.0.html" class="page">v1.6.0 Release Notes</a></li>
    <li><a href="../../00-release-notes/v1.7.0.html" class="page">v1.7.x Release Notes</a></li>
    <li><a href="../../00-release-notes/v2.x.x.html" class="page">v2.x.x Release Notes</a></li>
    <li><a href="../../00-release-notes/v3.x.x.html" class="page">v3.x.x Release Notes</a></li>
    <li><a href="../../00-release-notes/v4.x.x.html" class="page">v4.x.x Release Notes</a></li>
    <li><a href="../../00-release-notes/v5.x.x.html" class="page">v5.x.x Release Notes</a></li>
    <li><a href="../../00-release-notes/v6.x.x.html" class="page">v6.x.x Release Notes</a></li>
    <li><a href="../../00-release-notes/next.html" class="page">Release Notes for Next Release</a></li>
    <li><a href="../../00-release-notes/migration.html" class="page">Migration Notes</a></li>
  </ul></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-virtual-graph-search" class="header">Gravsearch: Virtual Graph Search</a>
  <ul>
    <li><a href="../../03-apis/api-v2/query-language.html#basic-concept" class="header">Basic Concept</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#submitting-gravsearch-queries" class="header">Submitting Gravsearch Queries</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-and-api-schemas" class="header">Gravsearch and API Schemas</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#main-and-dependent-resources" class="header">Main and Dependent Resources</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#virtual-incoming-links" class="header">Virtual incoming Links</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#graph-patterns-and-result-graphs" class="header">Graph Patterns and Result Graphs</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#permission-checking" class="header">Permission Checking</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#inference" class="header">Inference</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-syntax" class="header">Gravsearch Syntax</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-by-example" class="header">Gravsearch by Example</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#type-inference" class="header">Type Inference</a></li>
  </ul></li>
</ul>
</nav>

<div class="md-nav__title--site md-version" title="Version">
<i class="md-icon">label_outline</i> 6.0.0
</div>
</nav>

</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="toc">Table of contents</label>
<ul>
  <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-virtual-graph-search" class="header">Gravsearch: Virtual Graph Search</a>
  <ul>
    <li><a href="../../03-apis/api-v2/query-language.html#basic-concept" class="header">Basic Concept</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#submitting-gravsearch-queries" class="header">Submitting Gravsearch Queries</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-and-api-schemas" class="header">Gravsearch and API Schemas</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#main-and-dependent-resources" class="header">Main and Dependent Resources</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#virtual-incoming-links" class="header">Virtual incoming Links</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#graph-patterns-and-result-graphs" class="header">Graph Patterns and Result Graphs</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#permission-checking" class="header">Permission Checking</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#inference" class="header">Inference</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-syntax" class="header">Gravsearch Syntax</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-by-example" class="header">Gravsearch by Example</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#type-inference" class="header">Type Inference</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<!---
Copyright Â© 2015-2019 the contributors (see Contributors.md).

This file is part of Knora.

Knora is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as published
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

Knora is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public
License along with Knora.  If not, see <http://www.gnu.org/licenses/>.
-->
<h1><a href="#gravsearch-virtual-graph-search" name="gravsearch-virtual-graph-search" class="anchor"><span class="anchor-link"></span></a>Gravsearch: Virtual Graph Search</h1>
<div class="toc ">
<ul>
  <li><a href="../../03-apis/api-v2/query-language.html#basic-concept" class="header">Basic Concept</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#submitting-gravsearch-queries" class="header">Submitting Gravsearch Queries</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-and-api-schemas" class="header">Gravsearch and API Schemas</a>
  <ul>
    <li><a href="../../03-apis/api-v2/query-language.html#using-the-simple-schema" class="header">Using the Simple Schema</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#using-the-complex-schema" class="header">Using the Complex Schema</a></li>
  </ul></li>
  <li><a href="../../03-apis/api-v2/query-language.html#main-and-dependent-resources" class="header">Main and Dependent Resources</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#virtual-incoming-links" class="header">Virtual incoming Links</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#graph-patterns-and-result-graphs" class="header">Graph Patterns and Result Graphs</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#permission-checking" class="header">Permission Checking</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#inference" class="header">Inference</a></li>
  <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-syntax" class="header">Gravsearch Syntax</a>
  <ul>
    <li><a href="../../03-apis/api-v2/query-language.html#supported-sparql-syntax" class="header">Supported SPARQL Syntax</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#resources-properties-and-values" class="header">Resources, Properties, and Values</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#filtering-on-values" class="header">Filtering on Values</a>
    <ul>
      <li><a href="../../03-apis/api-v2/query-language.html#filtering-on-values-in-the-simple-schema" class="header">Filtering on Values in the Simple Schema</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#filtering-on-values-in-the-complex-schema" class="header">Filtering on Values in the Complex Schema</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#date-comparisons" class="header">Date Comparisons</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#searching-for-matching-words" class="header">Searching for Matching Words</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#filtering-text-by-language" class="header">Filtering Text by Language</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#regular-expressions" class="header">Regular Expressions</a></li>
    </ul></li>
    <li><a href="../../03-apis/api-v2/query-language.html#searching-for-text-markup" class="header">Searching for Text Markup</a>
    <ul>
      <li><a href="../../03-apis/api-v2/query-language.html#matching-text-in-a-standoff-tag" class="header">Matching Text in a Standoff Tag</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#matching-standoff-links" class="header">Matching Standoff Links</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#matching-standoff-dates" class="header">Matching Standoff Dates</a></li>
      <li><a href="../../03-apis/api-v2/query-language.html#matching-ancestor-tags" class="header">Matching Ancestor Tags</a></li>
    </ul></li>
    <li><a href="../../03-apis/api-v2/query-language.html#construct-clause" class="header">CONSTRUCT Clause</a></li>
  </ul></li>
  <li><a href="../../03-apis/api-v2/query-language.html#gravsearch-by-example" class="header">Gravsearch by Example</a>
  <ul>
    <li><a href="../../03-apis/api-v2/query-language.html#getting-all-the-components-of-a-compound-resource" class="header">Getting All the Components of a Compound Resource</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#traversing-multiple-links" class="header">Traversing Multiple Links</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#requesting-a-graph-starting-with-a-known-resource" class="header">Requesting a Graph Starting with a Known Resource</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#searching-for-a-list-value-referring-to-a-particular-list-node" class="header">Searching for a List Value Referring to a Particular List Node</a></li>
  </ul></li>
  <li><a href="../../03-apis/api-v2/query-language.html#type-inference" class="header">Type Inference</a>
  <ul>
    <li><a href="../../03-apis/api-v2/query-language.html#type-annotations" class="header">Type Annotations</a></li>
    <li><a href="../../03-apis/api-v2/query-language.html#inconsistent-types" class="header">Inconsistent Types</a></li>
  </ul></li>
</ul>
</div>
<h2><a href="#basic-concept" name="basic-concept" class="anchor"><span class="anchor-link"></span></a>Basic Concept</h2>
<p>Gravsearch is intended to offer the advantages of SPARQL endpoints (particularly the ability to perform queries using complex search criteria) while avoiding their drawbacks in terms of performance and security (see <a href="https://daverog.wordpress.com/2013/06/04/the-enduring-myth-of-the-sparql-endpoint/">The Enduring Myth of the SPARQL Endpoint</a>). It also has the benefit of enabling clients to work with a simpler RDF data model than the one Knora actually uses to store data in the triplestore, and makes it possible to provide better error-checking.</p>
<p>Rather than being processed directly by the triplestore, a Gravsearch query is interpreted by Knora, which enforces certain restrictions on the query, and implements paging and permission checking. The API server generates SPARQL based on the Gravsearch query submitted, queries the triplestore, filters the results according to the user&rsquo;s permissions, and returns each page of query results as a Knora API response. Thus, Gravsearch is a hybrid between a RESTful API and a SPARQL endpoint.</p>
<p>A Gravsearch query conforms to a subset of the syntax of a SPARQL <a href="https://www.w3.org/TR/sparql11-query/#construct">CONSTRUCT</a> query, with some additional restrictions and functionality. In particular, the variable representing the top-level (or &lsquo;main&rsquo;) resource that will appear in each search result must be identified, statements must be included to specify the types of the entities being queried, OFFSET is used to control paging, and <code>ORDER BY</code> is used to sort the results.</p>
<p>It is certainly possible to write Gravsearch queries by hand, but we expect that in general, they will be automatically generated by client software, e.g. by a client user interface.</p>
<h2><a href="#submitting-gravsearch-queries" name="submitting-gravsearch-queries" class="anchor"><span class="anchor-link"></span></a>Submitting Gravsearch Queries</h2>
<p>The recommended way to submit a Gravsearch query is via HTTP POST:</p>
<pre><code>HTTP POST to http://host/v2/searchextended
</code></pre>
<p>This works like <a href="https://www.w3.org/TR/sparql11-protocol/#query-via-post-direct">query via POST directly</a> in the <a href="https://www.w3.org/TR/sparql11-protocol/">SPARQL 1.1 Protocol</a>: the query is sent unencoded as the HTTP request message body, in the UTF-8 charset.</p>
<p>It is also possible to submit a Gravsearch query using HTTP GET. The entire query must be URL-encoded and included as the last element of the URL path:</p>
<pre><code>HTTP GET to http://host/v2/searchextended/QUERY
</code></pre>
<p>The response to a Gravsearch query is an RDF graph, which can be requested in various formats (see <a href="reading-and-searching-resources.html#responses-describing-resources">Responses Describing Resources</a>).</p>
<p>To request the number of results rather than the results themselves, you can do a count query:</p>
<pre><code>HTTP POST to http://host/v2/searchextended/count
</code></pre>
<p>The response to a count query request is an object with one predicate, <code>http://schema.org/numberOfItems</code>, with an integer value.</p>
<h2><a href="#gravsearch-and-api-schemas" name="gravsearch-and-api-schemas" class="anchor"><span class="anchor-link"></span></a>Gravsearch and API Schemas</h2>
<p>A Gravsearch query can be written in either of the two <a href="introduction.html#api-schema">Knora API v2 schemas</a>. The simple schema is easier to work with, and is sufficient if you don&rsquo;t need to query anything below the level of a Knora value. If your query needs to refer to list nodes or standoff markup, you must use the complex schema. Each query must use a single schema, with one exception (see <a href="query-language.html#date-comparisons">Date Comparisons</a>).</p>
<p>Gravsearch query results can be requested in the simple or complex schema; see <a href="introduction.html#api-schema">API Schema</a>.</p>
<h3><a href="#using-the-simple-schema" name="using-the-simple-schema" class="anchor"><span class="anchor-link"></span></a>Using the Simple Schema</h3>
<p>To write a query in the simple schema, use the <code>knora-api</code> ontology in the simple schema, and use the simple schema for any other Knora ontologies the query refers to, e.g.:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;
PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
</code></pre>
<p>In the simple schema, Knora values are represented as literals, which can be used <code>FILTER</code> expressions (see <a href="query-language.html#filtering-on-values-in-the-simple-schema">Filtering on Values in the Simple Schema</a>).</p>
<h3><a href="#using-the-complex-schema" name="using-the-complex-schema" class="anchor"><span class="anchor-link"></span></a>Using the Complex Schema</h3>
<p>To write a query in the complex schema, use the <code>knora-api</code> ontology in the complex schema, and use the complex schema for any other Knora ontologies the query refers to, e.g.:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/simple/v2#&gt;
</code></pre>
<p>In the complex schema, Knora values are represented as objects belonging to subclasses of <code>knora-api:Value</code>, e.g. <code>knora-api:TextValue</code>, and have predicates of their own, which can be used in <code>FILTER</code> expressions (see <a href="query-language.html#filtering-on-values-in-the-complex-schema">Filtering on Values in the Complex Schema</a>).</p>
<h2><a href="#main-and-dependent-resources" name="main-and-dependent-resources" class="anchor"><span class="anchor-link"></span></a>Main and Dependent Resources</h2>
<p>The main resource is the top-level resource in a search result. Other resources that are in some way connected to the main resource are referred to as dependent resources. If the client asks for a resource A relating to a resource B, then all matches for A will be presented as main resources and those for B as dependent resources. The main resource must be represented by a variable, marked with <code>knora-api:isMainResource</code>, as explained under <a href="query-language.html#construct-clause">CONSTRUCT Clause</a>.</p>
<h2><a href="#virtual-incoming-links" name="virtual-incoming-links" class="anchor"><span class="anchor-link"></span></a>Virtual incoming Links</h2>
<p>Depending on the ontology design, a resource A points to B or vice versa. For example, a page A is part of a book B using the property <code>incunabula:partOf</code>. If A is marked as the main resource, then B is nested as a dependent resource in its link value <code>incunabula:partOfValue</code>. But in case B is marked as the main resource, B does not have a link value pointing to A because in fact B is pointed to by A. Instead, B has a virtual property <code>knora-api:hasIncomingLink</code> containing A&rsquo;s link value:</p>
<pre><code>&quot;knora-api:hasIncomingLinkValue&quot; : {
    &quot;@id&quot; : &quot;http://rdfh.ch/A/values/xy&quot;,
    &quot;@type&quot; : &quot;knora-api:LinkValue&quot;,
    &quot;knora-api:linkValueHasSource&quot; : {
      &quot;@id&quot; : &quot;http://rdfh.ch/A&quot;,
      &quot;@type&quot; : &quot;incunabula:page&quot;,
      &quot;incunabula:partOfValue&quot; : {
        &quot;@id&quot; : &quot;http://rdfh.ch/A/values/xy&quot;,
        &quot;@type&quot; : &quot;knora-api:LinkValue&quot;,
        &quot;knora-api:linkValueHasTargetIri&quot; : {
          &quot;@id&quot; : &quot;http://rdfh.ch/B&quot;
        }
      }
    }
  },
</code></pre>
<p>Note that the virtually inserted link value inverts the relation by using <code>knora-api:linkValueHasSource</code>. The source of the link is A and its target B is only represented by an Iri (<code>knora-api:linkValueHasTargetIri</code>) since B is the main resource. </p>
<h2><a href="#graph-patterns-and-result-graphs" name="graph-patterns-and-result-graphs" class="anchor"><span class="anchor-link"></span></a>Graph Patterns and Result Graphs</h2>
<p>The WHERE clause of a Gravsearch query specifies a graph pattern. Each query result will match this graph pattern, and will have the form of a graph whose starting point is a main resource. The query&rsquo;s graph pattern, and hence each query result graph, can span zero more levels of relations between resources. For example, a query could request regions in images on pages of books written by a certain author, articles by authors who were students of a particular professor, or authors of texts that refer to events that took place within a certain date range.</p>
<h2><a href="#permission-checking" name="permission-checking" class="anchor"><span class="anchor-link"></span></a>Permission Checking</h2>
<p>Each matching resource is returned only if the client has permission to see all the values of that resource that matched the criteria given in the WHERE clause. If a matching resource contains a value that was mentioned in the WHERE clause, but the client does not have permission to see that value, the resource is not returned in the results, and is instead replaced by a proxy resource called <code>knora-api:ForbiddenResource</code>.</p>
<h2><a href="#inference" name="inference" class="anchor"><span class="anchor-link"></span></a>Inference</h2>
<p>Gravsearch queries are understood to imply <a href="https://www.w3.org/TR/rdf11-mt/">RDFS reasoning</a>. Depending on the triplestore being used, this may be implemented using the triplestore&rsquo;s own reasoner or by query expansion in Knora.</p>
<p>This means that if a statement pattern specifies a property, the pattern will also match subproperties of that property, and if a statement specifies that a subject has a particular <code>rdf:type</code>, the statement will also match subjects belonging to subclasses of that type.</p>
<h2><a href="#gravsearch-syntax" name="gravsearch-syntax" class="anchor"><span class="anchor-link"></span></a>Gravsearch Syntax</h2>
<p>Every Gravsearch query is a valid SPARQL 1.1 <a href="https://www.w3.org/TR/sparql11-query/#construct">CONSTRUCT</a> query. However, Gravsearch only supports a subset of the elements that can be used in a SPARQL Construct query, and a Gravsearch <a href="query-language.html#construct-clause">CONSTRUCT Clause</a> has to indicate which variable is to be used for the main resource in each search result.</p>
<h3><a href="#supported-sparql-syntax" name="supported-sparql-syntax" class="anchor"><span class="anchor-link"></span></a>Supported SPARQL Syntax</h3>
<p>The current version of Gravsearch accepts <code>CONSTRUCT</code> queries whose <code>WHERE</code> clauses use the following patterns, with the specified restrictions:</p>
<ul>
  <li><code>OPTIONAL</code>: cannot be nested in a <code>UNION</code>.</li>
  <li><code>UNION</code>: cannot be nested in a <code>UNION</code>.</li>
  <li><code>FILTER</code>: may contain a complex expression using the Boolean operators AND and OR, as well as comparison operators. The left argument of a comparison operator must be a query variable. A Knora ontology entity IRI used in a <code>FILTER</code> must be a property IRI.</li>
  <li><code>FILTER NOT EXISTS</code></li>
  <li><code>MINUS</code></li>
  <li><code>OFFSET</code>: the <code>OFFSET</code> is needed for paging. It does not actually refer to the number of triples to be returned, but to the requested page of results. The default value is 0, which refers to the first page of results. The number of results per page is defined in <code>app/v2</code> in <code>application.conf</code>.</li>
  <li><code>ORDER BY</code>: In SPARQL, the result of a <code>CONSTRUCT</code> query is an unordered set of triples. However, a Gravsearch query returns an ordered list of resources, which can be ordered by the values of specified properties. If the query is written in the complex schema, items below the level of Knora values may not be used in <code>ORDER BY</code>.</li>
  <li><code>BIND</code>: The value assigned must be a Knora resource IRI.</li>
</ul>
<h3><a href="#resources-properties-and-values" name="resources-properties-and-values" class="anchor"><span class="anchor-link"></span></a>Resources, Properties, and Values</h3>
<p>Resources can be represented either by an IRI or by a variable, except for the main resource, which must be represented by a variable.</p>
<p>It is possible to do a Gravsearch query in which the IRI of the main resource is already known, e.g. to request specific information about that resource and perhaps about linked resources. In this case, the IRI of the main resource must be assigned to a variable using <code>BIND</code>.</p>
<p>Properties can be represented by an IRI or a query variable. If a property is represented by a query variable, it can be restricted to certain property IRIs using a <code>FILTER</code>.</p>
<p>A Knora value (i.e. a value attached to a <code>knora-api:Resource</code>) must be represented as a query variable.</p>
<h3><a href="#filtering-on-values" name="filtering-on-values" class="anchor"><span class="anchor-link"></span></a>Filtering on Values</h3>
<h4><a href="#filtering-on-values-in-the-simple-schema" name="filtering-on-values-in-the-simple-schema" class="anchor"><span class="anchor-link"></span></a>Filtering on Values in the Simple Schema</h4>
<p>In the simple schema, a variable representing a Knora value can be used directly in a <code>FILTER</code> expression. For example:</p>
<pre><code>?book incunabula:title ?title .
FILTER(?title = &quot;ZeitglÃ¶cklein des Lebens und Leidens Christi&quot;)
</code></pre>
<p>Here the type of <code>?title</code> is <code>xsd:string</code>.</p>
<p>The following Knora value types can be compared with literals in <code>FILTER</code> expressions in the simple schema:</p>
<ul>
  <li>Text values (<code>xsd:string</code>)</li>
  <li>Uri values (<code>xsd:anyURI</code>)</li>
  <li>Integer values (<code>xsd:integer</code>)</li>
  <li>Decimal values (<code>xsd:decimal</code>)</li>
  <li>Boolean values (<code>xsd:boolean</code>)</li>
  <li>Date values (<code>knora-api:Date</code>)</li>
</ul>
<p>A Knora value may not be represented as the literal object of a predicate; for example, this is not allowed:</p>
<pre><code>?book incunabula:title &quot;ZeitglÃ¶cklein des Lebens und Leidens Christi&quot; .
</code></pre>
<h4><a href="#filtering-on-values-in-the-complex-schema" name="filtering-on-values-in-the-complex-schema" class="anchor"><span class="anchor-link"></span></a>Filtering on Values in the Complex Schema</h4>
<p>In the complex schema, variables representing Knora values are not literals. You must add something to the query (generally a statement) to get a literal from a Knora value. For example:</p>
<pre><code>?book incunabula:title ?title .
?title knora-api:valueAsString &quot;ZeitglÃ¶cklein des Lebens und Leidens Christi&quot; .
</code></pre>
<p>Here the type of <code>?title</code> is <code>knora-api:TextValue</code>. Note that no <code>FILTER</code> is needed in this example. But if you want to use a different comparison operator, you need a <code>FILTER</code>:</p>
<pre><code>?page incunabula:seqnum ?seqnum .
?seqnum knora-api:intValueAsInt ?seqnumInt .
FILTER(?seqnumInt &lt;= 10)
</code></pre>
<p>To match a date value in the complex schema, you must use the <code>knora-api:toSimpleDate</code> function in a <code>FILTER</code> (see <a href="query-language.html#date-comparisons">Date Comparisons</a>). The predicates of <code>knora-api:DateValue</code> (<code>knora-api:dateValueHasStartYear</code>, etc.) are not available in Gravsearch.</p>
<h4><a href="#date-comparisons" name="date-comparisons" class="anchor"><span class="anchor-link"></span></a>Date Comparisons</h4>
<p>In the simple schema, you can compare a date value directly with a <code>knora-api:Date</code> in a <code>FILTER</code>:</p>
<pre><code>?book incunabula:pubdate ?pubdate .
FILTER(?pubdate &lt; &quot;JULIAN:1497&quot;^^knora-api:Date)
</code></pre>
<p>In the complex schema, you must use the function <code>knora-api:toSimpleDate</code>, passing it the variable representing the date value. The date literal used in the comparison must still be a <code>knora-api:Date</code> in the simple schema. This is the only case in which you can use both schemas in a single query:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX knora-api-simple: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
    ?book knora-api:isMainResource true .
    ?book incunabula:pubdate ?pubdate .
} WHERE {
    ?book a incunabula:book .
    ?book incunabula:pubdate ?pubdate .
    FILTER(knora-api:toSimpleDate(?pubdate) &lt; &quot;JULIAN:1497&quot;^^knora-api-simple:Date)
} ORDER BY ?pubdate
</code></pre>
<p>You can also use <code>knora-api:toSimpleDate</code> with to search for date tags in standoff text markup (see <a href="query-language.html#matching-standoff-dates">Matching Standoff Dates</a>).</p>
<h4><a href="#searching-for-matching-words" name="searching-for-matching-words" class="anchor"><span class="anchor-link"></span></a>Searching for Matching Words</h4>
<p>The function <code>knora-api:match</code> searches for matching words anywhere in a text value, and is implemented using a full-text search index if available. The first argument must be a variable of type <code>xsd:string</code>, and the second argument is a string containing the words to be matched, separated by spaces. The words to be matched are separated by spaces in a string literal. For example, to search for titles that contain the words &lsquo;ZeitglÃ¶cklein&rsquo; and &lsquo;Lebens&rsquo; in the simple schema:</p>
<pre><code>FILTER knora-api:match(?title, &quot;ZeitglÃ¶cklein Lebens&quot;)
</code></pre>
<p>In the complex schema:</p>
<pre><code>?title knora-api:valueAsString ?titleStr .
FILTER knora-api:match(?titleStr, &quot;ZeitglÃ¶cklein Lebens&quot;)
</code></pre>
<p>If <code>knora-api:match</code> is used in a <code>FILTER</code>, it must be the only expression in the <code>FILTER</code>.</p>
<h4><a href="#filtering-text-by-language" name="filtering-text-by-language" class="anchor"><span class="anchor-link"></span></a>Filtering Text by Language</h4>
<p>To filter a text value by language in the simple schema, use the SPARQL <code>lang</code> function on the text value, e.g.:</p>
<pre><code>FILTER(lang(?text) = &quot;fr&quot;)
</code></pre>
<p>In the complex schema, the <code>lang</code> function is not supported. Use the text value&rsquo;s <code>knora-api:textValueHasLanguage</code> predicate instead:</p>
<pre><code>?text knora-api:textValueHasLanguage &quot;fr&quot; .
</code></pre>
<h4><a href="#regular-expressions" name="regular-expressions" class="anchor"><span class="anchor-link"></span></a>Regular Expressions</h4>
<p>The <a href="https://www.w3.org/TR/2013/REC-sparql11-query-20130321/#func-regex">SPARQL <code>regex</code> function</a> is supported. In the simple schema, you can use it directly on the text value, e.g.</p>
<pre><code>?book incunabula:title ?title .
FILTER regex(?title, &quot;Zeit&quot;, &quot;i&quot;)
</code></pre>
<p>In the complex schema, use it on the object of the text value&rsquo;s <code>knora-api:valueAsString</code> predicate:</p>
<pre><code>?book incunabula:title ?title .
?title knora-api:valueAsString ?titleStr .
FILTER regex(?titleStr, &quot;Zeit&quot;, &quot;i&quot;)
</code></pre>
<h3><a href="#searching-for-text-markup" name="searching-for-text-markup" class="anchor"><span class="anchor-link"></span></a>Searching for Text Markup</h3>
<p>To refer to standoff markup in text values, you must write your query in the complex schema.</p>
<p>A <code>knora-api:TextValue</code> can have the property <code>knora-api:textValueHasStandoff</code>, whose objects are the standoff markup tags in the text. You can match the tags you&rsquo;re interested in using <code>rdf:type</code> or other properties of each tag.</p>
<h4><a href="#matching-text-in-a-standoff-tag" name="matching-text-in-a-standoff-tag" class="anchor"><span class="anchor-link"></span></a>Matching Text in a Standoff Tag</h4>
<p>The function <code>knora-api:matchInStandoff</code> searches for standoff tags containing certain terms. The implementation is optimised using the full-text search index if available. The function takes three arguments:</p>
<ol>
  <li>A variable representing the string literal value of a text value.</li>
  <li>A variable representing a standoff tag.</li>
  <li>A string literal containing space-separated search terms.</li>
</ol>
<p>This function can only be used as the top-level expression in a <code>FILTER</code>. For example:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;
PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;

CONSTRUCT {
    ?letter knora-api:isMainResource true .
    ?letter beol:hasText ?text .
} WHERE {
    ?letter a beol:letter .
    ?letter beol:hasText ?text .
    ?text knora-api:valueAsString ?textStr .
    ?text knora-api:textValueHasStandoff ?standoffParagraphTag .
    ?standoffParagraphTag a standoff:StandoffParagraphTag .
    FILTER knora-api:matchInStandoff(?textStr, ?standoffParagraphTag, &quot;Grund Richtigkeit&quot;)
}
</code></pre>
<p>Here we are looking for letters containing the words &ldquo;Grund&rdquo; and &ldquo;Richtigkeit&rdquo; within a single paragraph.</p>
<h4><a href="#matching-standoff-links" name="matching-standoff-links" class="anchor"><span class="anchor-link"></span></a>Matching Standoff Links</h4>
<p>If you are only interested in specifying that a resource has some text value containing a standoff link to another resource, the most efficient way is to use the property <code>knora-api:hasStandoffLinkTo</code>, whose subjects and objects are resources. This property is automatically maintained by Knora. For example:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;

CONSTRUCT {
    ?letter knora-api:isMainResource true .
    ?letter beol:hasText ?text .
} WHERE {
    ?letter a beol:letter .
    ?letter beol:hasText ?text .
    ?letter knora-api:hasStandoffLinkTo ?person .
    ?person a beol:person .
    ?person beol:hasIAFIdentifier ?iafIdentifier .
    ?iafIdentifier knora-api:valueAsString &quot;(VIAF)271899510&quot; .
}
</code></pre>
<p>Here we are looking for letters containing a link to the historian Claude Jordan, who is identified by his Integrated Authority File identifier, <code>(VIAF)271899510</code>.</p>
<p>However, if you need to specify the context in which the link tag occurs, you must use the function <code>knora-api:standoffLink</code>. It takes three arguments:</p>
<ol>
  <li>A variable or IRI representing the resource that is the source of the link.</li>
  <li>A variable representing the standoff link tag.</li>
  <li>A variable or IRI representing the resource that is the target of the link.</li>
</ol>
<p>This function can only be used as the top-level expression in a <code>FILTER</code>. For example:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;
PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;

CONSTRUCT {
    ?letter knora-api:isMainResource true .
    ?letter beol:hasText ?text .
} WHERE {
    ?letter a beol:letter .
    ?letter beol:hasText ?text .
    ?text knora-api:textValueHasStandoff ?standoffLinkTag .
    ?standoffLinkTag a knora-api:StandoffLinkTag .
    FILTER knora-api:standoffLink(?letter, ?standoffLinkTag, ?person)
    ?person a beol:person .
    ?person beol:hasIAFIdentifier ?iafIdentifier .
    ?iafIdentifier knora-api:valueAsString &quot;(VIAF)271899510&quot; .
    ?standoffLinkTag knora-api:standoffTagHasStartParent ?standoffItalicTag .
    ?standoffItalicTag a standoff:StandoffItalicTag .
}
</code></pre>
<p>This has the same effect as the previous example, except that because we are matching the link tag itself, we can specify that its immediate parent is a <code>StandoffItalicTag</code>.</p>
<p>If you actually want to get the target of the link (in this example, <code>?person</code>) in the search results, you need to add a statement like <code>?letter knora-api:hasStandoffLinkTo ?person .</code> to the <code>WHERE</code> clause and to the <code>CONSTRUCT</code> clause:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;
PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;

CONSTRUCT {
    ?letter knora-api:isMainResource true .
    ?letter beol:hasText ?text .
    ?letter knora-api:hasStandoffLinkTo ?person .
} WHERE {
    ?letter a beol:letter .
    ?letter beol:hasText ?text .
    ?text knora-api:textValueHasStandoff ?standoffLinkTag .
    ?standoffLinkTag a knora-api:StandoffLinkTag .
    FILTER knora-api:standoffLink(?letter, ?standoffLinkTag, ?person)
    ?person a beol:person .
    ?person beol:hasIAFIdentifier ?iafIdentifier .
    ?iafIdentifier knora-api:valueAsString &quot;(VIAF)271899510&quot; .
    ?standoffLinkTag knora-api:standoffTagHasStartParent ?standoffItalicTag .
    ?standoffItalicTag a standoff:StandoffItalicTag .
    ?letter knora-api:hasStandoffLinkTo ?person .
}
</code></pre>
<h4><a href="#matching-standoff-dates" name="matching-standoff-dates" class="anchor"><span class="anchor-link"></span></a>Matching Standoff Dates</h4>
<p>You can use the <code>knora-api:toSimpleDate</code> function (see <a href="query-language.html#date-comparisons">Date Comparisons</a>) to match dates in standoff date tags, i.e. instances of <code>knora-api:StandoffDateTag</code> or of one of its subclasses. For example, here we are looking for a text containing an <code>anything:StandoffEventTag</code> (which is a project-specific subclass of <code>knora-api:StandoffDateTag</code>) representing an event that occurred sometime during the month of December 2016:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;
PREFIX knora-api-simple: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
    ?thing knora-api:isMainResource true .
    ?thing anything:hasText ?text .
} WHERE {
    ?thing a anything:Thing .
    ?thing anything:hasText ?text .
    ?text knora-api:textValueHasStandoff ?standoffEventTag .
    ?standoffEventTag a anything:StandoffEventTag .
    FILTER(knora-api:toSimpleDate(?standoffEventTag) = &quot;GREGORIAN:2016-12 CE&quot;^^knora-api-simple:Date)
}
</code></pre>
<h4><a href="#matching-ancestor-tags" name="matching-ancestor-tags" class="anchor"><span class="anchor-link"></span></a>Matching Ancestor Tags</h4>
<p>Suppose we want to search for a standoff date in a paragraph, but we know that the paragraph tag might not be the immediate parent of the date tag. For example, the date tag might be in an italics tag, which is in a paragraph tag. In that case, we can use the inferred property <code>knora-api:standoffTagHasStartAncestor</code>. We can modify the previous example to do this:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX standoff: &lt;http://api.knora.org/ontology/standoff/v2#&gt;
PREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;
PREFIX knora-api-simple: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
    ?thing knora-api:isMainResource true .
    ?thing anything:hasText ?text .
} WHERE {
    ?thing a anything:Thing .
    ?thing anything:hasText ?text .
    ?text knora-api:textValueHasStandoff ?standoffDateTag .
    ?standoffDateTag a knora-api:StandoffDateTag .
    FILTER(knora-api:toSimpleDate(?standoffDateTag) = &quot;GREGORIAN:2016-12-24 CE&quot;^^knora-api-simple:Date)
    ?standoffDateTag knora-api:standoffTagHasStartAncestor ?standoffParagraphTag .
    ?standoffParagraphTag a standoff:StandoffParagraphTag .
}
</code></pre>
<h3><a href="#construct-clause" name="construct-clause" class="anchor"><span class="anchor-link"></span></a>CONSTRUCT Clause</h3>
<p>In the <code>CONSTRUCT</code> clause of a Gravsearch query, the variable representing the main resource must be indicated with <code>knora-api:isMainResource true</code>. Exactly one variable representing a resource must be marked in this way.</p>
<p>Any other statements in the <code>CONSTRUCT</code> clause must also be present in the WHERE clause. If a variable representing a resource or value is used in the <code>WHERE</code> clause but not in the <code>CONSTRUCT</code> clause, the matching resources or values will not be included in the results.</p>
<p>If the query is written in the complex schema, all variables in the <code>CONSTRUCT</code> clause must refer to Knora resources, Knora values, or properties. Data below the level of Knora values may not be mentioned in the <code>CONSTRUCT</code> clause.</p>
<p>Predicates from the <code>rdf</code>, <code>rdfs</code>, and <code>owl</code> ontologies may not be used in the <code>CONSTRUCT</code> clause. The <code>rdfs:label</code> of each matching resource is always returned, so there is no need to mention it in the query.</p>
<h2><a href="#gravsearch-by-example" name="gravsearch-by-example" class="anchor"><span class="anchor-link"></span></a>Gravsearch by Example</h2>
<p>In this section, we provide some sample queries of different complexity to illustrate the usage of Gravsearch.</p>
<h3><a href="#getting-all-the-components-of-a-compound-resource" name="getting-all-the-components-of-a-compound-resource" class="anchor"><span class="anchor-link"></span></a>Getting All the Components of a Compound Resource</h3>
<p>In order to get all the components of a compound resource, the following Gravsearch query can be sent to the API.</p>
<p>In this case, the compound resource is an <code>incunabula:book</code> identified by the IRI <code>http://rdfh.ch/c5058f3a</code> and the components are of type <code>incunabula:page</code> (test data for the Incunabula project). Since inference is assumed, we can use <code>knora-api:StillImageRepresentation</code> (<code>incunabula:page</code> is one of its subclasses). This makes the query more generic and allows for reuse (for instance, a client would like to query different types of compound resources defined in different ontologies).</p>
<p><code>ORDER BY</code> is used to sort the components by their sequence number.</p>
<p><code>OFFSET</code> is set to 0 to get the first page of results.</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
   ?component knora-api:isMainResource true . # marking of the component searched for as the main resource, required
   ?component knora-api:seqnum ?seqnum . # return the sequence number in the response
   ?component knora-api:hasStillImageFileValue ?file . # return the StillImageFile in the response
} WHERE {
   ?component a knora-api:StillImageRepresentation . # restriction of the type of component
   ?component knora-api:isPartOf &lt;http://rdfh.ch/c5058f3a&gt; . # component relates to a compound resource via this property
   ?component knora-api:seqnum ?seqnum . # component must have a sequence number
   ?component knora-api:hasStillImageFileValue ?file . # component must have a StillImageFile
}
ORDER BY ASC(?seqnum) # order by sequence number, ascending
OFFSET 0 # get first page of results
</code></pre>
<p>The <code>incunabula:book</code> with the IRI <code>http://rdfh.ch/c5058f3a</code> has 402 pages. (This result can be obtained by doing a count query; see <a href="query-language.html#submitting-gravsearch-queries">Submitting Gravsearch Queries</a>.) However, with <code>OFFSET 0</code>, only the first page of results is returned. The same query can be sent again with <code>OFFSET 1</code> to get the next page of results, and so forth. When a page of results is not full (see settings in <code>app/v2</code> in <code>application.conf</code>) or is empty, no more results are available.</p>
<p>By design, it is not possible for the client to get more than one page of results at a time; this is intended to prevent performance problems that would be caused by huge responses. A client that wants to download all the results of a query must request each page sequentially.</p>
<p>Let&rsquo;s assume the client is not interested in all of the book&rsquo;s pages, but just in first ten of them. In that case, the sequence number can be restricted using a <code>FILTER</code> that is added to the query&rsquo;s <code>WHERE</code> clause:</p>
<pre><code>FILTER (?seqnum &lt;= 10)
</code></pre>
<p>The first page starts with sequence number 1, so with this <code>FILTER</code> only the first ten pages are returned.</p>
<p>This query would be exactly the same in the complex schema, except for the expansion of the <code>knora-api</code> prefix:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
</code></pre>
<h3><a href="#traversing-multiple-links" name="traversing-multiple-links" class="anchor"><span class="anchor-link"></span></a>Traversing Multiple Links</h3>
<p>Here we are looking for regions of pages that are part of books that have a particular title. In the simple schema:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
  ?region knora-api:isMainResource true ;
    knora-api:isRegionOf ?page .

  ?page incunabula:partOf ?book .

  ?book incunabula:title ?title .
} WHERE {
  ?region a knora-api:Region ;
    knora-api:isRegionOf ?page .

  ?page a incunabula:page ;
    incunabula:partOf ?book .

  ?book incunabula:title ?title .

  FILTER(?title = &quot;ZeitglÃ¶cklein des Lebens und Leidens Christi&quot;)
}
</code></pre>
<p>In the complex schema:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;

CONSTRUCT {
  ?region knora-api:isMainResource true ;
    knora-api:isRegionOf ?page .

  ?page incunabula:partOf ?book .

  ?book incunabula:title ?title .
} WHERE {
  ?region a knora-api:Region ;
    knora-api:isRegionOf ?page .

  ?page a incunabula:page ;
    incunabula:partOf ?book .

  ?book incunabula:title ?title .

  ?title knora-api:valueAsString &quot;ZeitglÃ¶cklein des Lebens und Leidens Christi&quot; .
}
</code></pre>
<p>If we remove the line <code>?book incunabula:title ?title .</code> from the <code>CONSTRUCT</code> clause, so that the <code>CONSTRUCT</code> clause no longer mentions <code>?title</code>, the response will contain the same matching resources, but the titles of those resources will not be included in the response.</p>
<h3><a href="#requesting-a-graph-starting-with-a-known-resource" name="requesting-a-graph-starting-with-a-known-resource" class="anchor"><span class="anchor-link"></span></a>Requesting a Graph Starting with a Known Resource</h3>
<p>Here the IRI of the main resource is already known, and we want specific information about it, as well as about related resources. In this case, the IRI of the main resource must be assigned to a variable using <code>BIND</code>:</p>
<pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
  ?letter knora-api:isMainResource true ;
    beol:creationDate ?date ;
    ?linkingProp1 ?person1 .

  ?person1 beol:hasFamilyName ?familyName .
} WHERE {
  BIND(&lt;http://rdfh.ch/0801/_B3lQa6tSymIq7_7SowBsA&gt; AS ?letter)

  ?letter a beol:letter ;
    beol:creationDate ?date ;
    ?linkingProp1 ?person1 .

  FILTER(?linkingProp1 = beol:hasAuthor || ?linkingProp1 = beol:hasRecipient)

  ?person1 beol:hasFamilyName ?familyName .
} ORDER BY ?date
</code></pre>
<p>This query would be the same in the complex schema, except for the prefix expansions:</p>
<pre><code>PREFIX beol: &lt;http://0.0.0.0:3333/ontology/0801/beol/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
</code></pre>
<h3><a href="#searching-for-a-list-value-referring-to-a-particular-list-node" name="searching-for-a-list-value-referring-to-a-particular-list-node" class="anchor"><span class="anchor-link"></span></a>Searching for a List Value Referring to a Particular List Node</h3>
<p>This is possible only in the complex schema:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/v2#&gt;
PREFIX anything: &lt;http://0.0.0.0:3333/ontology/0001/anything/v2#&gt;

CONSTRUCT {
    ?thing knora-api:isMainResource true .
    ?thing anything:hasListItem ?listItem .
} WHERE {
    ?thing anything:hasListItem ?listItem .
    ?listItem knora-api:listValueAsListNode &lt;http://rdfh.ch/lists/0001/treeList02&gt; .
}
</code></pre>
<h2><a href="#type-inference" name="type-inference" class="anchor"><span class="anchor-link"></span></a>Type Inference</h2>
<p>Gravsearch needs to be able to determine the types of the entities that query variables and IRIs refer to in the <code>WHERE</code> clause. In most cases, it can infer these from context and from the ontologies used. In particular, it needs to know:</p>
<ul>
  <li>The type of the subject and object of each statement.</li>
  <li>The type that is expected as the object of each predicate.</li>
</ul>
<h3><a href="#type-annotations" name="type-annotations" class="anchor"><span class="anchor-link"></span></a>Type Annotations</h3>
<p>When one or more types cannot be inferred, Gravsearch will return an error message indicating the entities for which it could not determine types. The missing information must then be given by adding type annotations to the query. This can always done by adding statements with the predicate <code>rdf:type</code>. The subject must be a resource or value, and the object must either be <code>knora-api:Resource</code> (if the subject is a resource) or the subject&rsquo;s specific type (if it is a value).</p>
<p>For example, consider this query that uses a non-Knora property:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;
PREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;

CONSTRUCT {
    ?book knora-api:isMainResource true ;
        dcterms:title ?title .

} WHERE {
    ?book dcterms:title ?title .
}
</code></pre>
<p>This produces the error message:</p>
<pre><code>The types of one or more entities could not be determined:
  ?book, &lt;http://purl.org/dc/terms/title&gt;, ?title
</code></pre>
<p>To solve this problem, it is enough to specify the types of <code>?book</code> and <code>?title</code>; the type of the expected object of <code>dcterms:title</code> can then be inferred from the type of <code>?title</code>.</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;
PREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;

CONSTRUCT {
    ?book knora-api:isMainResource true ;
        dcterms:title ?title .

} WHERE {

    ?book rdf:type incunabula:book ;
        dcterms:title ?title .

    ?title rdf:type xsd:string .

}
</code></pre>
<p>It would also be possible to annotate the property itself, using the predicate <code>knora-api:objectType</code>; then the type of <code>?title</code> would be inferred:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;
PREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;

CONSTRUCT {
    ?book knora-api:isMainResource true ;
        dcterms:title ?title .

} WHERE {

    ?book rdf:type incunabula:book ;
        dcterms:title ?title .

    dcterms:title knora-api:objectType xsd:string .

}
</code></pre>
<p>Note that it only makes sense to use <code>dcterms:title</code> in the simple schema, because its object is supposed to be a literal.</p>
<p>Here is another example, using a non-Knora class:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

CONSTRUCT {
    ?person knora-api:isMainResource true .
} WHERE {
    ?person a foaf:Person .
    ?person foaf:familyName ?familyName .
    FILTER(?familyName = &quot;Meier&quot;)
}
</code></pre>
<p>This produces the error message:</p>
<pre><code>Types could not be determined for one or more entities: ?person
</code></pre>
<p>The solution is to specify that <code>?person</code> is a <code>knora-api:Resource</code>:</p>
<pre><code>PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

CONSTRUCT {
    ?person knora-api:isMainResource true .
} WHERE {
    ?person a foaf:Person .
    ?person a knora-api:Resource .
    ?person foaf:familyName ?familyName .
    FILTER(?familyName = &quot;Meier&quot;)
}
</code></pre>
<h3><a href="#inconsistent-types" name="inconsistent-types" class="anchor"><span class="anchor-link"></span></a>Inconsistent Types</h3>
<p>Gravsearch will also reject a query if an entity is used with inconsistent types. For example:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
    ?book knora-api:isMainResource true ;
        incunabula:pubdate ?pubdate .
} WHERE {
    ?book a incunabula:book ;
        incunabula:pubdate ?pubdate .

  FILTER(?pubdate = &quot;JULIAN:1497-03-01&quot;) .
}
</code></pre>
<p>This returns the error message:</p>
<pre><code>One or more entities have inconsistent types:

&lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#pubdate&gt;
  knora-api:objectType &lt;http://api.knora.org/ontology/knora-api/simple/v2#Date&gt; ;
  knora-api:objectType &lt;http://www.w3.org/2001/XMLSchema#string&gt; .

?pubdate rdf:type &lt;http://api.knora.org/ontology/knora-api/simple/v2#Date&gt; ;
  rdf:type &lt;http://www.w3.org/2001/XMLSchema#string&gt; .
</code></pre>
<p>This is because the <code>incunabula</code> ontology says that the object of <code>incunabula:pubdate</code> must be a <code>knora-api:Date</code>, but the <code>FILTER</code> expression compares <code>?pubdate</code> with an <code>xsd:string</code>. The solution is to specify the type of the literal in the <code>FILTER</code>:</p>
<pre><code>PREFIX incunabula: &lt;http://0.0.0.0:3333/ontology/0803/incunabula/simple/v2#&gt;
PREFIX knora-api: &lt;http://api.knora.org/ontology/knora-api/simple/v2#&gt;

CONSTRUCT {
    ?book knora-api:isMainResource true ;
        incunabula:pubdate ?pubdate .
} WHERE {
    ?book a incunabula:book ;
        incunabula:pubdate ?pubdate .

  FILTER(?pubdate = &quot;JULIAN:1497-03-01&quot;^^knora-api:Date) .
}
</code></pre>
</div>
<div>
<a href="https://github.com/dhlab-basel/Knora/tree/master/docs/src/paradox/03-apis/api-v2/query-language.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
6.0.0
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../../03-apis/api-v2/xml-to-standoff-mapping.html" title="XML to Standoff Mapping in API v2" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
XML to Standoff Mapping in API v2
</span>
</div>
</a>
<a href="../../03-apis/api-v2/editing-resources.html" title="Editing Resources" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Editing Resources
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
<div class="md-footer-copyright__highlight">
Copyright 2015-2019 the contributors (see Contributors.md)
</div>
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
<div class="md-footer-social">
<a href="https://github.com/dhlab-basel" class="md-footer-social__link fa fa-github"></a><a href="https://twitter.com/dhlabbasel" class="md-footer-social__link fa fa-twitter"></a>
</div>

</div>
</div>
</footer>

</div>
<script src="../../assets/javascripts/application.5165553b.js"></script>
<script src="../../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../../."}})</script>
<script type="text/javascript" src="../../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
